var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-oEwsclbK.js"(exports, module) {
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map[key] = 1;
      return (val) => val in map;
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$d = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
    const isArray$2 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize$1 = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize$1(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$1(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$2(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$1(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$1(value)) {
        res = value;
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length) return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b) return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$2(a);
      bValidType = isArray$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap$1(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$1(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a2;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].pause();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].resume();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].resume();
            }
          }
        }
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          this.effects.length = 0;
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2, failSilently = false) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      }
    }
    let activeSub;
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn2) {
        this.fn = fn2;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= ~64;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= ~2;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= ~1;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed2 = false) {
      sub.flags |= 8;
      if (isComputed2) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= ~8;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= ~8;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head;
      let tail = sub.depsTail;
      let link = tail;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail) tail = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head;
      sub.depsTail = tail;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= ~16;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= ~2;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= ~2;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= ~4;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (false) ;
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      ""
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      ""
    );
    const ARRAY_ITERATE_KEY = Symbol(
      ""
    );
    function track(target, type, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        {
          dep.track();
        }
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run = (dep) => {
        if (dep) {
          {
            dep.trigger();
          }
        }
      };
      startBatch();
      if (type === "clear") {
        depsMap.forEach(run);
      } else {
        const targetIsArray = isArray$2(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
              run(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run(depsMap.get(key));
          }
          if (isArrayIndex) {
            run(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type) {
            case "add":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$1(target)) {
                run(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function getDepFromReactive(object, key) {
      const depMap = targetMap.get(object);
      return depMap && depMap.get(key);
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray$2(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn2, thisArg) {
        return apply$1(this, "every", fn2, thisArg, void 0, arguments);
      },
      filter(fn2, thisArg) {
        return apply$1(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn2, thisArg) {
        return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
      },
      findIndex(fn2, thisArg) {
        return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
      },
      findLast(fn2, thisArg) {
        return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
      },
      findLastIndex(fn2, thisArg) {
        return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn2, thisArg) {
        return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn2, thisArg) {
        return apply$1(this, "map", fn2, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn2, ...args) {
        return reduce(this, "reduce", fn2, args);
      },
      reduceRight(fn2, ...args) {
        return reduce(this, "reduceRight", fn2, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn2, thisArg) {
        return apply$1(this, "some", fn2, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto$1 = Array.prototype;
    function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto$1[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn2;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn2.call(this, toReactive(item), index, self2);
          };
        } else if (fn2.length > 2) {
          wrappedFn = function(item, index) {
            return fn2.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn2, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn2;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn2.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn2.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn2.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    function hasOwnProperty$c(key) {
      if (!isSymbol$1(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$2(target);
        if (!isReadonly2) {
          let fn2;
          if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
            return fn2;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$c;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$2(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$1(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            const oldValue = get2.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get: get2 } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            }
            get2 ? get2.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger(target, "delete", key, void 0);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const result = target.clear();
            if (hadItems) {
              trigger(
                target,
                "clear",
                void 0,
                void 0
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, isShallow2) {
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
      }
      get value() {
        {
          this.dep.track();
        }
        return this._value;
      }
      set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          {
            this.dep.trigger();
          }
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object) {
      const ret = isArray$2(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
      }
      get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
      }
      get value() {
        return this._value = this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(fn2, setter, isSSR) {
        this.fn = fn2;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        }
      }
      get value() {
        const link = this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction$1(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      return cRef;
    }
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      }
    }
    function watch$1(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, once, scheduler, augmentJob, call } = options;
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$2(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return call ? call(s, 2) : s();
          } else ;
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = call ? () => call(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope && scope.active) {
          remove(scope.effects, effect2);
        }
      };
      if (once && cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call ? call(cb, 3, args) : (
                // @ts-expect-error
                cb(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
      boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call) {
            call(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler) {
        scheduler(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    let isWarning = false;
    function warn$1(msg, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map((a) => {
              var _a2, _b;
              return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$1(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      try {
        return args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$1(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$2(fn2)) {
        const values = [];
        for (let i = 0; i < fn2.length; i++) {
          values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
      if (throwInProd) {
        throw err;
      } else {
        console.error(err);
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex$1(id) {
      let start = flushIndex + 1;
      let end2 = queue.length;
      while (start < end2) {
        const middle = start + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex$1(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$2(cb)) {
        if (activePostFlushCbs && cb.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
        } else if (!(cb.flags & 1)) {
          pendingPostFlushCbs.push(cb);
          cb.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.flags & 2) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          if (cb.flags & 4) {
            cb.flags &= ~1;
          }
          cb();
          if (!(cb.flags & 4)) {
            cb.flags &= ~1;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (cb.flags & 4) {
            cb.flags &= ~1;
          }
          if (!(cb.flags & 8)) cb();
          cb.flags &= ~1;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (false) ;
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= ~1;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs();
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx) return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              if (parentComponent && parentComponent.isCE) {
                parentComponent.ce._teleportTarget = container2;
              }
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountToTarget = () => {
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = prepareAnchor(target, n2, createText, insert);
            if (target) {
              if (namespace !== "svg" && isTargetSVG(target)) {
                namespace = "svg";
              } else if (namespace !== "mathml" && isTargetMathML(target)) {
                namespace = "mathml";
              }
              if (!disabled) {
                mount(target, targetAnchor);
                updateCssVars(n2, false);
              }
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
            updateCssVars(n2, true);
          }
          if (isTeleportDeferred(n2.props)) {
            queuePostRenderEffect(() => {
              mountToTarget();
              n2.el.__isMounted = true;
            }, parentSuspense);
          } else {
            mountToTarget();
          }
        } else {
          if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
            queuePostRenderEffect(() => {
              TeleportImpl.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
              delete n1.el.__isMounted;
            }, parentSuspense);
            return;
          }
          n2.el = n1.el;
          n2.targetStart = n1.targetStart;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
          updateCssVars(n2, disabled);
        }
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (disabled) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode, disabled);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode, isDisabled) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node, anchor;
        if (isDisabled) {
          node = vnode.el;
          anchor = vnode.anchor;
        } else {
          node = vnode.targetStart;
          anchor = vnode.targetAnchor;
        }
        while (node && node !== anchor) {
          if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const child = findNonCommentChild(children);
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getInnerChild$1(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          if (innerChild.type !== Comment) {
            setTransitionHooks(innerChild, enterHooks);
          }
          let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            let leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (!(instance.job.flags & 8)) {
                  instance.update();
                }
                delete leavingHooks.afterLeave;
                oldInnerChild = void 0;
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
                enterHooks.delayedLeave = () => {
                  delayedLeave();
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
              };
            } else {
              oldInnerChild = void 0;
            }
          } else if (oldInnerChild) {
            oldInnerChild = void 0;
          }
          return child;
        };
      }
    };
    function findNonCommentChild(children) {
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      return child;
    }
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$2(hook)) {
          if (hook.every((hook2) => hook2.length <= 1)) done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called) return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called) return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone) postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getInnerChild$1(vnode) {
      if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) {
          return findNonCommentChild(vnode.children);
        }
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$1(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128) keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8236: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$2(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString$1(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$1(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$2(existing) && remove(existing, refValue);
              } else {
                if (!isArray$2(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
    getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$1(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache;
      const sourceIsArray = isArray$2(source);
      if (sourceIsArray || isString$1(source)) {
        const sourceIsReactiveArray = sourceIsArray && isReactive(source);
        let needsWrap = false;
        if (sourceIsReactiveArray) {
          needsWrap = !isShallow(source);
          source = shallowReadArray(source);
        }
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(
            needsWrap ? toReactive(source[i]) : source[i],
            i,
            void 0,
            cached
          );
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached)
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l = keys2.length; i < l; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached);
          }
        }
      } else {
        ret = [];
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        if (isArray$2(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(
          Fragment,
          null,
          [createVNode("slot", props, fallback && fallback())],
          64
        );
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key;
      const rendered = createBlock(
        Fragment,
        {
          key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
          (!validSlotContent && fallback ? "_fb" : "")
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $host: (i) => i.ce,
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs$1() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function normalizePropsOrEmits(props) {
      return isArray$2(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$1(data)) ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$2(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$2(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$2(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$1(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
          {
            watch(getter, handler);
          }
        }
      } else if (isFunction$1(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject$1(raw)) {
        if (isArray$2(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions$1(resolved, base, optionMergeStrategies);
      }
      if (isObject$1(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions$1(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to) ? to.call(this, this) : to,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$2(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$2(to) && isArray$2(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to) return from;
      if (!from) return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin)) ;
            else if (plugin && isFunction$1(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$1(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getComponentPublicInstance(vnode.component);
            }
          },
          onUnmount(cleanupFn) {
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app2._instance,
                16
              );
              render(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          },
          runWithContext(fn2) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn2();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2) needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$2(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$2(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type = propType[index];
                const typeName = isFunction$1(type) && type.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$1(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot$1 = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false) ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot$1(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], namespace, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, namespace, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent, root: root2, type } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode && type.__asyncHydrate) {
                type.__asyncHydrate(
                  el,
                  instance,
                  hydrateSubTree
                );
              } else {
                hydrateSubTree();
              }
            } else {
              if (root2.ce) {
                root2.ce._injectChildStyle(type);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, job, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (job) {
          job.flags |= 8;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
      };
      let isFlushing = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= ~32;
        job.flags &= ~4;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$2(ch1) && isArray$2(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].flags |= 8;
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once } = options;
      const baseWatchOptions = extend({}, options);
      const runsImmediately = cb && immediate || !cb && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$2(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false) ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        setTransitionHooks(root2, vnode.transition);
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    let suspenseId = 0;
    const SuspenseImpl = {
      name: "Suspense",
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
            n2.suspense = n1.suspense;
            n2.suspense.vnode = n2;
            n2.el = n1.el;
            return;
          }
          patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      normalize: normalizeSuspenseChildren
    };
    const Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction$1(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      const {
        p: patch,
        o: { createElement }
      } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        container,
        hiddenContainer,
        anchor,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
      patch(
        null,
        suspense.pendingBranch = vnode.ssContent,
        hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds
      );
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(
          null,
          vnode.ssFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          namespace,
          slotScopeIds
        );
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve(false, true);
      }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(
            pendingBranch,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            if (!isHydrating) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          }
        } else {
          suspense.pendingId = suspenseId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            suspense.resolve(true);
          } else {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          if (newBranch.shapeFlag & 512) {
            suspense.pendingId = newBranch.component.suspenseId;
          } else {
            suspense.pendingId = suspenseId++;
          }
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout);
            } else if (timeout === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      const {
        p: patch,
        m: move,
        um: unmount,
        n: next,
        o: { parentNode, remove: remove2 }
      } = rendererInternals;
      let parentSuspenseId;
      const isSuspensible = isVNodeSuspensible(vnode);
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
          parentSuspenseId = parentSuspense.pendingId;
          parentSuspense.deps++;
        }
      }
      const timeout = vnode.props ? toNumber$1(vnode.props.timeout) : void 0;
      const initialAnchor = anchor;
      const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false, sync = false) {
          const {
            vnode: vnode2,
            activeBranch,
            pendingBranch,
            pendingId,
            effects,
            parentComponent: parentComponent2,
            container: container2
          } = suspense;
          let delayEnter = false;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(
                    pendingBranch,
                    container2,
                    anchor === initialAnchor ? next(activeBranch) : anchor,
                    0
                  );
                  queuePostFlushCb(effects);
                }
              };
            }
            if (activeBranch) {
              if (parentNode(activeBranch.el) === container2) {
                anchor = next(activeBranch);
              }
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent) {
            if (parent.pendingBranch) {
              parent.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent = parent.parent;
          }
          if (!hasUnresolvedAncestor && !delayEnter) {
            queuePostFlushCb(effects);
          }
          suspense.effects = [];
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0 && !sync) {
                parentSuspense.resolve();
              }
            }
          }
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor2 = next(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(
              null,
              fallbackVNode,
              container2,
              anchor2,
              parentComponent2,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(
            activeBranch,
            parentComponent2,
            null,
            // no suspense so unmount hooks fire now
            true
            // shouldRemove
          );
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor2, type) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect, optimized2) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(
              instance,
              vnode2,
              // component may have been moved before resolve.
              // if this is not a hydration, instance.subTree will be the comment
              // placeholder.
              parentNode(hydratedEl || instance.subTree.el),
              // anchor will not be used if this is hydration, so only need to
              // consider the comment placeholder case.
              hydratedEl ? null : next(instance.subTree),
              suspense,
              namespace,
              optimized2
            );
            if (placeholder) {
              remove2(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense2, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(
              suspense.activeBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
          if (suspense.pendingBranch) {
            unmount(
              suspense.pendingBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        node.parentNode,
        // eslint-disable-next-line no-restricted-globals
        document.createElement("div"),
        null,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals,
        true
      );
      const result = hydrateNode(
        node,
        suspense.pendingBranch = vnode.ssContent,
        parentComponent,
        suspense,
        slotScopeIds,
        optimized
      );
      if (suspense.deps === 0) {
        suspense.resolve(false, true);
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(
        isSlotChildren ? children.default : children
      );
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s) {
      let block;
      if (isFunction$1(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
          s._d = false;
          openBlock();
        }
        s = s();
        if (trackBlock) {
          s._d = true;
          block = currentBlock;
          closeBlock();
        }
      }
      if (isArray$2(s)) {
        const singleChild = filterSingleRoot(s);
        s = singleChild;
      }
      s = normalizeVNode(s);
      if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter((c) => c !== s);
      }
      return s;
    }
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$2(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      let el = branch.el;
      while (!el && branch.component) {
        branch = branch.component.subTree;
        el = branch.el;
      }
      vnode.el = el;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
      }
    }
    function isVNodeSuspensible(vnode) {
      const suspensible = vnode.props && vnode.props.suspensible;
      return suspensible != null && suspensible !== false;
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$1(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style)) {
          if (isProxy(style) && !isArray$2(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$2(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$2(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set2) => set2(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup } = Component;
      if (setup) {
        pauseTracking();
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        const isAsyncSetup = isPromise(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(
              extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c;
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.5.13";
    const warn = NOOP;
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt$1 = typeof window !== "undefined" && window.trustedTypes;
    if (tt$1) {
      try {
        policy = /* @__PURE__ */ tt$1.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end2 || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end2 || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const decorate$1 = (t) => {
      t.displayName = "Transition";
      t.props = TransitionPropsValidators;
      return t;
    };
    const Transition = /* @__PURE__ */ decorate$1(
      (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
    );
    const callHook = (hook, args = []) => {
      if (isArray$2(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done, isCancelled) => {
        el._enterCancelled = isCancelled;
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          if (!el._enterCancelled) {
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
          } else {
            addTransitionClass(el, leaveActiveClass);
            forceReflow();
          }
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false, void 0, true);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true, void 0, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$1(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout != null) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto") return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    const CSS_VAR_TEXT = Symbol("");
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      const setVars = () => {
        const vars = getter(instance.proxy);
        if (instance.ce) {
          setVarsOnNode(instance.ce, vars);
        } else {
          setVarsOnVNode(instance.subTree, vars);
        }
        updateTeleports(vars);
      };
      onBeforeUpdate(() => {
        queuePostFlushCb(setVars);
      });
      onMounted(() => {
        watch(setVars, NOOP, { flush: "post" });
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor) break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for (const key in vars) {
          style.setProperty(`--${key}`, vars[key]);
          cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
      }
    }
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$1(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString$1(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$2(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null) val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize$1(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(
            key,
            isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(attrName || key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$2(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
      ) {
        patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$1(value)) {
        return false;
      }
      return key in el;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const decorate = (t) => {
      delete t.props.mode;
      return t;
    };
    const TransitionGroupImpl = /* @__PURE__ */ decorate({
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    });
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing) return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue$2(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers)) return;
        }
        return fn2(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      const cache = fn2._withKeys || (fn2._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some(
          (k) => k === eventKey || keyNames[k] === eventKey
        )) {
          return fn2(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$1(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    var isVue2 = false;
    /*!
     * pinia v2.3.1
     * (c) 2025 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia) => activePinia = pinia;
    const piniaSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function isPlainObject(o) {
      return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope = effectScope(true);
      const state = scope.run(() => ref({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia = markRaw({
        install(app2) {
          setActivePinia(pinia);
          {
            pinia._a = app2;
            app2.provide(piniaSymbol, pinia);
            app2.config.globalProperties.$pinia = pinia;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      return pinia;
    }
    const noop$2 = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn2) => fn2();
    const ACTION_MARKER = Symbol();
    const ACTION_NAME = Symbol();
    function mergeReactiveObjects(target, patchToApply) {
      if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
      } else if (target instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target.add, target);
      }
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
          target[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target[key] = subPatch;
        }
      }
      return target;
    }
    const skipHydrateSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function shouldHydrate(obj) {
      return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign: assign$1 } = Object;
    function isComputed(o) {
      return !!(isRef(o) && o.effect);
    }
    function createOptionsStore(id, options, pinia, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia.state.value[id];
      let store;
      function setup() {
        if (!initialState && true) {
          {
            pinia.state.value[id] = state ? state() : {};
          }
        }
        const localState = toRefs(pinia.state.value[id]);
        return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia);
            const store2 = pinia._s.get(id);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id, setup, options, pinia, hot, true);
      return store;
    }
    function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
      let scope;
      const optionsForPlugin = assign$1({ actions: {} }, options);
      const $subscribeOptions = { deep: true };
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia.state.value[$id];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia.state.value[$id] = {};
        }
      }
      ref({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia.state.value[$id]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state } = options;
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign$1($state, newState);
        });
      } : (
        /* istanbul ignore next */
        noop$2
      );
      function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
      }
      const action = (fn2, name = "") => {
        if (ACTION_MARKER in fn2) {
          fn2[ACTION_NAME] = name;
          return fn2;
        }
        const wrappedAction = function() {
          setActivePinia(pinia);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name: wrappedAction[ACTION_NAME],
            store,
            after,
            onError
          });
          let ret;
          try {
            ret = fn2.apply(this && this.$id === $id ? this : store, args);
          } catch (error) {
            triggerSubscriptions(onErrorCallbackList, error);
            throw error;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error) => {
              triggerSubscriptions(onErrorCallbackList, error);
              return Promise.reject(error);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name;
        return wrappedAction;
      };
      const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign$1({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(partialStore);
      pinia._s.set($id, store);
      const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
      for (const key in setupStore) {
        const prop = setupStore[key];
        if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop)) {
              if (isRef(prop)) {
                prop.value = initialState[key];
              } else {
                mergeReactiveObjects(prop, initialState[key]);
              }
            }
            {
              pinia.state.value[$id][key] = prop;
            }
          }
        } else if (typeof prop === "function") {
          const actionValue = action(prop, key);
          {
            setupStore[key] = actionValue;
          }
          optionsForPlugin.actions[key] = prop;
        } else ;
      }
      {
        assign$1(store, setupStore);
        assign$1(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => pinia.state.value[$id],
        set: (state) => {
          $patch(($state) => {
            assign$1($state, state);
          });
        }
      });
      pinia._p.forEach((extender) => {
        {
          assign$1(store, scope.run(() => extender({
            store,
            app: pinia._a,
            pinia,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineStore(idOrOptions, setup, setupOptions) {
      let id;
      let options;
      const isSetupStore = typeof setup === "function";
      if (typeof idOrOptions === "string") {
        id = idOrOptions;
        options = isSetupStore ? setupOptions : setup;
      } else {
        options = idOrOptions;
        id = idOrOptions.id;
      }
      function useStore(pinia, hot) {
        const hasContext = hasInjectionContext();
        pinia = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia || (hasContext ? inject(piniaSymbol, null) : null);
        if (pinia)
          setActivePinia(pinia);
        pinia = activePinia;
        if (!pinia._s.has(id)) {
          if (isSetupStore) {
            createSetupStore(id, setup, options, pinia);
          } else {
            createOptionsStore(id, options, pinia);
          }
        }
        const store = pinia._s.get(id);
        return store;
      }
      useStore.$id = id;
      return useStore;
    }
    const _export_sfc$1 = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$O = {};
    function _sfc_render$9(_ctx, _cache) {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createVNode(_component_router_view)
        ]),
        fallback: withCtx(() => _cache[0] || (_cache[0] = [
          createBaseVNode("p", { style: { "color": "black", "align-items": "center" } }, "Loading...", -1)
        ])),
        _: 1
      });
    }
    const App = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["render", _sfc_render$9]]);
    /*!
      * vue-router v4.5.0
      * (c) 2024 Eduardo San Martin Morote
      * @license MIT
      */
    const isBrowser = typeof document !== "undefined";
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module" || // support CF with dynamic imports that do not
      // add the Module string tag
      obj.default && isRouteComponent(obj.default);
    }
    const assign = Object.assign;
    function applyToParams(fn2, params) {
      const newParams = {};
      for (const key in params) {
        const value = params[key];
        newParams[key] = isArray$1(value) ? value.map(fn2) : fn2(value);
      }
      return newParams;
    }
    const noop$1 = () => {
    };
    const isArray$1 = Array.isArray;
    const HASH_RE = /#/g;
    const AMPERSAND_RE = /&/g;
    const SLASH_RE = /\//g;
    const EQUAL_RE = /=/g;
    const IM_RE = /\?/g;
    const PLUS_RE = /\+/g;
    const ENC_BRACKET_OPEN_RE = /%5B/g;
    const ENC_BRACKET_CLOSE_RE = /%5D/g;
    const ENC_CARET_RE = /%5E/g;
    const ENC_BACKTICK_RE = /%60/g;
    const ENC_CURLY_OPEN_RE = /%7B/g;
    const ENC_PIPE_RE = /%7C/g;
    const ENC_CURLY_CLOSE_RE = /%7D/g;
    const ENC_SPACE_RE = /%20/g;
    function commonEncode(text) {
      return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text) {
      return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text) {
      return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text) {
      return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text) {
      return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text) {
      return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
    }
    function decode(text) {
      try {
        return decodeURIComponent("" + text);
      } catch (err) {
      }
      return "" + text;
    }
    const TRAILING_SLASH_RE = /\/$/;
    const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash,
        path,
        query,
        hash: decode(hash)
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base) {
      if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
      return pathname.slice(base.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a, b) {
      const aLastIndex = a.matched.length - 1;
      const bLastIndex = b.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
    }
    function isSameRouteRecord(a, b) {
      return (a.aliasOf || a) === (b.aliasOf || b);
    }
    function isSameRouteLocationParams(a, b) {
      if (Object.keys(a).length !== Object.keys(b).length)
        return false;
      for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a, b) {
      return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
    }
    function isEquivalentArray(a, b) {
      return isArray$1(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
    }
    function resolveRelativePath(to, from) {
      if (to.startsWith("/"))
        return to;
      if (!to)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to.split("/");
      const lastToSegment = toSegments[toSegments.length - 1];
      if (lastToSegment === ".." || lastToSegment === ".") {
        toSegments.push("");
      }
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
    }
    const START_LOCATION_NORMALIZED = {
      path: "/",
      // TODO: could we use a symbol in the future?
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    function normalizeBase(base) {
      if (!base) {
        if (isBrowser) {
          const baseEl = document.querySelector("base");
          base = baseEl && baseEl.getAttribute("href") || "/";
          base = base.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base = "/";
        }
      }
      if (base[0] !== "/" && base[0] !== "#")
        base = "/" + base;
      return removeTrailingSlash(base);
    }
    const BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base, location2) {
      return base.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el, offset) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0)
      };
    }
    const computeScrollPosition = () => ({
      left: window.scrollX,
      top: window.scrollY
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el) {
          return;
        }
        scrollToOptions = getElementPosition(el, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
      }
    }
    function getScrollKey(path, delta) {
      const position = history.state ? history.state.position - delta : -1;
      return position + path;
    }
    const scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key, scrollPosition) {
      scrollPositions.set(key, scrollPosition);
    }
    function getSavedScrollPosition(key) {
      const scroll = scrollPositions.get(key);
      scrollPositions.delete(key);
      return scroll;
    }
    let createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base, location2) {
      const { pathname, search, hash } = location2;
      const hashPos = base.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
        let pathFromHash = hash.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base);
      return path + search + hash;
    }
    function useHistoryListeners(base, historyState, currentLocation, replace) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
          currentLocation.value = to;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta = fromState ? state.position - fromState.position : 0;
        } else {
          replace(to);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta,
            type: NavigationType.pop,
            direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index = listeners.indexOf(callback);
          if (index > -1)
            listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener, {
        passive: true
      });
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back, current, forward, replaced = false, computeScroll = false) {
      return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          // the length is off by one, we need to decrease it
          position: history2.length - 1,
          replaced: true,
          // don't add a scroll as the user may have an anchor, and we want
          // scrollBehavior to be triggered without a saved position
          scroll: null
        }, true);
      }
      function changeLocation(to, state, replace2) {
        const hashIndex = base.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
        try {
          history2[replace2 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            console.error(err);
          }
          location2[replace2 ? "replace" : "assign"](url);
        }
      }
      function replace(to, data) {
        const state = assign({}, history2.state, buildState(
          historyState.value.back,
          // keep back and forward entries but override current position
          to,
          historyState.value.forward,
          true
        ), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
      }
      function push(to, data) {
        const currentState = assign(
          {},
          // use current history state to gracefully handle a wrong call to
          // history.replaceState
          // https://github.com/vuejs/router/issues/366
          historyState.value,
          history2.state,
          {
            forward: to,
            scroll: computeScrollPosition()
          }
        );
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace
      };
    }
    function createWebHistory(base) {
      base = normalizeBase(base);
      const historyNavigation = useHistoryStateNavigation(base);
      const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go(delta, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta);
      }
      const routerHistory = assign({
        // it's overridden right after
        location: "",
        base,
        go,
        createHref: createHref.bind(null, base)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function createWebHashHistory(base) {
      base = location.host ? base || location.pathname + location.search : "";
      if (!base.includes("#"))
        base += "#";
      return createWebHistory(base);
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    const NavigationFailureSymbol = Symbol("");
    var NavigationFailureType;
    (function(NavigationFailureType2) {
      NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
      NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
      NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
    })(NavigationFailureType || (NavigationFailureType = {}));
    function createRouterError(type, params) {
      {
        return assign(new Error(), {
          type,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error, type) {
      return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
    }
    const BASE_PARAM_PATTERN = "[^/]+?";
    const BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern = options.start ? "^" : "";
      const keys2 = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [
          90
          /* PathScore.Root */
        ];
        if (options.strict && !segment.length)
          pattern += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token.type === 0) {
            if (!tokenIndex)
              pattern += "/";
            pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token.type === 1) {
            const { value, repeatable, optional, regexp } = token;
            keys2.push({
              name: value,
              repeatable,
              optional
            });
            const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re2 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re2})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
            if (!tokenIndex)
              subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
              // or /:p?-:p2
              optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional)
              subPattern += "?";
            pattern += subPattern;
            subSegmentScore += 20;
            if (optional)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re2 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern += "/?";
      if (options.end)
        pattern += "$";
      else if (options.strict && !pattern.endsWith("/"))
        pattern += "(?:/|$)";
      const re = new RegExp(pattern, options.sensitive ? "" : "i");
      function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
          return null;
        for (let i = 1; i < match.length; i++) {
          const value = match[i] || "";
          const key = keys2[i - 1];
          params[key.name] = value && key.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token of segment) {
            if (token.type === 0) {
              path += token.value;
            } else if (token.type === 1) {
              const { value, repeatable, optional } = token;
              const param = value in params ? params[value] : "";
              if (isArray$1(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text = isArray$1(param) ? param.join("/") : param;
              if (!text) {
                if (optional) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text;
            }
          }
        }
        return path || "/";
      }
      return {
        re,
        score,
        keys: keys2,
        parse,
        stringify
      };
    }
    function compareScoreArray(a, b) {
      let i = 0;
      while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        if (diff)
          return diff;
        i++;
      }
      if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
      } else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a, b) {
      let i = 0;
      const aScore = a.score;
      const bScore = b.score;
      while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        if (comp)
          return comp;
        i++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    const ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(`Invalid path "${path}"`);
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i = 0;
      let char;
      let buffer = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer = "";
      }
      function addCharToBuffer() {
        buffer += char;
      }
      while (i < path.length) {
        char = path[i++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record, parent, options) {
      const parser = tokensToParser(tokenizePath(record.path), options);
      const matcher = assign(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: []
      });
      if (parent) {
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
          parent.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes2, globalOptions) {
      const matchers2 = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record, parent, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        const normalizedRecords = [mainNormalizedRecord];
        if ("alias" in record) {
          const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
          for (const alias of aliases) {
            normalizedRecords.push(
              // we need to normalize again to ensure the `mods` property
              // being non enumerable
              normalizeRouteRecord(assign({}, mainNormalizedRecord, {
                // this allows us to hold a copy of the `components` option
                // so that async components cache is hold on the original record
                components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
                path: alias,
                // we might be the child of an alias
                aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
                // the aliases are always of the same kind as the original since they
                // are defined on the same record
              }))
            );
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent && path[0] !== "/") {
            const parentPath = parent.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record.name && !isAliasRecord(matcher)) {
              removeRoute(record.name);
            }
          }
          if (isMatchable(matcher)) {
            insertMatcher(matcher);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i = 0; i < children.length; i++) {
              addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
            }
          }
          originalRecord = originalRecord || matcher;
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop$1;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers2.splice(matchers2.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index = matchers2.indexOf(matcherRef);
          if (index > -1) {
            matchers2.splice(index, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers2;
      }
      function insertMatcher(matcher) {
        const index = findInsertionIndex(matcher, matchers2);
        matchers2.splice(index, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve2(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          name = matcher.record.name;
          params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(
              currentLocation.params,
              // only keep params that exist in the resolved location
              // only keep optional params coming from a parent record
              matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)
            ),
            // discard any existing params in the current location that do not exist here
            // #1497 this ensures better active/exact matching
            location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
          );
          path = matcher.stringify(params);
        } else if (location2.path != null) {
          path = location2.path;
          matcher = matchers2.find((m) => m.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers2.find((m) => m.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes2.forEach((route) => addRoute(route));
      function clearRoutes() {
        matchers2.length = 0;
        matcherMap.clear();
      }
      return {
        addRoute,
        resolve: resolve2,
        removeRoute,
        clearRoutes,
        getRoutes,
        getRecordMatcher
      };
    }
    function paramsFromLocation(params, keys2) {
      const newParams = {};
      for (const key of keys2) {
        if (key in params)
          newParams[key] = params[key];
      }
      return newParams;
    }
    function normalizeRouteRecord(record) {
      const normalized = {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: record.aliasOf,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        // must be declared afterwards
        // mods: {},
        components: "components" in record ? record.components || null : record.component && { default: record.component }
      };
      Object.defineProperty(normalized, "mods", {
        value: {}
      });
      return normalized;
    }
    function normalizeRecordProps(record) {
      const propsObject = {};
      const props = record.props || false;
      if ("component" in record) {
        propsObject.default = props;
      } else {
        for (const name in record.components)
          propsObject[name] = typeof props === "object" ? props[name] : props;
      }
      return propsObject;
    }
    function isAliasRecord(record) {
      while (record) {
        if (record.record.aliasOf)
          return true;
        record = record.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record) => assign(meta, record.meta), {});
    }
    function mergeOptions(defaults, partialOptions) {
      const options = {};
      for (const key in defaults) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
      }
      return options;
    }
    function findInsertionIndex(matcher, matchers2) {
      let lower = 0;
      let upper = matchers2.length;
      while (lower !== upper) {
        const mid = lower + upper >> 1;
        const sortOrder = comparePathParserScore(matcher, matchers2[mid]);
        if (sortOrder < 0) {
          upper = mid;
        } else {
          lower = mid + 1;
        }
      }
      const insertionAncestor = getInsertionAncestor(matcher);
      if (insertionAncestor) {
        upper = matchers2.lastIndexOf(insertionAncestor, upper - 1);
      }
      return upper;
    }
    function getInsertionAncestor(matcher) {
      let ancestor = matcher;
      while (ancestor = ancestor.parent) {
        if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
          return ancestor;
        }
      }
      return;
    }
    function isMatchable({ record }) {
      return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i = 0; i < searchParams.length; ++i) {
        const searchParam = searchParams[i].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
          let currentValue = query[key];
          if (!isArray$1(currentValue)) {
            currentValue = query[key] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key] = value;
        }
      }
      return query;
    }
    function stringifyQuery(query) {
      let search = "";
      for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key;
          }
          continue;
        }
        const values = isArray$1(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key in query) {
        const value = query[key];
        if (value !== void 0) {
          normalizedQuery[key] = isArray$1(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    const matchedRouteKey = Symbol("");
    const viewDepthKey = Symbol("");
    const routerKey = Symbol("");
    const routeLocationKey = Symbol("");
    const routerViewLocationKey = Symbol("");
    function useCallbacks() {
      let handlers = [];
      function add(handler) {
        handlers.push(handler);
        return () => {
          const i = handlers.indexOf(handler);
          if (i > -1)
            handlers.splice(i, 1);
        };
      }
      function reset() {
        handlers = [];
      }
      return {
        add,
        list: () => handlers.slice(),
        reset
      };
    }
    function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn2) => fn2()) {
      const enterCallbackArray = record && // name is defined if record is because of the function overload
      (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
      return () => new Promise((resolve2, reject) => {
        const next = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
            record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next);
        guardCall.catch((err) => reject(err));
      });
    }
    function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn2) => fn2()) {
      const guards = [];
      for (const record of matched) {
        for (const name in record.components) {
          let rawComponent = record.components[name];
          if (guardType !== "beforeRouteEnter" && !record.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
          } else {
            let componentPromise = rawComponent();
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.mods[name] = resolved;
              record.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
            }));
          }
        }
      }
      return guards;
    }
    function useLink(props) {
      const router2 = inject(routerKey);
      const currentRoute = inject(routeLocationKey);
      const route = computed(() => {
        const to = unref(props.to);
        return router2.resolve(to);
      });
      const activeRecordIndex = computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
          return index;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
          // we are dealing with nested routes
          length > 1 && // if the parent and matched route have the same path, this link is
          // referring to the empty child. Or we currently are on a different
          // child of the same parent
          getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
          currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
        );
      });
      const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e = {}) {
        if (guardEvent(e)) {
          const p2 = router2[unref(props.replace) ? "replace" : "push"](
            unref(props.to)
            // avoid uncaught errors are they are logged anyway
          ).catch(noop$1);
          if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
            document.startViewTransition(() => p2);
          }
          return p2;
        }
        return Promise.resolve();
      }
      return {
        route,
        href: computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    function preferSingleVNode(vnodes) {
      return vnodes.length === 1 ? vnodes[0] : vnodes;
    }
    const RouterLinkImpl = /* @__PURE__ */ defineComponent({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink,
      setup(props, { slots }) {
        const link = reactive(useLink(props));
        const { options } = inject(routerKey);
        const elClass = computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
          // [getLinkClass(
          //   props.inactiveClass,
          //   options.linkInactiveClass,
          //   'router-link-inactive'
          // )]: !link.isExactActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
        }));
        return () => {
          const children = slots.default && preferSingleVNode(slots.default(link));
          return props.custom ? children : h("a", {
            "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
            href: link.href,
            // this would override user added attrs but Vue will still add
            // the listener, so we end up triggering both
            onClick: link.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    const RouterLink = RouterLinkImpl;
    function guardEvent(e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      if (e.button !== void 0 && e.button !== 0)
        return;
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const target = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target))
          return;
      }
      if (e.preventDefault)
        e.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record) {
      return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
    }
    const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    const RouterViewImpl = /* @__PURE__ */ defineComponent({
      name: "RouterView",
      // #674 we manually inherit them
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      // Better compat for @vue/compat users
      // https://github.com/vuejs/router/issues/1315
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        const injectedRoute = inject(routerViewLocationKey);
        const routeToDisplay = computed(() => props.route || injectedRoute.value);
        const injectedDepth = inject(viewDepthKey, 0);
        const depth = computed(() => {
          let initialDepth = unref(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
        provide(viewDepthKey, computed(() => depth.value + 1));
        provide(matchedRouteKey, matchedRouteRef);
        provide(routerViewLocationKey, routeToDisplay);
        const viewRef = ref();
        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
          if (to) {
            to.instances[name] = instance;
            if (from && from !== to && instance && instance === oldInstance) {
              if (!to.leaveGuards.size) {
                to.leaveGuards = from.leaveGuards;
              }
              if (!to.updateGuards.size) {
                to.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to && // if there is no instance but to and from are the same this might be
          // the first visit
          (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
            (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = h(ViewComponent, assign({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) || component
          );
        };
      }
    });
    function normalizeSlot(slot, data) {
      if (!slot)
        return null;
      const slotContent = slot(data);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    const RouterView = RouterViewImpl;
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
      const routerHistory = options.history;
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = (
        // @ts-expect-error: intentionally avoid the type check
        applyToParams.bind(null, decode)
      );
      function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
          parent = matcher.getRecordMatcher(parentOrRoute);
          record = route;
        } else {
          record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve2(rawLocation, currentLocation) {
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          return assign(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if (rawLocation.path != null) {
          matcherLocation = assign({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign({}, rawLocation.params);
          for (const key in targetParams) {
            if (targetParams[key] == null) {
              delete targetParams[key];
            }
          }
          matcherLocation = assign({}, rawLocation, {
            params: encodeParams(targetParams)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || "";
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
          hash: encodeHash(hash),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        return assign({
          fullPath,
          // keep the hash encoded so fullPath is effectively path + encodedQuery +
          // hash
          hash,
          query: (
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
          )
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to) {
        return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
      }
      function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
          return createRouterError(8, {
            from,
            to
          });
        }
      }
      function push(to) {
        return pushWithRedirect(to);
      }
      function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
      }
      function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
              // force empty params
              { path: newTargetLocation }
            );
            newTargetLocation.params = {};
          }
          return assign({
            query: to.query,
            hash: to.hash,
            // avoid transferring params if the redirect has a path
            params: newTargetLocation.path != null ? {} : to.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = pendingLocation = resolve2(to);
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        const replace2 = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(
            assign(locationAsObject(shouldRedirect), {
              state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
              force,
              replace: replace2
            }),
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation
          );
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(
            from,
            from,
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true,
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false
          );
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
          // navigation redirects still mark the router as ready
          isNavigationFailure(
            error,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          ) ? error : markAsReady(error)
        ) : (
          // reject any unknown error
          triggerError(error, toLocation, from)
        )).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(
              failure2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              return pushWithRedirect(
                // keep options
                assign({
                  // preserve an existing replacement but allow the redirect to override it
                  replace: replace2
                }, locationAsObject(failure2.to), {
                  state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                  force
                }),
                // preserve the original redirectedFrom if any
                redirectedFrom || toLocation
              );
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
      }
      function runWithContext(fn2) {
        const app2 = installedApps.values().next().value;
        return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn2) : fn2();
      }
      function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
        for (const record of leavingRecords) {
          record.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
          for (const record of updatingRecords) {
            record.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record of enteringRecords) {
            if (record.beforeEnter) {
              if (isArray$1(record.beforeEnter)) {
                for (const beforeEnter of record.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to, from));
              } else {
                guards.push(guardToPromiseFn(record.beforeEnter, to, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to.matched.forEach((record) => record.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(
          err,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to, from, failure) {
        afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
      }
      function finalizeNavigation(toLocation, from, isPush, replace2, data) {
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
          return error;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        if (isPush) {
          if (replace2 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign({
              scroll: isFirstNavigation && state && state.scroll
            }, data));
          else
            routerHistory.push(toLocation.fullPath, data);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
          if (!router2.listening)
            return;
          const toLocation = resolve2(to);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign(shouldRedirect, { replace: true, force: true }), toLocation).catch(noop$1);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error) => {
            if (isNavigationFailure(
              error,
              4 | 8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              return error;
            }
            if (isNavigationFailure(
              error,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              pushWithRedirect(
                assign(locationAsObject(error.to), {
                  force: true
                }),
                toLocation
                // avoid an uncaught rejection, let push call triggerError
              ).then((failure) => {
                if (isNavigationFailure(
                  failure,
                  4 | 16
                  /* ErrorTypes.NAVIGATION_DUPLICATED */
                ) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop$1);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(
              // after navigation, all matched components are resolved
              toLocation,
              from,
              false
            );
            if (failure) {
              if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
              // entry while a different route is displayed
              !isNavigationFailure(
                failure,
                8
                /* ErrorTypes.NAVIGATION_CANCELLED */
              )) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              )) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop$1);
        });
      }
      let readyHandlers = useCallbacks();
      let errorListeners = useCallbacks();
      let ready;
      function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorListeners.list();
        if (list.length) {
          list.forEach((handler) => handler(error, to, from));
        } else {
          console.error(error);
        }
        return Promise.reject(error);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve22, reject) => {
          readyHandlers.add([resolve22, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
      }
      const go = (delta) => routerHistory.go(delta);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router2 = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        clearRoutes: matcher.clearRoutes,
        hasRoute,
        getRoutes,
        resolve: resolve2,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorListeners.add,
        isReady,
        install(app2) {
          const router22 = this;
          app2.component("RouterLink", RouterLink);
          app2.component("RouterView", RouterView);
          app2.config.globalProperties.$router = router22;
          Object.defineProperty(app2.config.globalProperties, "$route", {
            enumerable: true,
            get: () => unref(currentRoute)
          });
          if (isBrowser && // used for the initial navigation client side to avoid pushing
          // multiple times when the router is used in multiple apps
          !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
            });
          }
          const reactiveRoute = {};
          for (const key in START_LOCATION_NORMALIZED) {
            Object.defineProperty(reactiveRoute, key, {
              get: () => currentRoute.value[key],
              enumerable: true
            });
          }
          app2.provide(routerKey, router22);
          app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
          app2.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app2.unmount;
          installedApps.add(app2);
          app2.unmount = function() {
            installedApps.delete(app2);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
        }
      };
      function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
      }
      return router2;
    }
    function extractChangingRecords(to, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to.matched.length);
      for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
          if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
          if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
      const handleEvent = (event) => {
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) {
          return oursHandler == null ? void 0 : oursHandler(event);
        }
      };
      return handleEvent;
    };
    var __defProp$9 = Object.defineProperty;
    var __defProps$6 = Object.defineProperties;
    var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
    var __hasOwnProp$b = Object.prototype.hasOwnProperty;
    var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$9 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp$b.call(b, prop))
          __defNormalProp$9(a, prop, b[prop]);
      if (__getOwnPropSymbols$b)
        for (var prop of __getOwnPropSymbols$b(b)) {
          if (__propIsEnum$b.call(b, prop))
            __defNormalProp$9(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
    function computedEager(fn2, options) {
      var _a2;
      const result = shallowRef();
      watchEffect(() => {
        result.value = fn2();
      }, __spreadProps$6(__spreadValues$9({}, options), {
        flush: (_a2 = void 0) != null ? _a2 : "sync"
      }));
      return readonly(result);
    }
    var _a;
    const isClient = typeof window !== "undefined";
    const isString = (val) => typeof val === "string";
    const noop = () => {
    };
    const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
    function resolveUnref(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    function createFilterWrapper(filter, fn2) {
      function wrapper(...args) {
        return new Promise((resolve2, reject) => {
          Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
        });
      }
      return wrapper;
    }
    function debounceFilter(ms, options = {}) {
      let timer;
      let maxTimer;
      let lastRejector = noop;
      const _clearTimeout = (timer2) => {
        clearTimeout(timer2);
        lastRejector();
        lastRejector = noop;
      };
      const filter = (invoke) => {
        const duration = resolveUnref(ms);
        const maxDuration = resolveUnref(options.maxWait);
        if (timer)
          _clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
          if (maxTimer) {
            _clearTimeout(maxTimer);
            maxTimer = null;
          }
          return Promise.resolve(invoke());
        }
        return new Promise((resolve2, reject) => {
          lastRejector = options.rejectOnCancel ? reject : resolve2;
          if (maxDuration && !maxTimer) {
            maxTimer = setTimeout(() => {
              if (timer)
                _clearTimeout(timer);
              maxTimer = null;
              resolve2(invoke());
            }, maxDuration);
          }
          timer = setTimeout(() => {
            if (maxTimer)
              _clearTimeout(maxTimer);
            maxTimer = null;
            resolve2(invoke());
          }, duration);
        });
      };
      return filter;
    }
    function identity$1(arg) {
      return arg;
    }
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function useDebounceFn(fn2, ms = 200, options = {}) {
      return createFilterWrapper(debounceFilter(ms, options), fn2);
    }
    function refDebounced(value, ms = 200, options = {}) {
      const debounced = ref(value.value);
      const updater = useDebounceFn(() => {
        debounced.value = value.value;
      }, ms, options);
      watch(value, () => updater());
      return debounced;
    }
    function tryOnMounted(fn2, sync = true) {
      if (getCurrentInstance())
        onMounted(fn2);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer = null;
      function clear() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function stop() {
        isPending.value = false;
        clear();
      }
      function start(...args) {
        clear();
        isPending.value = true;
        timer = setTimeout(() => {
          isPending.value = false;
          timer = null;
          cb(...args);
        }, resolveUnref(interval));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start();
      }
      tryOnScopeDispose(stop);
      return {
        isPending: readonly(isPending),
        start,
        stop
      };
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = resolveUnref(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    const defaultDocument = isClient ? window.document : void 0;
    function useEventListener(...args) {
      let target;
      let events;
      let listeners;
      let options;
      if (isString(args[0]) || Array.isArray(args[0])) {
        [events, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events, listeners, options] = args;
      }
      if (!target)
        return noop;
      if (!Array.isArray(events))
        events = [events];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event, listener, options2) => {
        el.addEventListener(event, listener, options2);
        return () => el.removeEventListener(event, listener, options2);
      };
      const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
        cleanup();
        if (!el)
          return;
        cleanups.push(...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        }));
      }, { immediate: true, flush: "post" });
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
      }
      let shouldListen = true;
      const shouldIgnore = (event) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event.target === el || event.composedPath().includes(el));
          }
        });
      };
      const listener = (event) => {
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el))
          return;
        if (event.detail === 0)
          shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e) => {
          const el = unrefElement(target);
          if (el)
            shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          var _a2;
          const el = unrefElement(target);
          if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
            handler(event);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useSupported(callback, sync = false) {
      const isSupported = ref();
      const update = () => isSupported.value = Boolean(callback());
      update();
      tryOnMounted(update, sync);
      return isSupported;
    }
    const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    _global[globalKey] = _global[globalKey] || {};
    function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
      if (!document2)
        return ref("visible");
      const visibility = ref(document2.visibilityState);
      useEventListener(document2, "visibilitychange", () => {
        visibility.value = document2.visibilityState;
      });
      return visibility;
    }
    var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
    var __hasOwnProp$g = Object.prototype.hasOwnProperty;
    var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
    var __objRest$2 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$g)
        for (var prop of __getOwnPropSymbols$g(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useResizeObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new ResizeObserver(callback);
          observer.observe(el, observerOptions);
        }
      }, { immediate: true, flush: "post" });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
    var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
    var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
    var __objRest$1 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$8)
        for (var prop of __getOwnPropSymbols$8(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useMutationObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new MutationObserver(callback);
          observer.observe(el, mutationOptions);
        }
      }, { immediate: true });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    var SwipeDirection;
    (function(SwipeDirection2) {
      SwipeDirection2["UP"] = "UP";
      SwipeDirection2["RIGHT"] = "RIGHT";
      SwipeDirection2["DOWN"] = "DOWN";
      SwipeDirection2["LEFT"] = "LEFT";
      SwipeDirection2["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));
    var __defProp = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    const _TransitionPresets = {
      easeInSine: [0.12, 0, 0.39, 0],
      easeOutSine: [0.61, 1, 0.88, 1],
      easeInOutSine: [0.37, 0, 0.63, 1],
      easeInQuad: [0.11, 0, 0.5, 0],
      easeOutQuad: [0.5, 1, 0.89, 1],
      easeInOutQuad: [0.45, 0, 0.55, 1],
      easeInCubic: [0.32, 0, 0.67, 0],
      easeOutCubic: [0.33, 1, 0.68, 1],
      easeInOutCubic: [0.65, 0, 0.35, 1],
      easeInQuart: [0.5, 0, 0.75, 0],
      easeOutQuart: [0.25, 1, 0.5, 1],
      easeInOutQuart: [0.76, 0, 0.24, 1],
      easeInQuint: [0.64, 0, 0.78, 0],
      easeOutQuint: [0.22, 1, 0.36, 1],
      easeInOutQuint: [0.83, 0, 0.17, 1],
      easeInExpo: [0.7, 0, 0.84, 0],
      easeOutExpo: [0.16, 1, 0.3, 1],
      easeInOutExpo: [0.87, 0, 0.13, 1],
      easeInCirc: [0.55, 0, 1, 0.45],
      easeOutCirc: [0, 0.55, 0.45, 1],
      easeInOutCirc: [0.85, 0, 0.15, 1],
      easeInBack: [0.36, 0, 0.66, -0.56],
      easeOutBack: [0.34, 1.56, 0.64, 1],
      easeInOutBack: [0.68, -0.6, 0.32, 1.6]
    };
    __spreadValues({
      linear: identity$1
    }, _TransitionPresets);
    function useWindowFocus({ window: window2 = defaultWindow } = {}) {
      if (!window2)
        return ref(false);
      const focused = ref(window2.document.hasFocus());
      useEventListener(window2, "blur", () => {
        focused.value = false;
      });
      useEventListener(window2, "focus", () => {
        focused.value = true;
      });
      return focused;
    }
    const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$e.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$d = Object.prototype;
    var nativeObjectToString = objectProto$d.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var INFINITY$1 = 1 / 0;
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$c = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue$1(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue$1(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root, "WeakMap");
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      array.length;
      var index = fromIndex + 1;
      while (index--) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var objectProto$a = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$6.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (predicate(value)) {
          {
            arrayPush(result, value);
          }
        } else {
          result[result.length] = value;
        }
      }
      return result;
    }
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array) : [];
    }
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);
        case boolTag$2:
        case dateTag$2:
          return new Ctor(+object);
        case dataViewTag$2:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$3:
          return new Ctor();
        case numberTag$2:
        case stringTag$2:
          return new Ctor(object);
        case regexpTag$2:
          return cloneRegExp(object);
        case setTag$3:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object);
      }
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    var mapTag$2 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag$2;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$2 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag$2;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack2.set(array, other);
      stack2.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array);
      stack2["delete"](other);
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack2.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    var now = function() {
      return root.Date.now();
    };
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce$1(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      return baseFindIndex(array, baseIteratee(predicate), index);
    }
    function fromPairs(pairs) {
      var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isNil(value) {
      return value == null;
    }
    function isUndefined$1(value) {
      return value === void 0;
    }
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    const isUndefined = (val) => val === void 0;
    const isBoolean = (val) => typeof val === "boolean";
    const isNumber = (val) => typeof val === "number";
    const isElement = (e) => {
      if (typeof Element === "undefined")
        return false;
      return e instanceof Element;
    };
    const isPropAbsent = (prop) => {
      return isNil(prop);
    };
    const isStringNumber = (val) => {
      if (!isString$1(val)) {
        return false;
      }
      return !Number.isNaN(Number(val));
    };
    const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    const capitalize = (str) => capitalize$1(str);
    const keysOf = (arr) => Object.keys(arr);
    const getProp = (obj, path, defaultValue) => {
      return {
        get value() {
          return get(obj, path, defaultValue);
        },
        set value(val) {
          set(obj, path, val);
        }
      };
    };
    class ElementPlusError extends Error {
      constructor(m) {
        super(m);
        this.name = "ElementPlusError";
      }
    }
    function throwError(scope, m) {
      throw new ElementPlusError(`[${scope}] ${m}`);
    }
    function debugWarn(scope, message) {
    }
    const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
    const hasClass = (el, cls) => {
      if (!el || !cls)
        return false;
      if (cls.includes(" "))
        throw new Error("className should not contain space.");
      return el.classList.contains(cls);
    };
    const addClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.add(...classNameToArray(cls));
    };
    const removeClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.remove(...classNameToArray(cls));
    };
    const getStyle = (element, styleName) => {
      var _a2;
      if (!isClient || !element || !styleName)
        return "";
      let key = camelize(styleName);
      if (key === "float")
        key = "cssFloat";
      try {
        const style = element.style[key];
        if (style)
          return style;
        const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
        return computed2 ? computed2[key] : "";
      } catch (e) {
        return element.style[key];
      }
    };
    function addUnit(value, defaultUnit = "px") {
      if (!value)
        return "";
      if (isNumber(value) || isStringNumber(value)) {
        return `${value}${defaultUnit}`;
      } else if (isString$1(value)) {
        return value;
      }
    }
    let scrollBarWidth;
    const getScrollBarWidth = (namespace) => {
      var _a2;
      if (!isClient)
        return 0;
      if (scrollBarWidth !== void 0)
        return scrollBarWidth;
      const outer = document.createElement("div");
      outer.className = `${namespace}-scrollbar__wrap`;
      outer.style.visibility = "hidden";
      outer.style.width = "100px";
      outer.style.position = "absolute";
      outer.style.top = "-9999px";
      document.body.appendChild(outer);
      const widthNoScroll = outer.offsetWidth;
      outer.style.overflow = "scroll";
      const inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
      const widthWithScroll = inner.offsetWidth;
      (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
      scrollBarWidth = widthNoScroll - widthWithScroll;
      return scrollBarWidth;
    };
    function scrollIntoView(container, selected) {
      if (!isClient)
        return;
      if (!selected) {
        container.scrollTop = 0;
        return;
      }
      const offsetParents = [];
      let pointer = selected.offsetParent;
      while (pointer !== null && container !== pointer && container.contains(pointer)) {
        offsetParents.push(pointer);
        pointer = pointer.offsetParent;
      }
      const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
      const bottom = top + selected.offsetHeight;
      const viewRectTop = container.scrollTop;
      const viewRectBottom = viewRectTop + container.clientHeight;
      if (top < viewRectTop) {
        container.scrollTop = top;
      } else if (bottom > viewRectBottom) {
        container.scrollTop = bottom - container.clientHeight;
      }
    }
    /*! Element Plus Icons Vue v2.3.1 */
    var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowDown",
      __name: "arrow-down",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
          })
        ]));
      }
    });
    var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
    var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowLeft",
      __name: "arrow-left",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
    var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowRight",
      __name: "arrow-right",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
    var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowUp",
      __name: "arrow-up",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
          })
        ]));
      }
    });
    var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
    var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleCheck",
      __name: "circle-check",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
          })
        ]));
      }
    });
    var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
    var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleCloseFilled",
      __name: "circle-close-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
          })
        ]));
      }
    });
    var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
    var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleClose",
      __name: "circle-close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          })
        ]));
      }
    });
    var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
    var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Close",
      __name: "close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
          })
        ]));
      }
    });
    var close_default = close_vue_vue_type_script_setup_true_lang_default;
    var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Hide",
      __name: "hide",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
          })
        ]));
      }
    });
    var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
    var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "InfoFilled",
      __name: "info-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
          })
        ]));
      }
    });
    var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
    var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Loading",
      __name: "loading",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
          })
        ]));
      }
    });
    var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
    var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Minus",
      __name: "minus",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
          })
        ]));
      }
    });
    var minus_default = minus_vue_vue_type_script_setup_true_lang_default;
    var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Plus",
      __name: "plus",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
          })
        ]));
      }
    });
    var plus_default = plus_vue_vue_type_script_setup_true_lang_default;
    var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "SuccessFilled",
      __name: "success-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
          })
        ]));
      }
    });
    var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
    var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "View",
      __name: "view",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
          })
        ]));
      }
    });
    var view_default = view_vue_vue_type_script_setup_true_lang_default;
    var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "WarningFilled",
      __name: "warning-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
          })
        ]));
      }
    });
    var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
    const epPropKey = "__epPropKey";
    const definePropType = (val) => val;
    const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
    const buildProp = (prop, key) => {
      if (!isObject$1(prop) || isEpProp(prop))
        return prop;
      const { values, required, default: defaultValue, type, validator } = prop;
      const _validator = values || validator ? (val) => {
        let valid = false;
        let allowedValues = [];
        if (values) {
          allowedValues = Array.from(values);
          if (hasOwn(prop, "default")) {
            allowedValues.push(defaultValue);
          }
          valid || (valid = allowedValues.includes(val));
        }
        if (validator)
          valid || (valid = validator(val));
        if (!valid && allowedValues.length > 0) {
          const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
          warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
      } : void 0;
      const epProp = {
        type,
        required: !!required,
        validator: _validator,
        [epPropKey]: true
      };
      if (hasOwn(prop, "default"))
        epProp.default = defaultValue;
      return epProp;
    };
    const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ]));
    const iconPropType = definePropType([
      String,
      Object,
      Function
    ]);
    const CloseComponents = {
      Close: close_default
    };
    const TypeComponents = {
      Close: close_default,
      SuccessFilled: success_filled_default,
      InfoFilled: info_filled_default,
      WarningFilled: warning_filled_default,
      CircleCloseFilled: circle_close_filled_default
    };
    const TypeComponentsMap = {
      success: success_filled_default,
      warning: warning_filled_default,
      error: circle_close_filled_default,
      info: info_filled_default
    };
    const ValidateComponentsMap = {
      validating: loading_default,
      success: circle_check_default,
      error: circle_close_default
    };
    const withInstall = (main, extra) => {
      main.install = (app2) => {
        for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
          app2.component(comp.name, comp);
        }
      };
      if (extra) {
        for (const [key, comp] of Object.entries(extra)) {
          main[key] = comp;
        }
      }
      return main;
    };
    const withNoopInstall = (component) => {
      component.install = NOOP;
      return component;
    };
    const composeRefs = (...refs) => {
      return (el) => {
        refs.forEach((ref2) => {
          if (isFunction$1(ref2)) {
            ref2(el);
          } else {
            ref2.value = el;
          }
        });
      };
    };
    const EVENT_CODE = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End"
    };
    const UPDATE_MODEL_EVENT = "update:modelValue";
    const CHANGE_EVENT = "change";
    const INPUT_EVENT = "input";
    const componentSizes = ["", "default", "small", "large"];
    var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
      PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
      PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
      PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
      PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
      PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
      PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
      PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
      PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
      PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
      PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
      PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
      return PatchFlags2;
    })(PatchFlags || {});
    const flattedChildren = (children) => {
      const vNodes = isArray$2(children) ? children : [children];
      const result = [];
      vNodes.forEach((child) => {
        var _a2;
        if (isArray$2(child)) {
          result.push(...flattedChildren(child));
        } else if (isVNode(child) && isArray$2(child.children)) {
          result.push(...flattedChildren(child.children));
        } else {
          result.push(child);
          if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
            result.push(...flattedChildren(child.component.subTree));
          }
        }
      });
      return result;
    };
    const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
    const mutable = (val) => val;
    const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    const LISTENER_PREFIX = /^on[A-Z]/;
    const useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = getCurrentInstance();
      if (!instance) {
        return computed(() => ({}));
      }
      return computed(() => {
        var _a2;
        return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
      watch(() => unref(condition), (val) => {
      }, {
        immediate: true
      });
    };
    const useDraggable = (targetRef, dragRef, draggable, overflow) => {
      let transform = {
        offsetX: 0,
        offsetY: 0
      };
      const onMousedown = (e) => {
        const downX = e.clientX;
        const downY = e.clientY;
        const { offsetX, offsetY } = transform;
        const targetRect = targetRef.value.getBoundingClientRect();
        const targetLeft = targetRect.left;
        const targetTop = targetRect.top;
        const targetWidth = targetRect.width;
        const targetHeight = targetRect.height;
        const clientWidth = document.documentElement.clientWidth;
        const clientHeight = document.documentElement.clientHeight;
        const minLeft = -targetLeft + offsetX;
        const minTop = -targetTop + offsetY;
        const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
        const maxTop = clientHeight - targetTop - targetHeight + offsetY;
        const onMousemove = (e2) => {
          let moveX = offsetX + e2.clientX - downX;
          let moveY = offsetY + e2.clientY - downY;
          if (!(overflow == null ? void 0 : overflow.value)) {
            moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
            moveY = Math.min(Math.max(moveY, minTop), maxTop);
          }
          transform = {
            offsetX: moveX,
            offsetY: moveY
          };
          if (targetRef.value) {
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          }
        };
        const onMouseup = () => {
          document.removeEventListener("mousemove", onMousemove);
          document.removeEventListener("mouseup", onMouseup);
        };
        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("mouseup", onMouseup);
      };
      const onDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.addEventListener("mousedown", onMousedown);
        }
      };
      const offDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.removeEventListener("mousedown", onMousedown);
        }
      };
      onMounted(() => {
        watchEffect(() => {
          if (draggable.value) {
            onDraggable();
          } else {
            offDraggable();
          }
        });
      });
      onBeforeUnmount(() => {
        offDraggable();
      });
    };
    var English = {
      name: "en",
      el: {
        breadcrumb: {
          label: "Breadcrumb"
        },
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          page: "Page",
          prev: "Go to previous page",
          next: "Go to next page",
          currentPage: "page {pager}",
          prevPages: "Previous {pager} pages",
          nextPages: "Next {pager} pages",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tour: {
          next: "Next",
          previous: "Previous",
          finish: "Finish"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        },
        carousel: {
          leftArrow: "Carousel arrow left",
          rightArrow: "Carousel arrow right",
          indicator: "Carousel switch to index {index}"
        }
      }
    };
    const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
    const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
      var _a2;
      return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
    });
    const buildLocaleContext = (locale) => {
      const lang = computed(() => unref(locale).name);
      const localeRef = isRef(locale) ? locale : ref(locale);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
      };
    };
    const localeContextKey = Symbol("localeContextKey");
    const useLocale = (localeOverrides) => {
      const locale = localeOverrides || inject(localeContextKey, ref());
      return buildLocaleContext(computed(() => locale.value || English));
    };
    const defaultNamespace = "el";
    const statePrefix = "is-";
    const _bem = (namespace, block, blockSuffix, element, modifier) => {
      let cls = `${namespace}-${block}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element) {
        cls += `__${element}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    const namespaceContextKey = Symbol("namespaceContextKey");
    const useGetDerivedNamespace = (namespaceOverrides) => {
      const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
      const namespace = computed(() => {
        return unref(derivedNamespace) || defaultNamespace;
      });
      return namespace;
    };
    const useNamespace = (block, namespaceOverrides) => {
      const namespace = useGetDerivedNamespace(namespaceOverrides);
      const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
      const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
      const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
      const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
      const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${block}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
      return {
        namespace,
        b,
        e,
        m,
        be: be2,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    const useLockscreen = (trigger2, options = {}) => {
      if (!isRef(trigger2)) {
        throwError("[useLockscreen]", "You need to pass a ref param to this function");
      }
      const ns = options.ns || useNamespace("popup");
      const hiddenCls = computed(() => ns.bm("parent", "hidden"));
      if (!isClient || hasClass(document.body, hiddenCls.value)) {
        return;
      }
      let scrollBarWidth2 = 0;
      let withoutHiddenClass = false;
      let bodyWidth = "0";
      const cleanup = () => {
        setTimeout(() => {
          removeClass(document == null ? void 0 : document.body, hiddenCls.value);
          if (withoutHiddenClass && document) {
            document.body.style.width = bodyWidth;
          }
        }, 200);
      };
      watch(trigger2, (val) => {
        if (!val) {
          cleanup();
          return;
        }
        withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          bodyWidth = document.body.style.width;
        }
        scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = getStyle(document.body, "overflowY");
        if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
          document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
        }
        addClass(document.body, hiddenCls.value);
      });
      onScopeDispose(() => cleanup());
    };
    const _prop = buildProp({
      type: definePropType(Boolean),
      default: null
    });
    const _event = buildProp({
      type: definePropType(Function)
    });
    const createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const props = instance.props;
        const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
        const isModelBindingAbsent = computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$1(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$1(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!isBoolean(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit2(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          watch(() => ({
            ...instance.proxy.$route
          }), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    createModelToggleComposable("modelValue");
    const useProp = (name) => {
      const vm = getCurrentInstance();
      return computed(() => {
        var _a2, _b;
        return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
      });
    };
    var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
      return t.concat([e + "-" + U, e + "-" + J]);
    }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
      return t.concat([e, e + "-" + U, e + "-" + J]);
    }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
    function C(t) {
      return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function H(t) {
      if (t == null) return window;
      if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window;
      }
      return t;
    }
    function Q(t) {
      var e = H(t).Element;
      return t instanceof e || t instanceof Element;
    }
    function B(t) {
      var e = H(t).HTMLElement;
      return t instanceof e || t instanceof HTMLElement;
    }
    function Pe(t) {
      if (typeof ShadowRoot == "undefined") return false;
      var e = H(t).ShadowRoot;
      return t instanceof e || t instanceof ShadowRoot;
    }
    function Mt(t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
        !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
          var s = o[a];
          s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
        }));
      });
    }
    function Rt(t) {
      var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
            return f[c] = "", f;
          }, {});
          !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
            o.removeAttribute(f);
          }));
        });
      };
    }
    var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
    function q(t) {
      return t.split("-")[0];
    }
    var X = Math.max, ve = Math.min, Z = Math.round;
    function ee(t, e) {
      e === void 0 && (e = false);
      var n = t.getBoundingClientRect(), r = 1, o = 1;
      if (B(t) && e) {
        var i = t.offsetHeight, a = t.offsetWidth;
        a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
      }
      return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
    }
    function ke(t) {
      var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
    }
    function it(t, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t.contains(e)) return true;
      if (n && Pe(n)) {
        var r = e;
        do {
          if (r && t.isSameNode(r)) return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function N(t) {
      return H(t).getComputedStyle(t);
    }
    function Wt(t) {
      return ["table", "td", "th"].indexOf(C(t)) >= 0;
    }
    function I(t) {
      return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function ge(t) {
      return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
    }
    function at(t) {
      return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
    }
    function Bt(t) {
      var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
      if (n && B(t)) {
        var r = N(t);
        if (r.position === "fixed") return null;
      }
      var o = ge(t);
      for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
        var i = N(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o;
        o = o.parentNode;
      }
      return null;
    }
    function se(t) {
      for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; ) n = at(n);
      return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
    }
    function Le(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
    }
    function fe(t, e, n) {
      return X(t, ve(e, n));
    }
    function St(t, e, n) {
      var r = fe(t, e, n);
      return r > n ? n : r;
    }
    function st() {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    function ft(t) {
      return Object.assign({}, st(), t);
    }
    function ct(t, e) {
      return e.reduce(function(n, r) {
        return n[r] = t, n;
      }, {});
    }
    var Tt = function(t, e) {
      return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
    };
    function Ht(t) {
      var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
      if (!(!i || !a)) {
        var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
        n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
      }
    }
    function Ct(t) {
      var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
      o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
    }
    var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function te(t) {
      return t.split("-")[1];
    }
    var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function Vt(t) {
      var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
      return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
    }
    function ut(t) {
      var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p2 }) : { x: l, y: p2 };
      l = g.x, p2 = g.y;
      var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
      if (c) {
        var w = se(n), O = "clientHeight", j = "clientWidth";
        if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
          d = R;
          var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
          p2 -= A - r.height, p2 *= f ? 1 : -1;
        }
        if (o === P || (o === E || o === R) && i === J) {
          $ = W;
          var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
          l -= k - r.width, l *= f ? 1 : -1;
        }
      }
      var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
      if (l = S.x, p2 = S.y, f) {
        var L;
        return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L));
      }
      return Object.assign({}, D, (e = {}, e[d] = y ? p2 + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
    }
    function Nt(t) {
      var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
    }
    var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
    function It(t) {
      var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c.forEach(function(u) {
        u.addEventListener("scroll", n.update, ye);
      }), s && f.addEventListener("resize", n.update, ye), function() {
        i && c.forEach(function(u) {
          u.removeEventListener("scroll", n.update, ye);
        }), s && f.removeEventListener("resize", n.update, ye);
      };
    }
    var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function be(t) {
      return t.replace(/left|right|bottom|top/g, function(e) {
        return _t[e];
      });
    }
    var zt = { start: "end", end: "start" };
    function lt(t) {
      return t.replace(/start|end/g, function(e) {
        return zt[e];
      });
    }
    function We(t) {
      var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
      return { scrollLeft: n, scrollTop: r };
    }
    function Be(t) {
      return ee(I(t)).left + We(t).scrollLeft;
    }
    function Ft(t) {
      var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
      return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
    }
    function Ut(t) {
      var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
      return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
    }
    function Se(t) {
      var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o + r);
    }
    function dt(t) {
      return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
    }
    function ce(t, e) {
      var n;
      e === void 0 && (e = []);
      var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
      return o ? s : s.concat(ce(ge(a)));
    }
    function Te(t) {
      return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
    }
    function Xt(t) {
      var e = ee(t);
      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
    }
    function ht(t, e) {
      return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
    }
    function Yt(t) {
      var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
      return Q(r) ? e.filter(function(o) {
        return Q(o) && it(o, r) && C(o) !== "body";
      }) : [];
    }
    function Gt(t, e, n) {
      var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
        var c = ht(t, f);
        return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
      }, ht(t, i));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function mt(t) {
      var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
      switch (o) {
        case E:
          f = { x: a, y: e.y - n.height };
          break;
        case R:
          f = { x: a, y: e.y + e.height };
          break;
        case W:
          f = { x: e.x + e.width, y: s };
          break;
        case P:
          f = { x: e.x - n.width, y: s };
          break;
        default:
          f = { x: e.x, y: e.y };
      }
      var c = o ? Le(o) : null;
      if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (i) {
          case U:
            f[c] = f[c] - (e[u] / 2 - n[u] / 2);
            break;
          case J:
            f[c] = f[c] + (e[u] / 2 - n[u] / 2);
            break;
        }
      }
      return f;
    }
    function ne(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A = t.modifiersData.offset;
      if (u === K && A) {
        var k = A[o];
        Object.keys(j).forEach(function(D) {
          var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
          j[D] += k[L] * S;
        });
      }
      return j;
    }
    function Jt(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
        return te(h2) === u;
      }) : G, v = m.filter(function(h2) {
        return c.indexOf(h2) >= 0;
      });
      v.length === 0 && (v = m);
      var l = v.reduce(function(h2, p2) {
        return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i, padding: a })[q(p2)], h2;
      }, {});
      return Object.keys(l).sort(function(h2, p2) {
        return l[h2] - l[p2];
      });
    }
    function Kt(t) {
      if (q(t) === me) return [];
      var e = be(t);
      return [lt(t), e, lt(e)];
    }
    function Qt(t) {
      var e = t.state, n = t.options, r = t.name;
      if (!e.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
          return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
        }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
          var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
          b[oe] > w[oe] && (T = be(T));
          var pe = be(T), _ = [];
          if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
            return z;
          })) {
            A = D, j = false;
            break;
          }
          O.set(D, _);
        }
        if (j) for (var ue = h2 ? 3 : 1, xe = function(z) {
          var V = d.find(function(de) {
            var ae = O.get(de);
            if (ae) return ae.slice(0, z).every(function(Y) {
              return Y;
            });
          });
          if (V) return A = V, "break";
        }, ie = ue; ie > 0; ie--) {
          var le = xe(ie);
          if (le === "break") break;
        }
        e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
      }
    }
    var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
    function gt(t, e, n) {
      return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
    }
    function yt(t) {
      return [E, W, R, P].some(function(e) {
        return t[e] >= 0;
      });
    }
    function Zt(t) {
      var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
      e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
    }
    var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
    function en(t, e, n) {
      var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
      return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
    }
    function tn(t) {
      var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
        return u[m] = en(m, e.rects, i), u;
      }, {}), s = a[e.placement], f = s.x, c = s.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
    }
    var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
    function nn(t) {
      var e = t.state, n = t.name;
      e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
    }
    var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
    function rn(t) {
      return t === "x" ? "y" : "x";
    }
    function on(t) {
      var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
      if (w) {
        if (i) {
          var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
          w[d] = qe, S[d] = qe - T;
        }
        if (s) {
          var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
          w[b] = Ue, S[b] = Ue - F;
        }
        e.modifiersData[r] = S;
      }
    }
    var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
    function an(t) {
      return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
    }
    function sn(t) {
      return t === H(t) || !B(t) ? We(t) : an(t);
    }
    function fn(t) {
      var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function cn(t, e, n) {
      n === void 0 && (n = false);
      var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
      return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
    }
    function pn(t) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t.forEach(function(i) {
        e.set(i.name, i);
      });
      function o(i) {
        n.add(i.name);
        var a = [].concat(i.requires || [], i.requiresIfExists || []);
        a.forEach(function(s) {
          if (!n.has(s)) {
            var f = e.get(s);
            f && o(f);
          }
        }), r.push(i);
      }
      return t.forEach(function(i) {
        n.has(i.name) || o(i);
      }), r;
    }
    function un(t) {
      var e = pn(t);
      return ot.reduce(function(n, r) {
        return n.concat(e.filter(function(o) {
          return o.phase === r;
        }));
      }, []);
    }
    function ln(t) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t());
          });
        })), e;
      };
    }
    function dn(t) {
      var e = t.reduce(function(n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function $t() {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function we(t) {
      t === void 0 && (t = {});
      var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
      return function(a, s, f) {
        f === void 0 && (f = i);
        var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
          var g = typeof p2 == "function" ? p2(c.options) : p2;
          h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
          var x = un(dn([].concat(r, c.options.modifiers)));
          return c.orderedModifiers = x.filter(function(y) {
            return y.enabled;
          }), l(), v.update();
        }, forceUpdate: function() {
          if (!m) {
            var p2 = c.elements, g = p2.reference, x = p2.popper;
            if ($t(g, x)) {
              c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                return c.modifiersData[j.name] = Object.assign({}, j.data);
              });
              for (var y = 0; y < c.orderedModifiers.length; y++) {
                if (c.reset === true) {
                  c.reset = false, y = -1;
                  continue;
                }
                var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
              }
            }
          }
        }, update: ln(function() {
          return new Promise(function(p2) {
            v.forceUpdate(), p2(c);
          });
        }), destroy: function() {
          h2(), m = true;
        } };
        if (!$t(a, s)) return v;
        v.setOptions(f).then(function(p2) {
          !m && f.onFirstUpdate && f.onFirstUpdate(p2);
        });
        function l() {
          c.orderedModifiers.forEach(function(p2) {
            var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $ = p2.effect;
            if (typeof $ == "function") {
              var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
              };
              u.push(d || b);
            }
          });
        }
        function h2() {
          u.forEach(function(p2) {
            return p2();
          }), u = [];
        }
        return v;
      };
    }
    we();
    var mn = [Re, He, Me, Ae];
    we({ defaultModifiers: mn });
    var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
    const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
      const stateUpdater = {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: ({ state }) => {
          const derivedState = deriveState(state);
          Object.assign(states.value, derivedState);
        },
        requires: ["computeStyles"]
      };
      const options = computed(() => {
        const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
        return {
          onFirstUpdate,
          placement: placement || "bottom",
          strategy: strategy || "absolute",
          modifiers: [
            ...modifiers || [],
            stateUpdater,
            { name: "applyStyles", enabled: false }
          ]
        };
      });
      const instanceRef = shallowRef();
      const states = ref({
        styles: {
          popper: {
            position: unref(options).strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      });
      const destroy = () => {
        if (!instanceRef.value)
          return;
        instanceRef.value.destroy();
        instanceRef.value = void 0;
      };
      watch(options, (newOptions) => {
        const instance = unref(instanceRef);
        if (instance) {
          instance.setOptions(newOptions);
        }
      }, {
        deep: true
      });
      watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
        destroy();
        if (!referenceElement || !popperElement)
          return;
        instanceRef.value = yn(referenceElement, popperElement, unref(options));
      });
      onBeforeUnmount(() => {
        destroy();
      });
      return {
        state: computed(() => {
          var _a2;
          return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
        }),
        styles: computed(() => unref(states).styles),
        attributes: computed(() => unref(states).attributes),
        update: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
        },
        forceUpdate: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
        },
        instanceRef: computed(() => unref(instanceRef))
      };
    };
    function deriveState(state) {
      const elements = Object.keys(state.elements);
      const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
      const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
      return {
        styles,
        attributes
      };
    }
    const useSameTarget = (handleClick) => {
      if (!handleClick) {
        return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
      }
      let mousedownTarget = false;
      let mouseupTarget = false;
      const onClick = (e) => {
        if (mousedownTarget && mouseupTarget) {
          handleClick(e);
        }
        mousedownTarget = mouseupTarget = false;
      };
      const onMousedown = (e) => {
        mousedownTarget = e.target === e.currentTarget;
      };
      const onMouseup = (e) => {
        mouseupTarget = e.target === e.currentTarget;
      };
      return { onClick, onMousedown, onMouseup };
    };
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn2, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn2, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    const defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    const ID_INJECTION_KEY = Symbol("elIdInjection");
    const useIdInjection = () => {
      return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
    };
    const useId = (deterministicId) => {
      const idInjection = useIdInjection();
      const namespace = useGetDerivedNamespace();
      const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    let registeredEscapeHandlers = [];
    const cachedHandler = (e) => {
      const event = e;
      if (event.key === EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    const useEscapeKeydown = (handler) => {
      onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (isClient)
          registeredEscapeHandlers.push(handler);
      });
      onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    let cachedContainer;
    const usePopperContainerId = () => {
      const namespace = useGetDerivedNamespace();
      const idInjection = useIdInjection();
      const id = computed(() => {
        return `${namespace.value}-popper-container-${idInjection.prefix}`;
      });
      const selector = computed(() => `#${id.value}`);
      return {
        id,
        selector
      };
    };
    const createContainer = (id) => {
      const container = document.createElement("div");
      container.id = id;
      document.body.appendChild(container);
      return container;
    };
    const usePopperContainer = () => {
      const { id, selector } = usePopperContainerId();
      onBeforeMount(() => {
        if (!isClient)
          return;
        if (!cachedContainer && !document.body.querySelector(selector.value)) {
          cachedContainer = createContainer(id.value);
        }
      });
      return {
        id,
        selector
      };
    };
    const useDelayedToggleProps = buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      autoClose: {
        type: Number,
        default: 0
      }
    });
    const useDelayedToggle = ({
      showAfter,
      hideAfter,
      autoClose,
      open,
      close
    }) => {
      const { registerTimeout } = useTimeout();
      const {
        registerTimeout: registerTimeoutForAutoClose,
        cancelTimeout: cancelTimeoutForAutoClose
      } = useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
          const _autoClose = unref(autoClose);
          if (isNumber(_autoClose) && _autoClose > 0) {
            registerTimeoutForAutoClose(() => {
              close(event);
            }, _autoClose);
          }
        }, unref(showAfter));
      };
      const onClose = (event) => {
        cancelTimeoutForAutoClose();
        registerTimeout(() => {
          close(event);
        }, unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    const useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    const useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    const initial = {
      current: 0
    };
    const zIndex = ref(0);
    const defaultInitialZIndex = 2e3;
    const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
    const zIndexContextKey = Symbol("zIndexContextKey");
    const useZIndex = (zIndexOverrides) => {
      const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
      const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
      const initialZIndex = computed(() => {
        const zIndexFromInjection = unref(zIndexInjection);
        return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
      });
      const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
      const nextZIndex = () => {
        increasingInjection.current++;
        zIndex.value = increasingInjection.current;
        return currentZIndex.value;
      };
      if (!isClient && !inject(ZINDEX_INJECTION_KEY)) ;
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    function useCursor(input) {
      const selectionRef = ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    const getOrderedChildren = (vm, childComponentName, children) => {
      const nodes = flattedChildren(vm.subTree).filter((n) => {
        var _a2;
        return isVNode(n) && ((_a2 = n.type) == null ? void 0 : _a2.name) === childComponentName && !!n.component;
      });
      const uids = nodes.map((n) => n.component.uid);
      return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
    };
    const useOrderedChildren = (vm, childComponentName) => {
      const children = {};
      const orderedChildren = shallowRef([]);
      const addChild = (child) => {
        children[child.uid] = child;
        orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
      };
      const removeChild = (uid2) => {
        delete children[uid2];
        orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid2);
      };
      return {
        children: orderedChildren,
        addChild,
        removeChild
      };
    };
    const useSizeProp = buildProp({
      type: String,
      values: componentSizes,
      required: false
    });
    const SIZE_INJECTION_KEY = Symbol("size");
    const useGlobalSize = () => {
      const injectedSize = inject(SIZE_INJECTION_KEY, {});
      return computed(() => {
        return unref(injectedSize.size) || "";
      });
    };
    function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
      const instance = getCurrentInstance();
      const { emit: emit2 } = instance;
      const wrapperRef = shallowRef();
      const isFocused = ref(false);
      const handleFocus = (event) => {
        if (isFocused.value)
          return;
        isFocused.value = true;
        emit2("focus", event);
        afterFocus == null ? void 0 : afterFocus();
      };
      const handleBlur = (event) => {
        var _a2;
        const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
        if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
          return;
        isFocused.value = false;
        emit2("blur", event);
        afterBlur == null ? void 0 : afterBlur();
      };
      const handleClick = () => {
        var _a2;
        (_a2 = target.value) == null ? void 0 : _a2.focus();
      };
      watch(wrapperRef, (el) => {
        if (el) {
          el.setAttribute("tabindex", "-1");
        }
      });
      useEventListener(wrapperRef, "click", handleClick);
      return {
        wrapperRef,
        isFocused,
        handleFocus,
        handleBlur
      };
    }
    const emptyValuesContextKey = Symbol("emptyValuesContextKey");
    const DEFAULT_EMPTY_VALUES = ["", void 0, null];
    const DEFAULT_VALUE_ON_CLEAR = void 0;
    const useEmptyValuesProps = buildProps({
      emptyValues: Array,
      valueOnClear: {
        type: [String, Number, Boolean, Function],
        default: void 0,
        validator: (val) => isFunction$1(val) ? !val() : !val
      }
    });
    const useEmptyValues = (props, defaultValue) => {
      const config = getCurrentInstance() ? inject(emptyValuesContextKey, ref({})) : ref({});
      const emptyValues = computed(() => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
      const valueOnClear = computed(() => {
        if (isFunction$1(props.valueOnClear)) {
          return props.valueOnClear();
        } else if (props.valueOnClear !== void 0) {
          return props.valueOnClear;
        } else if (isFunction$1(config.value.valueOnClear)) {
          return config.value.valueOnClear();
        } else if (config.value.valueOnClear !== void 0) {
          return config.value.valueOnClear;
        }
        return DEFAULT_VALUE_ON_CLEAR;
      });
      const isEmptyValue2 = (value) => {
        return emptyValues.value.includes(value);
      };
      if (!emptyValues.value.includes(valueOnClear.value)) ;
      return {
        emptyValues,
        valueOnClear,
        isEmptyValue: isEmptyValue2
      };
    };
    const ariaProps = buildProps({
      ariaLabel: String,
      ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical", "undefined"]
      },
      ariaControls: String
    });
    const useAriaProps = (arias) => {
      return pick(ariaProps, arias);
    };
    const configProviderContextKey = Symbol();
    const globalConfig = ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    function useGlobalComponentSettings(block, sizeFallback) {
      const config = useGlobalConfig();
      const ns = useNamespace(block, computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
      }));
      const locale = useLocale(computed(() => {
        var _a2;
        return (_a2 = config.value) == null ? void 0 : _a2.locale;
      }));
      const zIndex2 = useZIndex(computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
      }));
      const size = computed(() => {
        var _a2;
        return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
      });
      provideGlobalConfig(computed(() => unref(config) || {}));
      return {
        ns,
        locale,
        zIndex: zIndex2,
        size
      };
    }
    const provideGlobalConfig = (config, app2, global2 = false) => {
      var _a2;
      const inSetup = !!getCurrentInstance();
      const oldConfig = inSetup ? useGlobalConfig() : void 0;
      const provideFn = (_a2 = void 0) != null ? _a2 : inSetup ? provide : void 0;
      if (!provideFn) {
        return;
      }
      const context = computed(() => {
        const cfg = unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value))
          return cfg;
        return mergeConfig(oldConfig.value, cfg);
      });
      provideFn(configProviderContextKey, context);
      provideFn(localeContextKey, computed(() => context.value.locale));
      provideFn(namespaceContextKey, computed(() => context.value.namespace));
      provideFn(zIndexContextKey, computed(() => context.value.zIndex));
      provideFn(SIZE_INJECTION_KEY, {
        size: computed(() => context.value.size || "")
      });
      provideFn(emptyValuesContextKey, computed(() => ({
        emptyValues: context.value.emptyValues,
        valueOnClear: context.value.valueOnClear
      })));
      if (global2 || !globalConfig.value) {
        globalConfig.value = context.value;
      }
      return context;
    };
    const mergeConfig = (a, b) => {
      const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
      const obj = {};
      for (const key of keys2) {
        obj[key] = b[key] !== void 0 ? b[key] : a[key];
      }
      return obj;
    };
    var _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const iconProps = buildProps({
      size: {
        type: definePropType([Number, String])
      },
      color: {
        type: String
      }
    });
    const __default__$w = /* @__PURE__ */ defineComponent({
      name: "ElIcon",
      inheritAttrs: false
    });
    const _sfc_main$N = /* @__PURE__ */ defineComponent({
      ...__default__$w,
      props: iconProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("icon");
        const style = computed(() => {
          const { size, color } = props;
          if (!size && !color)
            return {};
          return {
            fontSize: isUndefined(size) ? void 0 : addUnit(size),
            "--color": color
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("i", mergeProps({
            class: unref(ns).b(),
            style: unref(style)
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    });
    var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "icon.vue"]]);
    const ElIcon = withInstall(Icon);
    const alertEffects = ["light", "dark"];
    const alertProps = buildProps({
      title: {
        type: String,
        default: ""
      },
      description: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        values: keysOf(TypeComponentsMap),
        default: "info"
      },
      closable: {
        type: Boolean,
        default: true
      },
      closeText: {
        type: String,
        default: ""
      },
      showIcon: Boolean,
      center: Boolean,
      effect: {
        type: String,
        values: alertEffects,
        default: "light"
      }
    });
    const alertEmits = {
      close: (evt) => evt instanceof MouseEvent
    };
    const __default__$v = /* @__PURE__ */ defineComponent({
      name: "ElAlert"
    });
    const _sfc_main$M = /* @__PURE__ */ defineComponent({
      ...__default__$v,
      props: alertProps,
      emits: alertEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const { Close } = TypeComponents;
        const slots = useSlots();
        const ns = useNamespace("alert");
        const visible = ref(true);
        const iconComponent = computed(() => TypeComponentsMap[props.type]);
        const iconClass = computed(() => [
          ns.e("icon"),
          { [ns.is("big")]: !!props.description || !!slots.default }
        ]);
        const withDescription = computed(() => {
          return { "with-description": props.description || slots.default };
        });
        const close = (evt) => {
          visible.value = false;
          emit2("close", evt);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.type), unref(ns).is("center", _ctx.center), unref(ns).is(_ctx.effect)]),
                role: "alert"
              }, [
                _ctx.showIcon && unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(iconClass))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass([unref(ns).e("title"), unref(withDescription)])
                  }, [
                    renderSlot(_ctx.$slots, "title", {}, () => [
                      createTextVNode(toDisplayString(_ctx.title), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.default || _ctx.description ? (openBlock(), createElementBlock("p", {
                    key: 1,
                    class: normalizeClass(unref(ns).e("description"))
                  }, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      createTextVNode(toDisplayString(_ctx.description), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    _ctx.closeText ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass([unref(ns).e("close-btn"), unref(ns).is("customed")]),
                      onClick: close
                    }, toDisplayString(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass(unref(ns).e("close-btn")),
                      onClick: close
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class"]))
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2)
              ], 2), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name"]);
        };
      }
    });
    var Alert = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__file", "alert.vue"]]);
    const ElAlert = withInstall(Alert);
    const formContextKey = Symbol("formContextKey");
    const formItemContextKey = Symbol("formItemContextKey");
    const useFormSize = (fallback, ignore = {}) => {
      const emptyRef = ref(void 0);
      const size = ignore.prop ? emptyRef : useProp("size");
      const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
      const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
      return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
    };
    const useFormDisabled = (fallback) => {
      const disabled = useProp("disabled");
      const form = inject(formContextKey, void 0);
      return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
    };
    const useFormItem = () => {
      const form = inject(formContextKey, void 0);
      const formItem = inject(formItemContextKey, void 0);
      return {
        form,
        formItem
      };
    };
    const useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = ref(false);
      }
      const inputId = ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = computed(() => {
        var _a2;
        return !!(!(props.label || props.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
      });
      onMounted(() => {
        idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
          const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
          if (newId !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                formItemContext.addInputId(newId);
              }
            }
            inputId.value = newId;
          }
        }, { immediate: true });
      });
      onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    const formMetaProps = buildProps({
      size: {
        type: String,
        values: componentSizes
      },
      disabled: Boolean
    });
    const formProps = buildProps({
      ...formMetaProps,
      model: Object,
      rules: {
        type: definePropType(Object)
      },
      labelPosition: {
        type: String,
        values: ["left", "right", "top"],
        default: "right"
      },
      requireAsteriskPosition: {
        type: String,
        values: ["left", "right"],
        default: "left"
      },
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      labelSuffix: {
        type: String,
        default: ""
      },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      validateOnRuleChange: {
        type: Boolean,
        default: true
      },
      hideRequiredAsterisk: Boolean,
      scrollToError: Boolean,
      scrollIntoViewOptions: {
        type: [Object, Boolean]
      }
    });
    const formEmits = {
      validate: (prop, isValid, message) => (isArray$2(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message)
    };
    function useFormLabelWidth() {
      const potentialLabelWidthArr = ref([]);
      const autoLabelWidth = computed(() => {
        if (!potentialLabelWidthArr.value.length)
          return "0";
        const max = Math.max(...potentialLabelWidthArr.value);
        return max ? `${max}px` : "";
      });
      function getLabelWidthIndex(width) {
        const index = potentialLabelWidthArr.value.indexOf(width);
        if (index === -1 && autoLabelWidth.value === "0") ;
        return index;
      }
      function registerLabelWidth(val, oldVal) {
        if (val && oldVal) {
          const index = getLabelWidthIndex(oldVal);
          potentialLabelWidthArr.value.splice(index, 1, val);
        } else if (val) {
          potentialLabelWidthArr.value.push(val);
        }
      }
      function deregisterLabelWidth(val) {
        const index = getLabelWidthIndex(val);
        if (index > -1) {
          potentialLabelWidthArr.value.splice(index, 1);
        }
      }
      return {
        autoLabelWidth,
        registerLabelWidth,
        deregisterLabelWidth
      };
    }
    const filterFields = (fields, props) => {
      const normalized = castArray(props);
      return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
    };
    const COMPONENT_NAME$7 = "ElForm";
    const __default__$u = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$7
    });
    const _sfc_main$L = /* @__PURE__ */ defineComponent({
      ...__default__$u,
      props: formProps,
      emits: formEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const fields = [];
        const formSize = useFormSize();
        const ns = useNamespace("form");
        const formClasses = computed(() => {
          const { labelPosition, inline } = props;
          return [
            ns.b(),
            ns.m(formSize.value || "default"),
            {
              [ns.m(`label-${labelPosition}`)]: labelPosition,
              [ns.m("inline")]: inline
            }
          ];
        });
        const getField = (prop) => {
          return fields.find((field) => field.prop === prop);
        };
        const addField = (field) => {
          fields.push(field);
        };
        const removeField = (field) => {
          if (field.prop) {
            fields.splice(fields.indexOf(field), 1);
          }
        };
        const resetFields = (properties = []) => {
          if (!props.model) {
            return;
          }
          filterFields(fields, properties).forEach((field) => field.resetField());
        };
        const clearValidate = (props2 = []) => {
          filterFields(fields, props2).forEach((field) => field.clearValidate());
        };
        const isValidatable = computed(() => {
          const hasModel = !!props.model;
          return hasModel;
        });
        const obtainValidateFields = (props2) => {
          if (fields.length === 0)
            return [];
          const filteredFields = filterFields(fields, props2);
          if (!filteredFields.length) {
            return [];
          }
          return filteredFields;
        };
        const validate = async (callback) => validateField(void 0, callback);
        const doValidateField = async (props2 = []) => {
          if (!isValidatable.value)
            return false;
          const fields2 = obtainValidateFields(props2);
          if (fields2.length === 0)
            return true;
          let validationErrors = {};
          for (const field of fields2) {
            try {
              await field.validate("");
            } catch (fields3) {
              validationErrors = {
                ...validationErrors,
                ...fields3
              };
            }
          }
          if (Object.keys(validationErrors).length === 0)
            return true;
          return Promise.reject(validationErrors);
        };
        const validateField = async (modelProps = [], callback) => {
          const shouldThrow = !isFunction$1(callback);
          try {
            const result = await doValidateField(modelProps);
            if (result === true) {
              await (callback == null ? void 0 : callback(result));
            }
            return result;
          } catch (e) {
            if (e instanceof Error)
              throw e;
            const invalidFields = e;
            if (props.scrollToError) {
              scrollToField(Object.keys(invalidFields)[0]);
            }
            await (callback == null ? void 0 : callback(false, invalidFields));
            return shouldThrow && Promise.reject(invalidFields);
          }
        };
        const scrollToField = (prop) => {
          var _a2;
          const field = filterFields(fields, prop)[0];
          if (field) {
            (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
          }
        };
        watch(() => props.rules, () => {
          if (props.validateOnRuleChange) {
            validate().catch((err) => debugWarn());
          }
        }, { deep: true });
        provide(formContextKey, reactive({
          ...toRefs(props),
          emit: emit2,
          resetFields,
          clearValidate,
          validateField,
          getField,
          addField,
          removeField,
          ...useFormLabelWidth()
        }));
        expose({
          validate,
          validateField,
          resetFields,
          clearValidate,
          scrollToField,
          fields
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("form", {
            class: normalizeClass(unref(formClasses))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Form = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "form.vue"]]);
    var define_process_env_default = {};
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
        o2.__proto__ = p22;
        return o2;
      };
      return _setPrototypeOf(o, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    if (typeof process !== "undefined" && define_process_env_default && false) {
      warning = function warning3(type4, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e) {
            return typeof e === "string";
          })) {
            console.warn(type4, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x) {
          if (x === "%%") {
            return "%";
          }
          if (i >= len) {
            return x;
          }
          switch (x) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == void 0) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b = function b2(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone2() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o, oc) {
        var _this2 = this;
        if (o === void 0) {
          o = {};
        }
        if (oc === void 0) {
          oc = function oc2() {
          };
        }
        var source = source_;
        var options = o;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type4] = validator;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators;
    const formItemValidateStates = [
      "",
      "error",
      "validating",
      "success"
    ];
    const formItemProps = buildProps({
      label: String,
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      labelPosition: {
        type: String,
        values: ["left", "right", "top", ""],
        default: ""
      },
      prop: {
        type: definePropType([String, Array])
      },
      required: {
        type: Boolean,
        default: void 0
      },
      rules: {
        type: definePropType([Object, Array])
      },
      error: String,
      validateStatus: {
        type: String,
        values: formItemValidateStates
      },
      for: String,
      inlineMessage: {
        type: [String, Boolean],
        default: ""
      },
      showMessage: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        values: componentSizes
      }
    });
    const COMPONENT_NAME$6 = "ElLabelWrap";
    var FormLabelWrap = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$6,
      props: {
        isAutoWidth: Boolean,
        updateAll: Boolean
      },
      setup(props, {
        slots
      }) {
        const formContext = inject(formContextKey, void 0);
        const formItemContext = inject(formItemContextKey);
        if (!formItemContext)
          throwError(COMPONENT_NAME$6, "usage: <el-form-item><label-wrap /></el-form-item>");
        const ns = useNamespace("form");
        const el = ref();
        const computedWidth = ref(0);
        const getLabelWidth = () => {
          var _a2;
          if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
            const width = window.getComputedStyle(el.value.firstElementChild).width;
            return Math.ceil(Number.parseFloat(width));
          } else {
            return 0;
          }
        };
        const updateLabelWidth = (action = "update") => {
          nextTick(() => {
            if (slots.default && props.isAutoWidth) {
              if (action === "update") {
                computedWidth.value = getLabelWidth();
              } else if (action === "remove") {
                formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
              }
            }
          });
        };
        const updateLabelWidthFn = () => updateLabelWidth("update");
        onMounted(() => {
          updateLabelWidthFn();
        });
        onBeforeUnmount(() => {
          updateLabelWidth("remove");
        });
        onUpdated(() => updateLabelWidthFn());
        watch(computedWidth, (val, oldVal) => {
          if (props.updateAll) {
            formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
          }
        });
        useResizeObserver(computed(() => {
          var _a2, _b;
          return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
        }), updateLabelWidthFn);
        return () => {
          var _a2, _b;
          if (!slots)
            return null;
          const {
            isAutoWidth
          } = props;
          if (isAutoWidth) {
            const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
            const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
            const style = {};
            if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
              const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
              const labelPosition = formItemContext.labelPosition || formContext.labelPosition;
              const marginPosition = labelPosition === "left" ? "marginRight" : "marginLeft";
              if (marginWidth) {
                style[marginPosition] = `${marginWidth}px`;
              }
            }
            return createVNode("div", {
              "ref": el,
              "class": [ns.be("item", "label-wrap")],
              "style": style
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
          } else {
            return createVNode(Fragment, {
              "ref": el
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
          }
        };
      }
    });
    const _hoisted_1$i = ["role", "aria-labelledby"];
    const __default__$t = /* @__PURE__ */ defineComponent({
      name: "ElFormItem"
    });
    const _sfc_main$K = /* @__PURE__ */ defineComponent({
      ...__default__$t,
      props: formItemProps,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        const formContext = inject(formContextKey, void 0);
        const parentFormItemContext = inject(formItemContextKey, void 0);
        const _size = useFormSize(void 0, { formItem: false });
        const ns = useNamespace("form-item");
        const labelId = useId().value;
        const inputIds = ref([]);
        const validateState = ref("");
        const validateStateDebounced = refDebounced(validateState, 100);
        const validateMessage = ref("");
        const formItemRef = ref();
        let initialValue = void 0;
        let isResettingField = false;
        const labelPosition = computed(() => props.labelPosition || (formContext == null ? void 0 : formContext.labelPosition));
        const labelStyle = computed(() => {
          if (labelPosition.value === "top") {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (labelWidth)
            return { width: labelWidth };
          return {};
        });
        const contentStyle = computed(() => {
          if (labelPosition.value === "top" || (formContext == null ? void 0 : formContext.inline)) {
            return {};
          }
          if (!props.label && !props.labelWidth && isNested) {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (!props.label && !slots.label) {
            return { marginLeft: labelWidth };
          }
          return {};
        });
        const formItemClasses = computed(() => [
          ns.b(),
          ns.m(_size.value),
          ns.is("error", validateState.value === "error"),
          ns.is("validating", validateState.value === "validating"),
          ns.is("success", validateState.value === "success"),
          ns.is("required", isRequired.value || props.required),
          ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
          (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
          {
            [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon,
            [ns.m(`label-${labelPosition.value}`)]: labelPosition.value
          }
        ]);
        const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
        const validateClasses = computed(() => [
          ns.e("error"),
          { [ns.em("error", "inline")]: _inlineMessage.value }
        ]);
        const propString = computed(() => {
          if (!props.prop)
            return "";
          return isString$1(props.prop) ? props.prop : props.prop.join(".");
        });
        const hasLabel = computed(() => {
          return !!(props.label || slots.label);
        });
        const labelFor = computed(() => {
          return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
        });
        const isGroup = computed(() => {
          return !labelFor.value && hasLabel.value;
        });
        const isNested = !!parentFormItemContext;
        const fieldValue = computed(() => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop) {
            return;
          }
          return getProp(model, props.prop).value;
        });
        const normalizedRules = computed(() => {
          const { required } = props;
          const rules2 = [];
          if (props.rules) {
            rules2.push(...castArray(props.rules));
          }
          const formRules = formContext == null ? void 0 : formContext.rules;
          if (formRules && props.prop) {
            const _rules = getProp(formRules, props.prop).value;
            if (_rules) {
              rules2.push(...castArray(_rules));
            }
          }
          if (required !== void 0) {
            const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
            if (requiredRules.length > 0) {
              for (const [rule, i] of requiredRules) {
                if (rule.required === required)
                  continue;
                rules2[i] = { ...rule, required };
              }
            } else {
              rules2.push({ required });
            }
          }
          return rules2;
        });
        const validateEnabled = computed(() => normalizedRules.value.length > 0);
        const getFilteredRule = (trigger2) => {
          const rules2 = normalizedRules.value;
          return rules2.filter((rule) => {
            if (!rule.trigger || !trigger2)
              return true;
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          }).map(({ trigger: trigger22, ...rule }) => rule);
        };
        const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
        const shouldShowError = computed(() => {
          var _a2;
          return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
        });
        const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
        const setValidationState = (state) => {
          validateState.value = state;
        };
        const onValidationFailed = (error) => {
          var _a2, _b;
          const { errors, fields } = error;
          if (!errors || !fields) {
            console.error(error);
          }
          setValidationState("error");
          validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
          formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
        };
        const onValidationSucceeded = () => {
          setValidationState("success");
          formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
        };
        const doValidate = async (rules2) => {
          const modelName = propString.value;
          const validator = new Schema({
            [modelName]: rules2
          });
          return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
            onValidationSucceeded();
            return true;
          }).catch((err) => {
            onValidationFailed(err);
            return Promise.reject(err);
          });
        };
        const validate = async (trigger2, callback) => {
          if (isResettingField || !props.prop) {
            return false;
          }
          const hasCallback = isFunction$1(callback);
          if (!validateEnabled.value) {
            callback == null ? void 0 : callback(false);
            return false;
          }
          const rules2 = getFilteredRule(trigger2);
          if (rules2.length === 0) {
            callback == null ? void 0 : callback(true);
            return true;
          }
          setValidationState("validating");
          return doValidate(rules2).then(() => {
            callback == null ? void 0 : callback(true);
            return true;
          }).catch((err) => {
            const { fields } = err;
            callback == null ? void 0 : callback(false, fields);
            return hasCallback ? false : Promise.reject(fields);
          });
        };
        const clearValidate = () => {
          setValidationState("");
          validateMessage.value = "";
          isResettingField = false;
        };
        const resetField = async () => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop)
            return;
          const computedValue = getProp(model, props.prop);
          isResettingField = true;
          computedValue.value = clone(initialValue);
          await nextTick();
          clearValidate();
          isResettingField = false;
        };
        const addInputId = (id) => {
          if (!inputIds.value.includes(id)) {
            inputIds.value.push(id);
          }
        };
        const removeInputId = (id) => {
          inputIds.value = inputIds.value.filter((listId) => listId !== id);
        };
        watch(() => props.error, (val) => {
          validateMessage.value = val || "";
          setValidationState(val ? "error" : "");
        }, { immediate: true });
        watch(() => props.validateStatus, (val) => setValidationState(val || ""));
        const context = reactive({
          ...toRefs(props),
          $el: formItemRef,
          size: _size,
          validateState,
          labelId,
          inputIds,
          isGroup,
          hasLabel,
          fieldValue,
          addInputId,
          removeInputId,
          resetField,
          clearValidate,
          validate
        });
        provide(formItemContextKey, context);
        onMounted(() => {
          if (props.prop) {
            formContext == null ? void 0 : formContext.addField(context);
            initialValue = clone(fieldValue.value);
          }
        });
        onBeforeUnmount(() => {
          formContext == null ? void 0 : formContext.removeField(context);
        });
        expose({
          size: _size,
          validateMessage,
          validateState,
          validate,
          clearValidate,
          resetField
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("div", {
            ref_key: "formItemRef",
            ref: formItemRef,
            class: normalizeClass(unref(formItemClasses)),
            role: unref(isGroup) ? "group" : void 0,
            "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
          }, [
            createVNode(unref(FormLabelWrap), {
              "is-auto-width": unref(labelStyle).width === "auto",
              "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
            }, {
              default: withCtx(() => [
                unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                  key: 0,
                  id: unref(labelId),
                  for: unref(labelFor),
                  class: normalizeClass(unref(ns).e("label")),
                  style: normalizeStyle(unref(labelStyle))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                      createTextVNode(toDisplayString(unref(currentLabel)), 1)
                    ])
                  ]),
                  _: 3
                }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["is-auto-width", "update-all"]),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns).e("content")),
              style: normalizeStyle(unref(contentStyle))
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(TransitionGroup, {
                name: `${unref(ns).namespace.value}-zoom-in-top`
              }, {
                default: withCtx(() => [
                  unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                    key: 0,
                    error: validateMessage.value
                  }, () => [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(validateClasses))
                    }, toDisplayString(validateMessage.value), 3)
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 6)
          ], 10, _hoisted_1$i);
        };
      }
    });
    var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "form-item.vue"]]);
    const ElForm = withInstall(Form, {
      FormItem
    });
    const ElFormItem = withNoopInstall(FormItem);
    let hiddenTextarea = void 0;
    const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
    const CONTEXT_STYLE = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing"
    ];
    function calculateNodeStyling(targetElement) {
      const style = window.getComputedStyle(targetElement);
      const boxSizing = style.getPropertyValue("box-sizing");
      const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
      const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
      const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
      return { contextStyle, paddingSize, borderSize, boxSizing };
    }
    function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
      var _a2;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
      }
      const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
      hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
      hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
      let height = hiddenTextarea.scrollHeight;
      const result = {};
      if (boxSizing === "border-box") {
        height = height + borderSize;
      } else if (boxSizing === "content-box") {
        height = height - paddingSize;
      }
      hiddenTextarea.value = "";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (isNumber(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
      }
      if (isNumber(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        height = Math.min(maxHeight, height);
      }
      result.height = `${height}px`;
      (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
      hiddenTextarea = void 0;
      return result;
    }
    const inputProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: definePropType([
          String,
          Number,
          Object
        ]),
        default: ""
      },
      maxlength: {
        type: [String, Number]
      },
      minlength: {
        type: [String, Number]
      },
      type: {
        type: String,
        default: "text"
      },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
      },
      autosize: {
        type: definePropType([Boolean, Object]),
        default: false
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: {
        type: String
      },
      form: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      showPassword: {
        type: Boolean,
        default: false
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: iconPropType
      },
      prefixIcon: {
        type: iconPropType
      },
      containerRole: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
      },
      autofocus: {
        type: Boolean,
        default: false
      },
      ...useAriaProps(["ariaLabel"])
    });
    const inputEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
      input: (value) => isString$1(value),
      change: (value) => isString$1(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      mouseleave: (evt) => evt instanceof MouseEvent,
      mouseenter: (evt) => evt instanceof MouseEvent,
      keydown: (evt) => evt instanceof Event,
      compositionstart: (evt) => evt instanceof CompositionEvent,
      compositionupdate: (evt) => evt instanceof CompositionEvent,
      compositionend: (evt) => evt instanceof CompositionEvent
    };
    const _hoisted_1$h = ["role"];
    const _hoisted_2$7 = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
    const _hoisted_3$4 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
    const __default__$s = /* @__PURE__ */ defineComponent({
      name: "ElInput",
      inheritAttrs: false
    });
    const _sfc_main$J = /* @__PURE__ */ defineComponent({
      ...__default__$s,
      props: inputProps,
      emits: inputEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const rawAttrs = useAttrs$1();
        const slots = useSlots();
        const containerAttrs = computed(() => {
          const comboBoxAttrs = {};
          if (props.containerRole === "combobox") {
            comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
            comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
            comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
          }
          return comboBoxAttrs;
        });
        const containerKls = computed(() => [
          props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
          nsInput.m(inputSize.value),
          nsInput.is("disabled", inputDisabled.value),
          nsInput.is("exceed", inputExceed.value),
          {
            [nsInput.b("group")]: slots.prepend || slots.append,
            [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
            [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
            [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
            [nsInput.b("hidden")]: props.type === "hidden"
          },
          rawAttrs.class
        ]);
        const wrapperKls = computed(() => [
          nsInput.e("wrapper"),
          nsInput.is("focus", isFocused.value)
        ]);
        const attrs = useAttrs({
          excludeKeys: computed(() => {
            return Object.keys(containerAttrs.value);
          })
        });
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: elFormItem
        });
        const inputSize = useFormSize();
        const inputDisabled = useFormDisabled();
        const nsInput = useNamespace("input");
        const nsTextarea = useNamespace("textarea");
        const input = shallowRef();
        const textarea = shallowRef();
        const hovering = ref(false);
        const isComposing = ref(false);
        const passwordVisible = ref(false);
        const countStyle = ref();
        const textareaCalcStyle = shallowRef(props.inputStyle);
        const _ref = computed(() => input.value || textarea.value);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
          afterBlur() {
            var _a2;
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const needStatusIcon = computed(() => {
          var _a2;
          return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
        });
        const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
        const containerStyle = computed(() => [
          rawAttrs.style
        ]);
        const textareaStyle = computed(() => [
          props.inputStyle,
          textareaCalcStyle.value,
          { resize: props.resize }
        ]);
        const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
        const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
        const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
        const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
        const textLength = computed(() => nativeInputValue.value.length);
        const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
        const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
        const [recordCursor, setCursor] = useCursor(input);
        useResizeObserver(textarea, (entries) => {
          onceInitSizeTextarea();
          if (!isWordLimitVisible.value || props.resize !== "both")
            return;
          const entry = entries[0];
          const { width } = entry.contentRect;
          countStyle.value = {
            right: `calc(100% - ${width + 15 + 6}px)`
          };
        });
        const resizeTextarea = () => {
          const { type, autosize } = props;
          if (!isClient || type !== "textarea" || !textarea.value)
            return;
          if (autosize) {
            const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
            const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
            const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
            textareaCalcStyle.value = {
              overflowY: "hidden",
              ...textareaStyle2
            };
            nextTick(() => {
              textarea.value.offsetHeight;
              textareaCalcStyle.value = textareaStyle2;
            });
          } else {
            textareaCalcStyle.value = {
              minHeight: calcTextareaHeight(textarea.value).minHeight
            };
          }
        };
        const createOnceInitResize = (resizeTextarea2) => {
          let isInit = false;
          return () => {
            var _a2;
            if (isInit || !props.autosize)
              return;
            const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
            if (!isElHidden) {
              resizeTextarea2();
              isInit = true;
            }
          };
        };
        const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
        const setNativeInputValue = () => {
          const input2 = _ref.value;
          const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
          if (!input2 || input2.value === formatterValue)
            return;
          input2.value = formatterValue;
        };
        const handleInput = async (event) => {
          recordCursor();
          let { value } = event.target;
          if (props.formatter) {
            value = props.parser ? props.parser(value) : value;
          }
          if (isComposing.value)
            return;
          if (value === nativeInputValue.value) {
            setNativeInputValue();
            return;
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emit2("input", value);
          await nextTick();
          setNativeInputValue();
          setCursor();
        };
        const handleChange = (event) => {
          emit2("change", event.target.value);
        };
        const handleCompositionStart = (event) => {
          emit2("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit2("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit2("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            handleInput(event);
          }
        };
        const handlePasswordVisible = () => {
          passwordVisible.value = !passwordVisible.value;
          focus();
        };
        const focus = async () => {
          var _a2;
          await nextTick();
          (_a2 = _ref.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
        };
        const handleMouseLeave = (evt) => {
          hovering.value = false;
          emit2("mouseleave", evt);
        };
        const handleMouseEnter = (evt) => {
          hovering.value = true;
          emit2("mouseenter", evt);
        };
        const handleKeydown = (evt) => {
          emit2("keydown", evt);
        };
        const select = () => {
          var _a2;
          (_a2 = _ref.value) == null ? void 0 : _a2.select();
        };
        const clear = () => {
          emit2(UPDATE_MODEL_EVENT, "");
          emit2("change", "");
          emit2("clear");
          emit2("input", "");
        };
        watch(() => props.modelValue, () => {
          var _a2;
          nextTick(() => resizeTextarea());
          if (props.validateEvent) {
            (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
          }
        });
        watch(nativeInputValue, () => setNativeInputValue());
        watch(() => props.type, async () => {
          await nextTick();
          setNativeInputValue();
          resizeTextarea();
        });
        onMounted(() => {
          if (!props.formatter && props.parser) ;
          setNativeInputValue();
          nextTick(resizeTextarea);
        });
        useDeprecated({
          from: "label",
          replacement: "aria-label",
          version: "2.8.0",
          scope: "el-input",
          ref: "https://element-plus.org/en-US/component/input.html"
        }, computed(() => !!props.label));
        expose({
          input,
          textarea,
          ref: _ref,
          textareaStyle,
          autosize: toRef(props, "autosize"),
          focus,
          blur,
          select,
          clear,
          resizeTextarea
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
            class: [
              unref(containerKls),
              {
                [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
              }
            ],
            style: unref(containerStyle),
            role: _ctx.containerRole,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }), [
            createCommentVNode(" input "),
            _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" prepend slot "),
              _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(nsInput).be("group", "prepend"))
              }, [
                renderSlot(_ctx.$slots, "prepend")
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                ref_key: "wrapperRef",
                ref: wrapperRef,
                class: normalizeClass(unref(wrapperKls))
              }, [
                createCommentVNode(" prefix slot "),
                _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("prefix-inner"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  id: unref(inputId),
                  ref_key: "input",
                  ref: input,
                  class: unref(nsInput).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  tabindex: _ctx.tabindex,
                  "aria-label": _ctx.label || _ctx.ariaLabel,
                  placeholder: _ctx.placeholder,
                  style: _ctx.inputStyle,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_2$7),
                createCommentVNode(" suffix slot "),
                unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).e("suffix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("suffix-inner"))
                  }, [
                    !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      renderSlot(_ctx.$slots, "suffix"),
                      _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 64)) : createCommentVNode("v-if", true),
                    unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: clear
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(circle_close_default))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                    unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                      onClick: handlePasswordVisible
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsInput).e("count-inner"))
                      }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 4,
                      class: normalizeClass([
                        unref(nsInput).e("icon"),
                        unref(nsInput).e("validateIcon"),
                        unref(nsInput).is("loading", unref(validateState) === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              createCommentVNode(" append slot "),
              _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(nsInput).be("group", "append"))
              }, [
                renderSlot(_ctx.$slots, "append")
              ], 2)) : createCommentVNode("v-if", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" textarea "),
              createBaseVNode("textarea", mergeProps({
                id: unref(inputId),
                ref_key: "textarea",
                ref: textarea,
                class: [unref(nsTextarea).e("inner"), unref(nsInput).is("focus", unref(isFocused))]
              }, unref(attrs), {
                minlength: _ctx.minlength,
                maxlength: _ctx.maxlength,
                tabindex: _ctx.tabindex,
                disabled: unref(inputDisabled),
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: unref(textareaStyle),
                "aria-label": _ctx.label || _ctx.ariaLabel,
                placeholder: _ctx.placeholder,
                form: _ctx.form,
                autofocus: _ctx.autofocus,
                onCompositionstart: handleCompositionStart,
                onCompositionupdate: handleCompositionUpdate,
                onCompositionend: handleCompositionEnd,
                onInput: handleInput,
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                onChange: handleChange,
                onKeydown: handleKeydown
              }), null, 16, _hoisted_3$4),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: normalizeStyle(countStyle.value),
                class: normalizeClass(unref(nsInput).e("count"))
              }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
            ], 64))
          ], 16, _hoisted_1$h);
        };
      }
    });
    var Input = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "input.vue"]]);
    const ElInput = withInstall(Input);
    const GAP = 4;
    const BAR_MAP = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
      }
    };
    const renderThumbStyle = ({
      move,
      size,
      bar
    }) => ({
      [bar.size]: size,
      transform: `translate${bar.axis}(${move}%)`
    });
    const scrollbarContextKey = Symbol("scrollbarContextKey");
    const thumbProps = buildProps({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: {
        type: Number,
        required: true
      },
      always: Boolean
    });
    const COMPONENT_NAME$5 = "Thumb";
    const _sfc_main$I = /* @__PURE__ */ defineComponent({
      __name: "thumb",
      props: thumbProps,
      setup(__props) {
        const props = __props;
        const scrollbar = inject(scrollbarContextKey);
        const ns = useNamespace("scrollbar");
        if (!scrollbar)
          throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
        const instance = ref();
        const thumb = ref();
        const thumbState = ref({});
        const visible = ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = isClient ? document.onselectstart : null;
        const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
        const thumbStyle = computed(() => renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        }));
        const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
        const clickThumbHandler = (e) => {
          var _a2;
          e.stopPropagation();
          if (e.ctrlKey || [1, 2].includes(e.button))
            return;
          (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
          startDrag(e);
          const el = e.currentTarget;
          if (!el)
            return;
          thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e) => {
          if (!thumb.value || !instance.value || !scrollbar.wrapElement)
            return;
          const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
          const thumbHalf = thumb.value[bar.value.offset] / 2;
          const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e) => {
          e.stopImmediatePropagation();
          cursorDown = true;
          document.addEventListener("mousemove", mouseMoveDocumentHandler);
          document.addEventListener("mouseup", mouseUpDocumentHandler);
          originalOnSelectStart = document.onselectstart;
          document.onselectstart = () => false;
        };
        const mouseMoveDocumentHandler = (e) => {
          if (!instance.value || !thumb.value)
            return;
          if (cursorDown === false)
            return;
          const prevPage = thumbState.value[bar.value.axis];
          if (!prevPage)
            return;
          const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
          const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
          const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = () => {
          cursorDown = false;
          thumbState.value[bar.value.axis] = 0;
          document.removeEventListener("mousemove", mouseMoveDocumentHandler);
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
          restoreOnselectstart();
          if (cursorLeave)
            visible.value = false;
        };
        const mouseMoveScrollbarHandler = () => {
          cursorLeave = false;
          visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = () => {
          cursorLeave = true;
          visible.value = cursorDown;
        };
        onBeforeUnmount(() => {
          restoreOnselectstart();
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = () => {
          if (document.onselectstart !== originalOnSelectStart)
            document.onselectstart = originalOnSelectStart;
        };
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "instance",
                ref: instance,
                class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                onMousedown: clickTrackHandler
              }, [
                createBaseVNode("div", {
                  ref_key: "thumb",
                  ref: thumb,
                  class: normalizeClass(unref(ns).e("thumb")),
                  style: normalizeStyle(unref(thumbStyle)),
                  onMousedown: clickThumbHandler
                }, null, 38)
              ], 34), [
                [vShow, _ctx.always || visible.value]
              ])
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "thumb.vue"]]);
    const barProps = buildProps({
      always: {
        type: Boolean,
        default: true
      },
      minSize: {
        type: Number,
        required: true
      }
    });
    const _sfc_main$H = /* @__PURE__ */ defineComponent({
      __name: "bar",
      props: barProps,
      setup(__props, { expose }) {
        const props = __props;
        const scrollbar = inject(scrollbarContextKey);
        const moveX = ref(0);
        const moveY = ref(0);
        const sizeWidth = ref("");
        const sizeHeight = ref("");
        const ratioY = ref(1);
        const ratioX = ref(1);
        const handleScroll = (wrap) => {
          if (wrap) {
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            moveY.value = wrap.scrollTop * 100 / offsetHeight * ratioY.value;
            moveX.value = wrap.scrollLeft * 100 / offsetWidth * ratioX.value;
          }
        };
        const update = () => {
          const wrap = scrollbar == null ? void 0 : scrollbar.wrapElement;
          if (!wrap)
            return;
          const offsetHeight = wrap.offsetHeight - GAP;
          const offsetWidth = wrap.offsetWidth - GAP;
          const originalHeight = offsetHeight ** 2 / wrap.scrollHeight;
          const originalWidth = offsetWidth ** 2 / wrap.scrollWidth;
          const height = Math.max(originalHeight, props.minSize);
          const width = Math.max(originalWidth, props.minSize);
          ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
          ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
          sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
          sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        expose({
          handleScroll,
          update
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(Thumb, {
              move: moveX.value,
              ratio: ratioX.value,
              size: sizeWidth.value,
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"]),
            createVNode(Thumb, {
              move: moveY.value,
              ratio: ratioY.value,
              size: sizeHeight.value,
              vertical: "",
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"])
          ], 64);
        };
      }
    });
    var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "bar.vue"]]);
    const scrollbarProps = buildProps({
      height: {
        type: [String, Number],
        default: ""
      },
      maxHeight: {
        type: [String, Number],
        default: ""
      },
      native: {
        type: Boolean,
        default: false
      },
      wrapStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      wrapClass: {
        type: [String, Array],
        default: ""
      },
      viewClass: {
        type: [String, Array],
        default: ""
      },
      viewStyle: {
        type: [String, Array, Object],
        default: ""
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div"
      },
      always: Boolean,
      minSize: {
        type: Number,
        default: 20
      },
      id: String,
      role: String,
      ...useAriaProps(["ariaLabel", "ariaOrientation"])
    });
    const scrollbarEmits = {
      scroll: ({
        scrollTop,
        scrollLeft
      }) => [scrollTop, scrollLeft].every(isNumber)
    };
    const COMPONENT_NAME$4 = "ElScrollbar";
    const __default__$r = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$4
    });
    const _sfc_main$G = /* @__PURE__ */ defineComponent({
      ...__default__$r,
      props: scrollbarProps,
      emits: scrollbarEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbarRef = ref();
        const wrapRef = ref();
        const resizeRef = ref();
        const barRef = ref();
        const wrapStyle = computed(() => {
          const style = {};
          if (props.height)
            style.height = addUnit(props.height);
          if (props.maxHeight)
            style.maxHeight = addUnit(props.maxHeight);
          return [props.wrapStyle, style];
        });
        const wrapKls = computed(() => {
          return [
            props.wrapClass,
            ns.e("wrap"),
            { [ns.em("wrap", "hidden-default")]: !props.native }
          ];
        });
        const resizeKls = computed(() => {
          return [ns.e("view"), props.viewClass];
        });
        const handleScroll = () => {
          var _a2;
          if (wrapRef.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
            emit2("scroll", {
              scrollTop: wrapRef.value.scrollTop,
              scrollLeft: wrapRef.value.scrollLeft
            });
          }
        };
        function scrollTo(arg1, arg2) {
          if (isObject$1(arg1)) {
            wrapRef.value.scrollTo(arg1);
          } else if (isNumber(arg1) && isNumber(arg2)) {
            wrapRef.value.scrollTo(arg1, arg2);
          }
        }
        const setScrollTop = (value) => {
          if (!isNumber(value)) {
            return;
          }
          wrapRef.value.scrollTop = value;
        };
        const setScrollLeft = (value) => {
          if (!isNumber(value)) {
            return;
          }
          wrapRef.value.scrollLeft = value;
        };
        const update = () => {
          var _a2;
          (_a2 = barRef.value) == null ? void 0 : _a2.update();
        };
        watch(() => props.noresize, (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
            stopResizeListener = useEventListener("resize", update);
          }
        }, { immediate: true });
        watch(() => [props.maxHeight, props.height], () => {
          if (!props.native)
            nextTick(() => {
              var _a2;
              update();
              if (wrapRef.value) {
                (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              }
            });
        });
        provide(scrollbarContextKey, reactive({
          scrollbarElement: scrollbarRef,
          wrapElement: wrapRef
        }));
        onMounted(() => {
          if (!props.native)
            nextTick(() => {
              update();
            });
        });
        onUpdated(() => update());
        expose({
          wrapRef,
          update,
          scrollTo,
          setScrollTop,
          setScrollLeft,
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "scrollbarRef",
            ref: scrollbarRef,
            class: normalizeClass(unref(ns).b())
          }, [
            createBaseVNode("div", {
              ref_key: "wrapRef",
              ref: wrapRef,
              class: normalizeClass(unref(wrapKls)),
              style: normalizeStyle(unref(wrapStyle)),
              onScroll: handleScroll
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                id: _ctx.id,
                ref_key: "resizeRef",
                ref: resizeRef,
                class: normalizeClass(unref(resizeKls)),
                style: normalizeStyle(_ctx.viewStyle),
                role: _ctx.role,
                "aria-label": _ctx.ariaLabel,
                "aria-orientation": _ctx.ariaOrientation
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
            ], 38),
            !_ctx.native ? (openBlock(), createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              always: _ctx.always,
              "min-size": _ctx.minSize
            }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "scrollbar.vue"]]);
    const ElScrollbar = withInstall(Scrollbar);
    const POPPER_INJECTION_KEY = Symbol("popper");
    const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    const roleTypes = [
      "dialog",
      "grid",
      "group",
      "listbox",
      "menu",
      "navigation",
      "tooltip",
      "tree"
    ];
    const popperProps = buildProps({
      role: {
        type: String,
        values: roleTypes,
        default: "tooltip"
      }
    });
    const __default__$q = /* @__PURE__ */ defineComponent({
      name: "ElPopper",
      inheritAttrs: false
    });
    const _sfc_main$F = /* @__PURE__ */ defineComponent({
      ...__default__$q,
      props: popperProps,
      setup(__props, { expose }) {
        const props = __props;
        const triggerRef = ref();
        const popperInstanceRef = ref();
        const contentRef = ref();
        const referenceRef = ref();
        const role = computed(() => props.role);
        const popperProvides = {
          triggerRef,
          popperInstanceRef,
          contentRef,
          referenceRef,
          role
        };
        expose(popperProvides);
        provide(POPPER_INJECTION_KEY, popperProvides);
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default");
        };
      }
    });
    var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "popper.vue"]]);
    const popperArrowProps = buildProps({
      arrowOffset: {
        type: Number,
        default: 5
      }
    });
    const __default__$p = /* @__PURE__ */ defineComponent({
      name: "ElPopperArrow",
      inheritAttrs: false
    });
    const _sfc_main$E = /* @__PURE__ */ defineComponent({
      ...__default__$p,
      props: popperArrowProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("popper");
        const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
        watch(() => props.arrowOffset, (val) => {
          arrowOffset.value = val;
        });
        onBeforeUnmount(() => {
          arrowRef.value = void 0;
        });
        expose({
          arrowRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            class: normalizeClass(unref(ns).e("arrow")),
            style: normalizeStyle(unref(arrowStyle)),
            "data-popper-arrow": ""
          }, null, 6);
        };
      }
    });
    var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "arrow.vue"]]);
    const NAME = "ElOnlyChild";
    const OnlyChild = /* @__PURE__ */ defineComponent({
      name: NAME,
      setup(_, {
        slots,
        attrs
      }) {
        var _a2;
        const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
        const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
        return () => {
          var _a22;
          const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
          if (!defaultSlot)
            return null;
          if (defaultSlot.length > 1) {
            return null;
          }
          const firstLegitNode = findFirstLegitChild(defaultSlot);
          if (!firstLegitNode) {
            return null;
          }
          return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
        };
      }
    });
    function findFirstLegitChild(node) {
      if (!node)
        return null;
      const children = node;
      for (const child of children) {
        if (isObject$1(child)) {
          switch (child.type) {
            case Comment:
              continue;
            case Text:
            case "svg":
              return wrapTextContent(child);
            case Fragment:
              return findFirstLegitChild(child.children);
            default:
              return child;
          }
        }
        return wrapTextContent(child);
      }
      return null;
    }
    function wrapTextContent(s) {
      const ns = useNamespace("only-child");
      return createVNode("span", {
        "class": ns.e("content")
      }, [s]);
    }
    const popperTriggerProps = buildProps({
      virtualRef: {
        type: definePropType(Object)
      },
      virtualTriggering: Boolean,
      onMouseenter: {
        type: definePropType(Function)
      },
      onMouseleave: {
        type: definePropType(Function)
      },
      onClick: {
        type: definePropType(Function)
      },
      onKeydown: {
        type: definePropType(Function)
      },
      onFocus: {
        type: definePropType(Function)
      },
      onBlur: {
        type: definePropType(Function)
      },
      onContextmenu: {
        type: definePropType(Function)
      },
      id: String,
      open: Boolean
    });
    const __default__$o = /* @__PURE__ */ defineComponent({
      name: "ElPopperTrigger",
      inheritAttrs: false
    });
    const _sfc_main$D = /* @__PURE__ */ defineComponent({
      ...__default__$o,
      props: popperTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
        useForwardRef(triggerRef);
        const ariaControls = computed(() => {
          return ariaHaspopup.value ? props.id : void 0;
        });
        const ariaDescribedby = computed(() => {
          if (role && role.value === "tooltip") {
            return props.open && props.id ? props.id : void 0;
          }
          return void 0;
        });
        const ariaHaspopup = computed(() => {
          if (role && role.value !== "tooltip") {
            return role.value;
          }
          return void 0;
        });
        const ariaExpanded = computed(() => {
          return ariaHaspopup.value ? `${props.open}` : void 0;
        });
        let virtualTriggerAriaStopWatch = void 0;
        onMounted(() => {
          watch(() => props.virtualRef, (virtualEl) => {
            if (virtualEl) {
              triggerRef.value = unrefElement(virtualEl);
            }
          }, {
            immediate: true
          });
          watch(triggerRef, (el, prevEl) => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (isElement(el)) {
              [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ].forEach((eventName) => {
                var _a2;
                const handler = props[eventName];
                if (handler) {
                  el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                  (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                }
              });
              virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement(prevEl)) {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((key) => prevEl.removeAttribute(key));
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
          virtualTriggerAriaStopWatch = void 0;
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
            "aria-controls": unref(ariaControls),
            "aria-describedby": unref(ariaDescribedby),
            "aria-expanded": unref(ariaExpanded),
            "aria-haspopup": unref(ariaHaspopup)
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
        };
      }
    });
    var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__file", "trigger.vue"]]);
    const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
    const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
    const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
    const FOCUS_AFTER_TRAPPED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const FOCUSOUT_PREVENTED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
    const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
    const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
    const focusReason = ref();
    const lastUserFocusTimestamp = ref(0);
    const lastAutomatedFocusTimestamp = ref(0);
    let focusReasonUserCount = 0;
    const obtainAllFocusableElements = (element) => {
      const nodes = [];
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput)
            return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode())
        nodes.push(walker.currentNode);
      return nodes;
    };
    const getVisibleElement = (elements, container) => {
      for (const element of elements) {
        if (!isHidden(element, container))
          return element;
      }
    };
    const isHidden = (element, container) => {
      if (getComputedStyle(element).visibility === "hidden")
        return true;
      while (element) {
        if (container && element === container)
          return false;
        if (getComputedStyle(element).display === "none")
          return true;
        element = element.parentElement;
      }
      return false;
    };
    const getEdges = (container) => {
      const focusable = obtainAllFocusableElements(container);
      const first = getVisibleElement(focusable, container);
      const last = getVisibleElement(focusable.reverse(), container);
      return [first, last];
    };
    const isSelectable = (element) => {
      return element instanceof HTMLInputElement && "select" in element;
    };
    const tryFocus = (element, shouldSelect) => {
      if (element && element.focus) {
        const prevFocusedElement = document.activeElement;
        element.focus({ preventScroll: true });
        lastAutomatedFocusTimestamp.value = window.performance.now();
        if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
          element.select();
        }
      }
    };
    function removeFromStack(list, item) {
      const copy = [...list];
      const idx = list.indexOf(item);
      if (idx !== -1) {
        copy.splice(idx, 1);
      }
      return copy;
    }
    const createFocusableStack = () => {
      let stack2 = [];
      const push = (layer) => {
        const currentLayer = stack2[0];
        if (currentLayer && layer !== currentLayer) {
          currentLayer.pause();
        }
        stack2 = removeFromStack(stack2, layer);
        stack2.unshift(layer);
      };
      const remove2 = (layer) => {
        var _a2, _b;
        stack2 = removeFromStack(stack2, layer);
        (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
      };
      return {
        push,
        remove: remove2
      };
    };
    const focusFirstDescendant = (elements, shouldSelect = false) => {
      const prevFocusedElement = document.activeElement;
      for (const element of elements) {
        tryFocus(element, shouldSelect);
        if (document.activeElement !== prevFocusedElement)
          return;
      }
    };
    const focusableStack = createFocusableStack();
    const isFocusCausedByUserEvent = () => {
      return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
    };
    const notifyFocusReasonPointer = () => {
      focusReason.value = "pointer";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const notifyFocusReasonKeydown = () => {
      focusReason.value = "keyboard";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const useFocusReason = () => {
      onMounted(() => {
        if (focusReasonUserCount === 0) {
          document.addEventListener("mousedown", notifyFocusReasonPointer);
          document.addEventListener("touchstart", notifyFocusReasonPointer);
          document.addEventListener("keydown", notifyFocusReasonKeydown);
        }
        focusReasonUserCount++;
      });
      onBeforeUnmount(() => {
        focusReasonUserCount--;
        if (focusReasonUserCount <= 0) {
          document.removeEventListener("mousedown", notifyFocusReasonPointer);
          document.removeEventListener("touchstart", notifyFocusReasonPointer);
          document.removeEventListener("keydown", notifyFocusReasonKeydown);
        }
      });
      return {
        focusReason,
        lastUserFocusTimestamp,
        lastAutomatedFocusTimestamp
      };
    };
    const createFocusOutPreventedEvent = (detail) => {
      return new CustomEvent(FOCUSOUT_PREVENTED, {
        ...FOCUSOUT_PREVENTED_OPTS,
        detail
      });
    };
    const _sfc_main$C = /* @__PURE__ */ defineComponent({
      name: "ElFocusTrap",
      inheritAttrs: false,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
          type: [Object, String],
          default: "first"
        }
      },
      emits: [
        ON_TRAP_FOCUS_EVT,
        ON_RELEASE_FOCUS_EVT,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested"
      ],
      setup(props, { emit: emit2 }) {
        const forwardRef = ref();
        let lastFocusBeforeTrapped;
        let lastFocusAfterTrapped;
        const { focusReason: focusReason2 } = useFocusReason();
        useEscapeKeydown((event) => {
          if (props.trapped && !focusLayer.paused) {
            emit2("release-requested", event);
          }
        });
        const focusLayer = {
          paused: false,
          pause() {
            this.paused = true;
          },
          resume() {
            this.paused = false;
          }
        };
        const onKeydown = (e) => {
          if (!props.loop && !props.trapped)
            return;
          if (focusLayer.paused)
            return;
          const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
          const { loop } = props;
          const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
          const currentFocusingEl = document.activeElement;
          if (isTabbing && currentFocusingEl) {
            const container = currentTarget;
            const [first, last] = getEdges(container);
            const isTabbable = first && last;
            if (!isTabbable) {
              if (currentFocusingEl === container) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                }
              }
            } else {
              if (!shiftKey && currentFocusingEl === last) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(first, true);
                }
              } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(last, true);
                }
              }
            }
          }
        };
        provide(FOCUS_TRAP_INJECTION_KEY, {
          focusTrapRef: forwardRef,
          onKeydown
        });
        watch(() => props.focusTrapEl, (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        }, { immediate: true });
        watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
          if (forwardRef2) {
            forwardRef2.addEventListener("keydown", onKeydown);
            forwardRef2.addEventListener("focusin", onFocusIn);
            forwardRef2.addEventListener("focusout", onFocusOut);
          }
          if (oldForwardRef) {
            oldForwardRef.removeEventListener("keydown", onKeydown);
            oldForwardRef.removeEventListener("focusin", onFocusIn);
            oldForwardRef.removeEventListener("focusout", onFocusOut);
          }
        });
        const trapOnFocus = (e) => {
          emit2(ON_TRAP_FOCUS_EVT, e);
        };
        const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
        const onFocusIn = (e) => {
          const trapContainer = unref(forwardRef);
          if (!trapContainer)
            return;
          const target = e.target;
          const relatedTarget = e.relatedTarget;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!props.trapped) {
            const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
            if (!isPrevFocusedInTrap) {
              lastFocusBeforeTrapped = relatedTarget;
            }
          }
          if (isFocusedInTrap)
            emit2("focusin", e);
          if (focusLayer.paused)
            return;
          if (props.trapped) {
            if (isFocusedInTrap) {
              lastFocusAfterTrapped = target;
            } else {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }
        };
        const onFocusOut = (e) => {
          const trapContainer = unref(forwardRef);
          if (focusLayer.paused || !trapContainer)
            return;
          if (props.trapped) {
            const relatedTarget = e.relatedTarget;
            if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
              setTimeout(() => {
                if (!focusLayer.paused && props.trapped) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    tryFocus(lastFocusAfterTrapped, true);
                  }
                }
              }, 0);
            }
          } else {
            const target = e.target;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!isFocusedInTrap)
              emit2("focusout", e);
          }
        };
        async function startTrap() {
          await nextTick();
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            focusableStack.push(focusLayer);
            const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
            lastFocusBeforeTrapped = prevFocusedElement;
            const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
            if (!isPrevFocusContained) {
              const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
              trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              trapContainer.dispatchEvent(focusEvent);
              if (!focusEvent.defaultPrevented) {
                nextTick(() => {
                  let focusStartEl = props.focusStartEl;
                  if (!isString$1(focusStartEl)) {
                    tryFocus(focusStartEl);
                    if (document.activeElement !== focusStartEl) {
                      focusStartEl = "first";
                    }
                  }
                  if (focusStartEl === "first") {
                    focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                  }
                  if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                    tryFocus(trapContainer);
                  }
                });
              }
            }
          }
        }
        function stopTrap() {
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
              ...FOCUS_AFTER_TRAPPED_OPTS,
              detail: {
                focusReason: focusReason2.value
              }
            });
            trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            trapContainer.dispatchEvent(releasedEvent);
            if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
              tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
            }
            trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            focusableStack.remove(focusLayer);
          }
        }
        onMounted(() => {
          if (props.trapped) {
            startTrap();
          }
          watch(() => props.trapped, (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          });
        });
        onBeforeUnmount(() => {
          if (props.trapped) {
            stopTrap();
          }
        });
        return {
          onKeydown
        };
      }
    });
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
    }
    var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$8], ["__file", "focus-trap.vue"]]);
    const POSITIONING_STRATEGIES = ["fixed", "absolute"];
    const popperCoreConfigProps = buildProps({
      boundariesPadding: {
        type: Number,
        default: 0
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: void 0
      },
      gpuAcceleration: {
        type: Boolean,
        default: true
      },
      offset: {
        type: Number,
        default: 12
      },
      placement: {
        type: String,
        values: Ee,
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      strategy: {
        type: String,
        values: POSITIONING_STRATEGIES,
        default: "absolute"
      }
    });
    const popperContentProps = buildProps({
      ...popperCoreConfigProps,
      id: String,
      style: {
        type: definePropType([String, Array, Object])
      },
      className: {
        type: definePropType([String, Array, Object])
      },
      effect: {
        type: String,
        default: "dark"
      },
      visible: Boolean,
      enterable: {
        type: Boolean,
        default: true
      },
      pure: Boolean,
      focusOnShow: {
        type: Boolean,
        default: false
      },
      trapping: {
        type: Boolean,
        default: false
      },
      popperClass: {
        type: definePropType([String, Array, Object])
      },
      popperStyle: {
        type: definePropType([String, Array, Object])
      },
      referenceEl: {
        type: definePropType(Object)
      },
      triggerTargetEl: {
        type: definePropType(Object)
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true
      },
      virtualTriggering: Boolean,
      zIndex: Number,
      ...useAriaProps(["ariaLabel"])
    });
    const popperContentEmits = {
      mouseenter: (evt) => evt instanceof MouseEvent,
      mouseleave: (evt) => evt instanceof MouseEvent,
      focus: () => true,
      blur: () => true,
      close: () => true
    };
    const buildPopperOptions = (props, modifiers = []) => {
      const { placement, strategy, popperOptions } = props;
      const options = {
        placement,
        strategy,
        ...popperOptions,
        modifiers: [...genModifiers(props), ...modifiers]
      };
      deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
      return options;
    };
    const unwrapMeasurableEl = ($el) => {
      if (!isClient)
        return;
      return unrefElement($el);
    };
    function genModifiers(options) {
      const { offset, gpuAcceleration, fallbackPlacements } = options;
      return [
        {
          name: "offset",
          options: {
            offset: [0, offset != null ? offset : 12]
          }
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        },
        {
          name: "flip",
          options: {
            padding: 5,
            fallbackPlacements
          }
        },
        {
          name: "computeStyles",
          options: {
            gpuAcceleration
          }
        }
      ];
    }
    function deriveExtraModifiers(options, modifiers) {
      if (modifiers) {
        options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
      }
    }
    const DEFAULT_ARROW_OFFSET = 0;
    const usePopperContent = (props) => {
      const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
      const arrowRef = ref();
      const arrowOffset = ref();
      const eventListenerModifier = computed(() => {
        return {
          name: "eventListeners",
          enabled: !!props.visible
        };
      });
      const arrowModifier = computed(() => {
        var _a2;
        const arrowEl = unref(arrowRef);
        const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
        return {
          name: "arrow",
          enabled: !isUndefined$1(arrowEl),
          options: {
            element: arrowEl,
            padding: offset
          }
        };
      });
      const options = computed(() => {
        return {
          onFirstUpdate: () => {
            update();
          },
          ...buildPopperOptions(props, [
            unref(arrowModifier),
            unref(eventListenerModifier)
          ])
        };
      });
      const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
      const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
      watch(instanceRef, (instance) => popperInstanceRef.value = instance);
      onMounted(() => {
        watch(() => {
          var _a2;
          return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
        }, () => {
          update();
        });
      });
      return {
        attributes,
        arrowRef,
        contentRef,
        instanceRef,
        state,
        styles,
        role,
        forceUpdate,
        update
      };
    };
    const usePopperContentDOM = (props, {
      attributes,
      styles,
      role
    }) => {
      const { nextZIndex } = useZIndex();
      const ns = useNamespace("popper");
      const contentAttrs = computed(() => unref(attributes).popper);
      const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
      const contentClass = computed(() => [
        ns.b(),
        ns.is("pure", props.pure),
        ns.is(props.effect),
        props.popperClass
      ]);
      const contentStyle = computed(() => {
        return [
          { zIndex: unref(contentZIndex) },
          unref(styles).popper,
          props.popperStyle || {}
        ];
      });
      const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
      const arrowStyle = computed(() => unref(styles).arrow || {});
      const updateZIndex = () => {
        contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
      };
      return {
        ariaModal,
        arrowStyle,
        contentAttrs,
        contentClass,
        contentStyle,
        contentZIndex,
        updateZIndex
      };
    };
    const usePopperContentFocusTrap = (props, emit2) => {
      const trapped = ref(false);
      const focusStartRef = ref();
      const onFocusAfterTrapped = () => {
        emit2("focus");
      };
      const onFocusAfterReleased = (event) => {
        var _a2;
        if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
          focusStartRef.value = "first";
          emit2("blur");
        }
      };
      const onFocusInTrap = (event) => {
        if (props.visible && !trapped.value) {
          if (event.target) {
            focusStartRef.value = event.target;
          }
          trapped.value = true;
        }
      };
      const onFocusoutPrevented = (event) => {
        if (!props.trapping) {
          if (event.detail.focusReason === "pointer") {
            event.preventDefault();
          }
          trapped.value = false;
        }
      };
      const onReleaseRequested = () => {
        trapped.value = false;
        emit2("close");
      };
      return {
        focusStartRef,
        trapped,
        onFocusAfterReleased,
        onFocusAfterTrapped,
        onFocusInTrap,
        onFocusoutPrevented,
        onReleaseRequested
      };
    };
    const __default__$n = /* @__PURE__ */ defineComponent({
      name: "ElPopperContent"
    });
    const _sfc_main$B = /* @__PURE__ */ defineComponent({
      ...__default__$n,
      props: popperContentProps,
      emits: popperContentEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        } = usePopperContentFocusTrap(props, emit2);
        const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
        const {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          updateZIndex
        } = usePopperContentDOM(props, {
          styles,
          attributes,
          role
        });
        const formItemContext = inject(formItemContextKey, void 0);
        const arrowOffset = ref();
        provide(POPPER_CONTENT_INJECTION_KEY, {
          arrowStyle,
          arrowRef,
          arrowOffset
        });
        if (formItemContext) {
          provide(formItemContextKey, {
            ...formItemContext,
            addInputId: NOOP,
            removeInputId: NOOP
          });
        }
        let triggerTargetAriaStopWatch = void 0;
        const updatePopper = (shouldUpdateZIndex = true) => {
          update();
          shouldUpdateZIndex && updateZIndex();
        };
        const togglePopperAlive = () => {
          updatePopper(false);
          if (props.visible && props.focusOnShow) {
            trapped.value = true;
          } else if (props.visible === false) {
            trapped.value = false;
          }
        };
        onMounted(() => {
          watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
            const el = unref(triggerTargetEl || contentRef.value);
            const prevEl = unref(prevTriggerTargetEl || contentRef.value);
            if (isElement(el)) {
              triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (prevEl !== el && isElement(prevEl)) {
              ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                prevEl.removeAttribute(key);
              });
            }
          }, { immediate: true });
          watch(() => props.visible, togglePopperAlive, { immediate: true });
        });
        onBeforeUnmount(() => {
          triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
          triggerTargetAriaStopWatch = void 0;
        });
        expose({
          popperContentRef: contentRef,
          popperInstanceRef: instanceRef,
          updatePopper,
          contentStyle
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "contentRef",
            ref: contentRef
          }, unref(contentAttrs), {
            style: unref(contentStyle),
            class: unref(contentClass),
            tabindex: "-1",
            onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
            onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
          }), [
            createVNode(unref(ElFocusTrap), {
              trapped: unref(trapped),
              "trap-on-focus-in": true,
              "focus-trap-el": unref(contentRef),
              "focus-start-el": unref(focusStartRef),
              onFocusAfterTrapped: unref(onFocusAfterTrapped),
              onFocusAfterReleased: unref(onFocusAfterReleased),
              onFocusin: unref(onFocusInTrap),
              onFocusoutPrevented: unref(onFocusoutPrevented),
              onReleaseRequested: unref(onReleaseRequested)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
          ], 16);
        };
      }
    });
    var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "content.vue"]]);
    const ElPopper = withInstall(Popper);
    const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
    const useTooltipContentProps = buildProps({
      ...useDelayedToggleProps,
      ...popperContentProps,
      appendTo: {
        type: definePropType([String, Object])
      },
      content: {
        type: String,
        default: ""
      },
      rawContent: {
        type: Boolean,
        default: false
      },
      persistent: Boolean,
      visible: {
        type: definePropType(Boolean),
        default: null
      },
      transition: String,
      teleported: {
        type: Boolean,
        default: true
      },
      disabled: Boolean,
      ...useAriaProps(["ariaLabel"])
    });
    const useTooltipTriggerProps = buildProps({
      ...popperTriggerProps,
      disabled: Boolean,
      trigger: {
        type: definePropType([String, Array]),
        default: "hover"
      },
      triggerKeys: {
        type: definePropType(Array),
        default: () => [EVENT_CODE.enter, EVENT_CODE.space]
      }
    });
    const {
      useModelToggleProps: useTooltipModelToggleProps,
      useModelToggleEmits: useTooltipModelToggleEmits,
      useModelToggle: useTooltipModelToggle
    } = createModelToggleComposable("visible");
    const useTooltipProps = buildProps({
      ...popperProps,
      ...useTooltipModelToggleProps,
      ...useTooltipContentProps,
      ...useTooltipTriggerProps,
      ...popperArrowProps,
      showArrow: {
        type: Boolean,
        default: true
      }
    });
    const tooltipEmits = [
      ...useTooltipModelToggleEmits,
      "before-show",
      "before-hide",
      "show",
      "hide",
      "open",
      "close"
    ];
    const isTriggerType = (trigger2, type) => {
      if (isArray$2(trigger2)) {
        return trigger2.includes(type);
      }
      return trigger2 === type;
    };
    const whenTrigger = (trigger2, type, handler) => {
      return (e) => {
        isTriggerType(unref(trigger2), type) && handler(e);
      };
    };
    const __default__$m = /* @__PURE__ */ defineComponent({
      name: "ElTooltipTrigger"
    });
    const _sfc_main$A = /* @__PURE__ */ defineComponent({
      ...__default__$m,
      props: useTooltipTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("tooltip");
        const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef = ref(null);
        const stopWhenControlledOrDisabled = () => {
          if (unref(controlled) || props.disabled) {
            return true;
          }
        };
        const trigger2 = toRef(props, "trigger");
        const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
        const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
        const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
          if (e.button === 0) {
            onToggle(e);
          }
        }));
        const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
        const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
        const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
          e.preventDefault();
          onToggle(e);
        }));
        const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
          const { code } = e;
          if (props.triggerKeys.includes(code)) {
            e.preventDefault();
            onToggle(e);
          }
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopperTrigger), {
            id: unref(id),
            "virtual-ref": _ctx.virtualRef,
            open: unref(open),
            "virtual-triggering": _ctx.virtualTriggering,
            class: normalizeClass(unref(ns).e("trigger")),
            onBlur: unref(onBlur),
            onClick: unref(onClick),
            onContextmenu: unref(onContextMenu),
            onFocus: unref(onFocus),
            onMouseenter: unref(onMouseenter),
            onMouseleave: unref(onMouseleave),
            onKeydown: unref(onKeydown)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
        };
      }
    });
    var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "trigger.vue"]]);
    const __default__$l = /* @__PURE__ */ defineComponent({
      name: "ElTooltipContent",
      inheritAttrs: false
    });
    const _sfc_main$z = /* @__PURE__ */ defineComponent({
      ...__default__$l,
      props: useTooltipContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const { selector } = usePopperContainerId();
        const ns = useNamespace("tooltip");
        const contentRef = ref(null);
        const destroyed = ref(false);
        const {
          controlled,
          id,
          open,
          trigger: trigger2,
          onClose,
          onOpen,
          onShow,
          onHide,
          onBeforeShow,
          onBeforeHide
        } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const transitionClass = computed(() => {
          return props.transition || `${ns.namespace.value}-fade-in-linear`;
        });
        const persistentRef = computed(() => {
          return props.persistent;
        });
        onBeforeUnmount(() => {
          destroyed.value = true;
        });
        const shouldRender = computed(() => {
          return unref(persistentRef) ? true : unref(open);
        });
        const shouldShow = computed(() => {
          return props.disabled ? false : unref(open);
        });
        const appendTo = computed(() => {
          return props.appendTo || selector.value;
        });
        const contentStyle = computed(() => {
          var _a2;
          return (_a2 = props.style) != null ? _a2 : {};
        });
        const ariaHidden = computed(() => !unref(open));
        const onTransitionLeave = () => {
          onHide();
        };
        const stopWhenControlled = () => {
          if (unref(controlled))
            return true;
        };
        const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
          if (props.enterable && unref(trigger2) === "hover") {
            onOpen();
          }
        });
        const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
          if (unref(trigger2) === "hover") {
            onClose();
          }
        });
        const onBeforeEnter = () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          onBeforeShow == null ? void 0 : onBeforeShow();
        };
        const onBeforeLeave = () => {
          onBeforeHide == null ? void 0 : onBeforeHide();
        };
        const onAfterShow = () => {
          onShow();
          stopHandle = onClickOutside(computed(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          }), () => {
            if (unref(controlled))
              return;
            const $trigger = unref(trigger2);
            if ($trigger !== "hover") {
              onClose();
            }
          });
        };
        const onBlur = () => {
          if (!props.virtualTriggering) {
            onClose();
          }
        };
        let stopHandle;
        watch(() => unref(open), (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        }, {
          flush: "post"
        });
        watch(() => props.content, () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        expose({
          contentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            disabled: !_ctx.teleported,
            to: unref(appendTo)
          }, [
            createVNode(Transition, {
              name: unref(transitionClass),
              onAfterLeave: onTransitionLeave,
              onBeforeEnter,
              onAfterEnter: onAfterShow,
              onBeforeLeave
            }, {
              default: withCtx(() => [
                unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                  key: 0,
                  id: unref(id),
                  ref_key: "contentRef",
                  ref: contentRef
                }, _ctx.$attrs, {
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": unref(ariaHidden),
                  "boundaries-padding": _ctx.boundariesPadding,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  strategy: _ctx.strategy,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  pure: _ctx.pure,
                  "popper-class": _ctx.popperClass,
                  "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  visible: unref(shouldShow),
                  "z-index": _ctx.zIndex,
                  onMouseenter: unref(onContentEnter),
                  onMouseleave: unref(onContentLeave),
                  onBlur,
                  onClose: unref(onClose)
                }), {
                  default: withCtx(() => [
                    !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                  [vShow, unref(shouldShow)]
                ]) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["name"])
          ], 8, ["disabled", "to"]);
        };
      }
    });
    var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "content.vue"]]);
    const _hoisted_1$g = ["innerHTML"];
    const _hoisted_2$6 = { key: 1 };
    const __default__$k = /* @__PURE__ */ defineComponent({
      name: "ElTooltip"
    });
    const _sfc_main$y = /* @__PURE__ */ defineComponent({
      ...__default__$k,
      props: useTooltipProps,
      emits: tooltipEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        usePopperContainer();
        const id = useId();
        const popperRef = ref();
        const contentRef = ref();
        const updatePopper = () => {
          var _a2;
          const popperComponent = unref(popperRef);
          if (popperComponent) {
            (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
          }
        };
        const open = ref(false);
        const toggleReason = ref();
        const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
          indicator: open,
          toggleReason
        });
        const { onOpen, onClose } = useDelayedToggle({
          showAfter: toRef(props, "showAfter"),
          hideAfter: toRef(props, "hideAfter"),
          autoClose: toRef(props, "autoClose"),
          open: show,
          close: hide
        });
        const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
        provide(TOOLTIP_INJECTION_KEY, {
          controlled,
          id,
          open: readonly(open),
          trigger: toRef(props, "trigger"),
          onOpen: (event) => {
            onOpen(event);
          },
          onClose: (event) => {
            onClose(event);
          },
          onToggle: (event) => {
            if (unref(open)) {
              onClose(event);
            } else {
              onOpen(event);
            }
          },
          onShow: () => {
            emit2("show", toggleReason.value);
          },
          onHide: () => {
            emit2("hide", toggleReason.value);
          },
          onBeforeShow: () => {
            emit2("before-show", toggleReason.value);
          },
          onBeforeHide: () => {
            emit2("before-hide", toggleReason.value);
          },
          updatePopper
        });
        watch(() => props.disabled, (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        });
        const isFocusInsideContent = (event) => {
          var _a2, _b;
          const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
          const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
          return popperContent && popperContent.contains(activeElement);
        };
        onDeactivated(() => open.value && hide());
        expose({
          popperRef,
          contentRef,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose,
          hide
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopper), {
            ref_key: "popperRef",
            ref: popperRef,
            role: _ctx.role
          }, {
            default: withCtx(() => [
              createVNode(ElTooltipTrigger, {
                disabled: _ctx.disabled,
                trigger: _ctx.trigger,
                "trigger-keys": _ctx.triggerKeys,
                "virtual-ref": _ctx.virtualRef,
                "virtual-triggering": _ctx.virtualTriggering
              }, {
                default: withCtx(() => [
                  _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
              createVNode(ElTooltipContent, {
                ref_key: "contentRef",
                ref: contentRef,
                "aria-label": _ctx.ariaLabel,
                "boundaries-padding": _ctx.boundariesPadding,
                content: _ctx.content,
                disabled: _ctx.disabled,
                effect: _ctx.effect,
                enterable: _ctx.enterable,
                "fallback-placements": _ctx.fallbackPlacements,
                "hide-after": _ctx.hideAfter,
                "gpu-acceleration": _ctx.gpuAcceleration,
                offset: _ctx.offset,
                persistent: _ctx.persistent,
                "popper-class": _ctx.popperClass,
                "popper-style": _ctx.popperStyle,
                placement: _ctx.placement,
                "popper-options": _ctx.popperOptions,
                pure: _ctx.pure,
                "raw-content": _ctx.rawContent,
                "reference-el": _ctx.referenceEl,
                "trigger-target-el": _ctx.triggerTargetEl,
                "show-after": _ctx.showAfter,
                strategy: _ctx.strategy,
                teleported: _ctx.teleported,
                transition: _ctx.transition,
                "virtual-triggering": _ctx.virtualTriggering,
                "z-index": _ctx.zIndex,
                "append-to": _ctx.appendTo
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      innerHTML: _ctx.content
                    }, null, 8, _hoisted_1$g)) : (openBlock(), createElementBlock("span", _hoisted_2$6, toDisplayString(_ctx.content), 1))
                  ]),
                  _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                    key: 0,
                    "arrow-offset": _ctx.arrowOffset
                  }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
            ]),
            _: 3
          }, 8, ["role"]);
        };
      }
    });
    var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "tooltip.vue"]]);
    const ElTooltip = withInstall(Tooltip);
    const buttonGroupContextKey = Symbol("buttonGroupContextKey");
    const useButton = (props, emit2) => {
      useDeprecated({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
      }, computed(() => props.type === "text"));
      const buttonGroupContext = inject(buttonGroupContextKey, void 0);
      const globalConfig2 = useGlobalConfig("button");
      const { form } = useFormItem();
      const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
      const _disabled = useFormDisabled();
      const _ref = ref();
      const slots = useSlots();
      const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
      const autoInsertSpace = computed(() => {
        var _a2, _b, _c;
        return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
      });
      const _props = computed(() => {
        if (props.tag === "button") {
          return {
            ariaDisabled: _disabled.value || props.loading,
            disabled: _disabled.value || props.loading,
            autofocus: props.autofocus,
            type: props.nativeType
          };
        }
        return {};
      });
      const shouldAddSpace = computed(() => {
        var _a2;
        const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
          const slot = defaultSlot[0];
          if ((slot == null ? void 0 : slot.type) === Text) {
            const text = slot.children;
            return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
          }
        }
        return false;
      });
      const handleClick = (evt) => {
        if (props.nativeType === "reset") {
          form == null ? void 0 : form.resetFields();
        }
        emit2("click", evt);
      };
      return {
        _disabled,
        _size,
        _type,
        _ref,
        _props,
        shouldAddSpace,
        handleClick
      };
    };
    const buttonTypes = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      ""
    ];
    const buttonNativeTypes = ["button", "submit", "reset"];
    const buttonProps = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      type: {
        type: String,
        values: buttonTypes,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
      },
      loading: Boolean,
      loadingIcon: {
        type: iconPropType,
        default: () => loading_default
      },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: {
        type: Boolean,
        default: void 0
      },
      tag: {
        type: definePropType([String, Object]),
        default: "button"
      }
    });
    const buttonEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var isPercent = isPercentage(n);
      n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
      }
      if (Math.abs(n - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
      } else {
        n = n % max / parseFloat(String(max));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c) {
      return c.length === 1 ? "0" + c : String(c);
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var s = 0;
      var l = (max + min) / 2;
      if (max === min) {
        s = 0;
        h2 = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l };
    }
    function hue2rgb(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l) {
      var r;
      var g;
      var b;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      if (s === 0) {
        g = l;
        b = l;
        r = l;
      } else {
        var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p2 = 2 * l - q2;
        r = hue2rgb(p2, q2, h2 + 1 / 3);
        g = hue2rgb(p2, q2, h2);
        b = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v };
    }
    function hsvToRgb(h2, s, v) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i = Math.floor(h2);
      var f = h2 - i;
      var p2 = v * (1 - s);
      var q2 = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      var mod = i % 6;
      var r = [v, q2, p2, p2, t, v][mod];
      var g = [t, v, v, q2, p2, p2][mod];
      var b = [p2, p2, t, v, v, q2][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a2;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x) {
            return "".concat(Math.round(bound01(x, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x) {
            return Math.round(bound01(x, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v }));
            v = (v + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n;
          for (var i = 1; i < n; i++) {
            result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    function darken(color, amount = 20) {
      return color.mix("#141414", amount).toString();
    }
    function useButtonCustomStyle(props) {
      const _disabled = useFormDisabled();
      const ns = useNamespace("button");
      return computed(() => {
        let styles = {};
        let buttonColor = props.color;
        if (buttonColor) {
          const match = buttonColor.match(/var\((.*?)\)/);
          if (match) {
            buttonColor = window.getComputedStyle(window.document.documentElement).getPropertyValue(match[1]);
          }
          const color = new TinyColor(buttonColor);
          const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
          if (props.plain) {
            styles = ns.cssVarBlock({
              "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
              "text-color": buttonColor,
              "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
              "hover-text-color": `var(${ns.cssVarName("color-white")})`,
              "hover-bg-color": buttonColor,
              "hover-border-color": buttonColor,
              "active-bg-color": activeBgColor,
              "active-text-color": `var(${ns.cssVarName("color-white")})`,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
            }
          } else {
            const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
            const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
            styles = ns.cssVarBlock({
              "bg-color": buttonColor,
              "text-color": textColor,
              "border-color": buttonColor,
              "hover-bg-color": hoverBgColor,
              "hover-text-color": textColor,
              "hover-border-color": hoverBgColor,
              "active-bg-color": activeBgColor,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
              styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
            }
          }
        }
        return styles;
      });
    }
    const __default__$j = /* @__PURE__ */ defineComponent({
      name: "ElButton"
    });
    const _sfc_main$x = /* @__PURE__ */ defineComponent({
      ...__default__$j,
      props: buttonProps,
      emits: buttonEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const buttonStyle = useButtonCustomStyle(props);
        const ns = useNamespace("button");
        const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
        const buttonKls = computed(() => [
          ns.b(),
          ns.m(_type.value),
          ns.m(_size.value),
          ns.is("disabled", _disabled.value),
          ns.is("loading", props.loading),
          ns.is("plain", props.plain),
          ns.is("round", props.round),
          ns.is("circle", props.circle),
          ns.is("text", props.text),
          ns.is("link", props.link),
          ns.is("has-bg", props.bg)
        ]);
        expose({
          ref: _ref,
          size: _size,
          type: _type,
          disabled: _disabled,
          shouldAddSpace
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
            ref_key: "_ref",
            ref: _ref
          }, unref(_props), {
            class: unref(buttonKls),
            style: unref(buttonStyle),
            onClick: unref(handleClick)
          }), {
            default: withCtx(() => [
              _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                ]),
                _: 3
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["class", "style", "onClick"]);
        };
      }
    });
    var Button = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "button.vue"]]);
    const buttonGroupProps = {
      size: buttonProps.size,
      type: buttonProps.type
    };
    const __default__$i = /* @__PURE__ */ defineComponent({
      name: "ElButtonGroup"
    });
    const _sfc_main$w = /* @__PURE__ */ defineComponent({
      ...__default__$i,
      props: buttonGroupProps,
      setup(__props) {
        const props = __props;
        provide(buttonGroupContextKey, reactive({
          size: toRef(props, "size"),
          type: toRef(props, "type")
        }));
        const ns = useNamespace("button");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`${unref(ns).b("group")}`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "button-group.vue"]]);
    const ElButton = withInstall(Button, {
      ButtonGroup
    });
    const ElButtonGroup = withNoopInstall(ButtonGroup);
    const nodeList = /* @__PURE__ */ new Map();
    let startClick;
    if (isClient) {
      document.addEventListener("mousedown", (e) => startClick = e);
      document.addEventListener("mouseup", (e) => {
        for (const handlers of nodeList.values()) {
          for (const { documentHandler } of handlers) {
            documentHandler(e, startClick);
          }
        }
      });
    }
    function createDocumentHandler(el, binding) {
      let excludes = [];
      if (Array.isArray(binding.arg)) {
        excludes = binding.arg;
      } else if (isElement(binding.arg)) {
        excludes.push(binding.arg);
      }
      return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
          return;
        }
        binding.value(mouseup, mousedown);
      };
    }
    const ClickOutside = {
      beforeMount(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        nodeList.get(el).push({
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        });
      },
      updated(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        const handlers = nodeList.get(el);
        const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
        const newHandler = {
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) {
          handlers.splice(oldHandlerIndex, 1, newHandler);
        } else {
          handlers.push(newHandler);
        }
      },
      unmounted(el) {
        nodeList.delete(el);
      }
    };
    const REPEAT_INTERVAL = 100;
    const REPEAT_DELAY = 600;
    const vRepeatClick = {
      beforeMount(el, binding) {
        const value = binding.value;
        const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
        let intervalId;
        let delayId;
        const handler = () => isFunction$1(value) ? value() : value.handler();
        const clear = () => {
          if (delayId) {
            clearTimeout(delayId);
            delayId = void 0;
          }
          if (intervalId) {
            clearInterval(intervalId);
            intervalId = void 0;
          }
        };
        el.addEventListener("mousedown", (evt) => {
          if (evt.button !== 0)
            return;
          clear();
          handler();
          document.addEventListener("mouseup", () => clear(), {
            once: true
          });
          delayId = setTimeout(() => {
            intervalId = setInterval(() => {
              handler();
            }, interval);
          }, delay);
        });
      }
    };
    const radioPropsBase = buildProps({
      modelValue: {
        type: [String, Number, Boolean],
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      label: {
        type: [String, Number, Boolean],
        default: void 0
      },
      value: {
        type: [String, Number, Boolean],
        default: void 0
      },
      name: {
        type: String,
        default: void 0
      }
    });
    const radioProps = buildProps({
      ...radioPropsBase,
      border: Boolean
    });
    const radioEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
      [CHANGE_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
    };
    const radioGroupKey = Symbol("radioGroupKey");
    const useRadio = (props, emit2) => {
      const radioRef = ref();
      const radioGroup = inject(radioGroupKey, void 0);
      const isGroup = computed(() => !!radioGroup);
      const actualValue = computed(() => {
        if (!isPropAbsent(props.value)) {
          return props.value;
        }
        return props.label;
      });
      const modelValue = computed({
        get() {
          return isGroup.value ? radioGroup.modelValue : props.modelValue;
        },
        set(val) {
          if (isGroup.value) {
            radioGroup.changeEvent(val);
          } else {
            emit2 && emit2(UPDATE_MODEL_EVENT, val);
          }
          radioRef.value.checked = props.modelValue === actualValue.value;
        }
      });
      const size = useFormSize(computed(() => radioGroup == null ? void 0 : radioGroup.size));
      const disabled = useFormDisabled(computed(() => radioGroup == null ? void 0 : radioGroup.disabled));
      const focus = ref(false);
      const tabIndex = computed(() => {
        return disabled.value || isGroup.value && modelValue.value !== actualValue.value ? -1 : 0;
      });
      useDeprecated({
        from: "label act as value",
        replacement: "value",
        version: "3.0.0",
        scope: "el-radio",
        ref: "https://element-plus.org/en-US/component/radio.html"
      }, computed(() => isGroup.value && isPropAbsent(props.value)));
      return {
        radioRef,
        isGroup,
        radioGroup,
        focus,
        size,
        disabled,
        tabIndex,
        modelValue,
        actualValue
      };
    };
    const _hoisted_1$f = ["value", "name", "disabled"];
    const __default__$h = /* @__PURE__ */ defineComponent({
      name: "ElRadio"
    });
    const _sfc_main$v = /* @__PURE__ */ defineComponent({
      ...__default__$h,
      props: radioProps,
      emits: radioEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("radio");
        const { radioRef, radioGroup, focus, size, disabled, modelValue, actualValue } = useRadio(props, emit2);
        function handleChange() {
          nextTick(() => emit2("change", modelValue.value));
        }
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("label", {
            class: normalizeClass([
              unref(ns).b(),
              unref(ns).is("disabled", unref(disabled)),
              unref(ns).is("focus", unref(focus)),
              unref(ns).is("bordered", _ctx.border),
              unref(ns).is("checked", unref(modelValue) === unref(actualValue)),
              unref(ns).m(unref(size))
            ])
          }, [
            createBaseVNode("span", {
              class: normalizeClass([
                unref(ns).e("input"),
                unref(ns).is("disabled", unref(disabled)),
                unref(ns).is("checked", unref(modelValue) === unref(actualValue))
              ])
            }, [
              withDirectives(createBaseVNode("input", {
                ref_key: "radioRef",
                ref: radioRef,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
                class: normalizeClass(unref(ns).e("original")),
                value: unref(actualValue),
                name: _ctx.name || ((_a2 = unref(radioGroup)) == null ? void 0 : _a2.name),
                disabled: unref(disabled),
                type: "radio",
                onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
                onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false),
                onChange: handleChange,
                onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_1$f), [
                [vModelRadio, unref(modelValue)]
              ]),
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("inner"))
              }, null, 2)
            ], 2),
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).e("label")),
              onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ])
            ], 34)
          ], 2);
        };
      }
    });
    var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "radio.vue"]]);
    const radioButtonProps = buildProps({
      ...radioPropsBase
    });
    const _hoisted_1$e = ["value", "name", "disabled"];
    const __default__$g = /* @__PURE__ */ defineComponent({
      name: "ElRadioButton"
    });
    const _sfc_main$u = /* @__PURE__ */ defineComponent({
      ...__default__$g,
      props: radioButtonProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("radio");
        const { radioRef, focus, size, disabled, modelValue, radioGroup, actualValue } = useRadio(props);
        const activeStyle = computed(() => {
          return {
            backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
            borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
            boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
            color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
          };
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("label", {
            class: normalizeClass([
              unref(ns).b("button"),
              unref(ns).is("active", unref(modelValue) === unref(actualValue)),
              unref(ns).is("disabled", unref(disabled)),
              unref(ns).is("focus", unref(focus)),
              unref(ns).bm("button", unref(size))
            ])
          }, [
            withDirectives(createBaseVNode("input", {
              ref_key: "radioRef",
              ref: radioRef,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
              class: normalizeClass(unref(ns).be("button", "original-radio")),
              value: unref(actualValue),
              type: "radio",
              name: _ctx.name || ((_a2 = unref(radioGroup)) == null ? void 0 : _a2.name),
              disabled: unref(disabled),
              onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false),
              onClick: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_1$e), [
              [vModelRadio, unref(modelValue)]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).be("button", "inner")),
              style: normalizeStyle(unref(modelValue) === unref(actualValue) ? unref(activeStyle) : {}),
              onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ])
            ], 38)
          ], 2);
        };
      }
    });
    var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "radio-button.vue"]]);
    const radioGroupProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: [String, Number, Boolean],
        default: void 0
      },
      fill: {
        type: String,
        default: ""
      },
      label: {
        type: String,
        default: void 0
      },
      textColor: {
        type: String,
        default: ""
      },
      name: {
        type: String,
        default: void 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      ...useAriaProps(["ariaLabel"])
    });
    const radioGroupEmits = radioEmits;
    const _hoisted_1$d = ["id", "aria-label", "aria-labelledby"];
    const __default__$f = /* @__PURE__ */ defineComponent({
      name: "ElRadioGroup"
    });
    const _sfc_main$t = /* @__PURE__ */ defineComponent({
      ...__default__$f,
      props: radioGroupProps,
      emits: radioGroupEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("radio");
        const radioId = useId();
        const radioGroupRef = ref();
        const { formItem } = useFormItem();
        const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const changeEvent = (value) => {
          emit2(UPDATE_MODEL_EVENT, value);
          nextTick(() => emit2("change", value));
        };
        onMounted(() => {
          const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
          const firstLabel = radios[0];
          if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
            firstLabel.tabIndex = 0;
          }
        });
        const name = computed(() => {
          return props.name || radioId.value;
        });
        provide(radioGroupKey, reactive({
          ...toRefs(props),
          changeEvent,
          name
        }));
        watch(() => props.modelValue, () => {
          if (props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        useDeprecated({
          from: "label",
          replacement: "aria-label",
          version: "2.8.0",
          scope: "el-radio-group",
          ref: "https://element-plus.org/en-US/component/radio.html"
        }, computed(() => !!props.label));
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            id: unref(groupId),
            ref_key: "radioGroupRef",
            ref: radioGroupRef,
            class: normalizeClass(unref(ns).b("group")),
            role: "radiogroup",
            "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || _ctx.ariaLabel || "radio-group" : void 0,
            "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 10, _hoisted_1$d);
        };
      }
    });
    var RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "radio-group.vue"]]);
    const ElRadio = withInstall(Radio, {
      RadioButton,
      RadioGroup
    });
    const ElRadioGroup = withNoopInstall(RadioGroup);
    withNoopInstall(RadioButton);
    const tagProps = buildProps({
      type: {
        type: String,
        values: ["primary", "success", "info", "warning", "danger"],
        default: "primary"
      },
      closable: Boolean,
      disableTransitions: Boolean,
      hit: Boolean,
      color: String,
      size: {
        type: String,
        values: componentSizes
      },
      effect: {
        type: String,
        values: ["dark", "light", "plain"],
        default: "light"
      },
      round: Boolean
    });
    const tagEmits = {
      close: (evt) => evt instanceof MouseEvent,
      click: (evt) => evt instanceof MouseEvent
    };
    const __default__$e = /* @__PURE__ */ defineComponent({
      name: "ElTag"
    });
    const _sfc_main$s = /* @__PURE__ */ defineComponent({
      ...__default__$e,
      props: tagProps,
      emits: tagEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const tagSize = useFormSize();
        const ns = useNamespace("tag");
        const containerKls = computed(() => {
          const { type, hit, effect, closable, round } = props;
          return [
            ns.b(),
            ns.is("closable", closable),
            ns.m(type || "primary"),
            ns.m(tagSize.value),
            ns.m(effect),
            ns.is("hit", hit),
            ns.is("round", round)
          ];
        });
        const handleClose = (event) => {
          emit2("close", event);
        };
        const handleClick = (event) => {
          emit2("click", event);
        };
        return (_ctx, _cache) => {
          return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(containerKls)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)) : (openBlock(), createBlock(Transition, {
            key: 1,
            name: `${unref(ns).namespace.value}-zoom-in-center`,
            appear: ""
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(containerKls)),
                style: normalizeStyle({ backgroundColor: _ctx.color }),
                onClick: handleClick
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).e("close")),
                  onClick: withModifiers(handleClose, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 6)
            ]),
            _: 3
          }, 8, ["name"]));
        };
      }
    });
    var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "tag.vue"]]);
    const ElTag = withInstall(Tag);
    const rowContextKey = Symbol("rowContextKey");
    const RowJustify = [
      "start",
      "center",
      "end",
      "space-around",
      "space-between",
      "space-evenly"
    ];
    const RowAlign = ["top", "middle", "bottom"];
    const rowProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      gutter: {
        type: Number,
        default: 0
      },
      justify: {
        type: String,
        values: RowJustify,
        default: "start"
      },
      align: {
        type: String,
        values: RowAlign
      }
    });
    const __default__$d = /* @__PURE__ */ defineComponent({
      name: "ElRow"
    });
    const _sfc_main$r = /* @__PURE__ */ defineComponent({
      ...__default__$d,
      props: rowProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("row");
        const gutter = computed(() => props.gutter);
        provide(rowContextKey, {
          gutter
        });
        const style = computed(() => {
          const styles = {};
          if (!props.gutter) {
            return styles;
          }
          styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
          return styles;
        });
        const rowKls = computed(() => [
          ns.b(),
          ns.is(`justify-${props.justify}`, props.justify !== "start"),
          ns.is(`align-${props.align}`, !!props.align)
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass(unref(rowKls)),
            style: normalizeStyle(unref(style))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    });
    var Row = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "row.vue"]]);
    const ElRow = withInstall(Row);
    const colProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      span: {
        type: Number,
        default: 24
      },
      offset: {
        type: Number,
        default: 0
      },
      pull: {
        type: Number,
        default: 0
      },
      push: {
        type: Number,
        default: 0
      },
      xs: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      sm: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      md: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      lg: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      xl: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      }
    });
    const __default__$c = /* @__PURE__ */ defineComponent({
      name: "ElCol"
    });
    const _sfc_main$q = /* @__PURE__ */ defineComponent({
      ...__default__$c,
      props: colProps,
      setup(__props) {
        const props = __props;
        const { gutter } = inject(rowContextKey, { gutter: computed(() => 0) });
        const ns = useNamespace("col");
        const style = computed(() => {
          const styles = {};
          if (gutter.value) {
            styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
          }
          return styles;
        });
        const colKls = computed(() => {
          const classes = [];
          const pos = ["span", "offset", "pull", "push"];
          pos.forEach((prop) => {
            const size = props[prop];
            if (isNumber(size)) {
              if (prop === "span")
                classes.push(ns.b(`${props[prop]}`));
              else if (size > 0)
                classes.push(ns.b(`${prop}-${props[prop]}`));
            }
          });
          const sizes = ["xs", "sm", "md", "lg", "xl"];
          sizes.forEach((size) => {
            if (isNumber(props[size])) {
              classes.push(ns.b(`${size}-${props[size]}`));
            } else if (isObject$1(props[size])) {
              Object.entries(props[size]).forEach(([prop, sizeProp]) => {
                classes.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProp}`) : ns.b(`${size}-${sizeProp}`));
              });
            }
          });
          if (gutter.value) {
            classes.push(ns.is("guttered"));
          }
          return [ns.b(), classes];
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass(unref(colKls)),
            style: normalizeStyle(unref(style))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    });
    var Col = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "col.vue"]]);
    const ElCol = withInstall(Col);
    const __default__$b = /* @__PURE__ */ defineComponent({
      name: "ElContainer"
    });
    const _sfc_main$p = /* @__PURE__ */ defineComponent({
      ...__default__$b,
      props: {
        direction: {
          type: String
        }
      },
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const ns = useNamespace("container");
        const isVertical = computed(() => {
          if (props.direction === "vertical") {
            return true;
          } else if (props.direction === "horizontal") {
            return false;
          }
          if (slots && slots.default) {
            const vNodes = slots.default();
            return vNodes.some((vNode) => {
              const tag = vNode.type.name;
              return tag === "ElHeader" || tag === "ElFooter";
            });
          } else {
            return false;
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("section", {
            class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Container = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "container.vue"]]);
    const __default__$a = /* @__PURE__ */ defineComponent({
      name: "ElAside"
    });
    const _sfc_main$o = /* @__PURE__ */ defineComponent({
      ...__default__$a,
      props: {
        width: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("aside");
        const style = computed(() => props.width ? ns.cssVarBlock({ width: props.width }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("aside", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Aside = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "aside.vue"]]);
    const __default__$9 = /* @__PURE__ */ defineComponent({
      name: "ElFooter"
    });
    const _sfc_main$n = /* @__PURE__ */ defineComponent({
      ...__default__$9,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("footer");
        const style = computed(() => props.height ? ns.cssVarBlock({ height: props.height }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("footer", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Footer = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "footer.vue"]]);
    const __default__$8 = /* @__PURE__ */ defineComponent({
      name: "ElHeader"
    });
    const _sfc_main$m = /* @__PURE__ */ defineComponent({
      ...__default__$8,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("header");
        const style = computed(() => {
          return props.height ? ns.cssVarBlock({
            height: props.height
          }) : {};
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("header", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Header = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "header.vue"]]);
    const __default__$7 = /* @__PURE__ */ defineComponent({
      name: "ElMain"
    });
    const _sfc_main$l = /* @__PURE__ */ defineComponent({
      ...__default__$7,
      setup(__props) {
        const ns = useNamespace("main");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("main", {
            class: normalizeClass(unref(ns).b())
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Main = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "main.vue"]]);
    const ElContainer = withInstall(Container, {
      Aside,
      Footer,
      Header,
      Main
    });
    withNoopInstall(Aside);
    const ElFooter = withNoopInstall(Footer);
    const ElHeader = withNoopInstall(Header);
    const ElMain = withNoopInstall(Main);
    const overlayProps = buildProps({
      mask: {
        type: Boolean,
        default: true
      },
      customMaskEvent: {
        type: Boolean,
        default: false
      },
      overlayClass: {
        type: definePropType([
          String,
          Array,
          Object
        ])
      },
      zIndex: {
        type: definePropType([String, Number])
      }
    });
    const overlayEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const BLOCK = "overlay";
    var Overlay = /* @__PURE__ */ defineComponent({
      name: "ElOverlay",
      props: overlayProps,
      emits: overlayEmits,
      setup(props, { slots, emit: emit2 }) {
        const ns = useNamespace(BLOCK);
        const onMaskClick = (e) => {
          emit2("click", e);
        };
        const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
        return () => {
          return props.mask ? createVNode("div", {
            class: [ns.b(), props.overlayClass],
            style: {
              zIndex: props.zIndex
            },
            onClick,
            onMousedown,
            onMouseup
          }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
            class: props.overlayClass,
            style: {
              zIndex: props.zIndex,
              position: "fixed",
              top: "0px",
              right: "0px",
              bottom: "0px",
              left: "0px"
            }
          }, [renderSlot(slots, "default")]);
        };
      }
    });
    const ElOverlay = Overlay;
    const dialogInjectionKey = Symbol("dialogInjectionKey");
    const dialogContentProps = buildProps({
      center: Boolean,
      alignCenter: Boolean,
      closeIcon: {
        type: iconPropType
      },
      draggable: Boolean,
      overflow: Boolean,
      fullscreen: Boolean,
      showClose: {
        type: Boolean,
        default: true
      },
      title: {
        type: String,
        default: ""
      },
      ariaLevel: {
        type: String,
        default: "2"
      }
    });
    const dialogContentEmits = {
      close: () => true
    };
    const _hoisted_1$c = ["aria-level"];
    const _hoisted_2$5 = ["aria-label"];
    const _hoisted_3$3 = ["id"];
    const __default__$6 = /* @__PURE__ */ defineComponent({ name: "ElDialogContent" });
    const _sfc_main$k = /* @__PURE__ */ defineComponent({
      ...__default__$6,
      props: dialogContentProps,
      emits: dialogContentEmits,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const { Close } = CloseComponents;
        const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
        const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
        const dialogKls = computed(() => [
          ns.b(),
          ns.is("fullscreen", props.fullscreen),
          ns.is("draggable", props.draggable),
          ns.is("align-center", props.alignCenter),
          { [ns.m("center")]: props.center }
        ]);
        const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
        const draggable = computed(() => props.draggable);
        const overflow = computed(() => props.overflow);
        useDraggable(dialogRef, headerRef, draggable, overflow);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref: unref(composedDialogRef),
            class: normalizeClass(unref(dialogKls)),
            style: normalizeStyle(unref(style)),
            tabindex: "-1"
          }, [
            createBaseVNode("header", {
              ref_key: "headerRef",
              ref: headerRef,
              class: normalizeClass([unref(ns).e("header"), { "show-close": _ctx.showClose }])
            }, [
              renderSlot(_ctx.$slots, "header", {}, () => [
                createBaseVNode("span", {
                  role: "heading",
                  "aria-level": _ctx.ariaLevel,
                  class: normalizeClass(unref(ns).e("title"))
                }, toDisplayString(_ctx.title), 11, _hoisted_1$c)
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("button", {
                key: 0,
                "aria-label": unref(t)("el.dialog.close"),
                class: normalizeClass(unref(ns).e("headerbtn")),
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, [
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(ns).e("close"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, _hoisted_2$5)) : createCommentVNode("v-if", true)
            ], 2),
            createBaseVNode("div", {
              id: unref(bodyId),
              class: normalizeClass(unref(ns).e("body"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_3$3),
            _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
              key: 0,
              class: normalizeClass(unref(ns).e("footer"))
            }, [
              renderSlot(_ctx.$slots, "footer")
            ], 2)) : createCommentVNode("v-if", true)
          ], 6);
        };
      }
    });
    var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "dialog-content.vue"]]);
    const dialogProps = buildProps({
      ...dialogContentProps,
      appendToBody: Boolean,
      appendTo: {
        type: definePropType(String),
        default: "body"
      },
      beforeClose: {
        type: definePropType(Function)
      },
      destroyOnClose: Boolean,
      closeOnClickModal: {
        type: Boolean,
        default: true
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      lockScroll: {
        type: Boolean,
        default: true
      },
      modal: {
        type: Boolean,
        default: true
      },
      openDelay: {
        type: Number,
        default: 0
      },
      closeDelay: {
        type: Number,
        default: 0
      },
      top: {
        type: String
      },
      modelValue: Boolean,
      modalClass: String,
      width: {
        type: [String, Number]
      },
      zIndex: {
        type: Number
      },
      trapFocus: {
        type: Boolean,
        default: false
      },
      headerAriaLevel: {
        type: String,
        default: "2"
      }
    });
    const dialogEmits = {
      open: () => true,
      opened: () => true,
      close: () => true,
      closed: () => true,
      [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
      openAutoFocus: () => true,
      closeAutoFocus: () => true
    };
    const useDialog = (props, targetRef) => {
      var _a2;
      const instance = getCurrentInstance();
      const emit2 = instance.emit;
      const { nextZIndex } = useZIndex();
      let lastPosition = "";
      const titleId = useId();
      const bodyId = useId();
      const visible = ref(false);
      const closed = ref(false);
      const rendered = ref(false);
      const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
      let openTimer = void 0;
      let closeTimer = void 0;
      const namespace = useGlobalConfig("namespace", defaultNamespace);
      const style = computed(() => {
        const style2 = {};
        const varPrefix = `--${namespace.value}-dialog`;
        if (!props.fullscreen) {
          if (props.top) {
            style2[`${varPrefix}-margin-top`] = props.top;
          }
          if (props.width) {
            style2[`${varPrefix}-width`] = addUnit(props.width);
          }
        }
        return style2;
      });
      const overlayDialogStyle = computed(() => {
        if (props.alignCenter) {
          return { display: "flex" };
        }
        return {};
      });
      function afterEnter() {
        emit2("opened");
      }
      function afterLeave() {
        emit2("closed");
        emit2(UPDATE_MODEL_EVENT, false);
        if (props.destroyOnClose) {
          rendered.value = false;
        }
      }
      function beforeLeave() {
        emit2("close");
      }
      function open() {
        closeTimer == null ? void 0 : closeTimer();
        openTimer == null ? void 0 : openTimer();
        if (props.openDelay && props.openDelay > 0) {
          ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
        } else {
          doOpen();
        }
      }
      function close() {
        openTimer == null ? void 0 : openTimer();
        closeTimer == null ? void 0 : closeTimer();
        if (props.closeDelay && props.closeDelay > 0) {
          ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
        } else {
          doClose();
        }
      }
      function handleClose() {
        function hide(shouldCancel) {
          if (shouldCancel)
            return;
          closed.value = true;
          visible.value = false;
        }
        if (props.beforeClose) {
          props.beforeClose(hide);
        } else {
          close();
        }
      }
      function onModalClick() {
        if (props.closeOnClickModal) {
          handleClose();
        }
      }
      function doOpen() {
        if (!isClient)
          return;
        visible.value = true;
      }
      function doClose() {
        visible.value = false;
      }
      function onOpenAutoFocus() {
        emit2("openAutoFocus");
      }
      function onCloseAutoFocus() {
        emit2("closeAutoFocus");
      }
      function onFocusoutPrevented(event) {
        var _a22;
        if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
          event.preventDefault();
        }
      }
      if (props.lockScroll) {
        useLockscreen(visible);
      }
      function onCloseRequested() {
        if (props.closeOnPressEscape) {
          handleClose();
        }
      }
      watch(() => props.modelValue, (val) => {
        if (val) {
          closed.value = false;
          open();
          rendered.value = true;
          zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
          nextTick(() => {
            emit2("open");
            if (targetRef.value) {
              targetRef.value.scrollTop = 0;
            }
          });
        } else {
          if (visible.value) {
            close();
          }
        }
      });
      watch(() => props.fullscreen, (val) => {
        if (!targetRef.value)
          return;
        if (val) {
          lastPosition = targetRef.value.style.transform;
          targetRef.value.style.transform = "";
        } else {
          targetRef.value.style.transform = lastPosition;
        }
      });
      onMounted(() => {
        if (props.modelValue) {
          visible.value = true;
          rendered.value = true;
          open();
        }
      });
      return {
        afterEnter,
        afterLeave,
        beforeLeave,
        handleClose,
        onModalClick,
        close,
        doClose,
        onOpenAutoFocus,
        onCloseAutoFocus,
        onCloseRequested,
        onFocusoutPrevented,
        titleId,
        bodyId,
        closed,
        style,
        overlayDialogStyle,
        rendered,
        visible,
        zIndex: zIndex2
      };
    };
    const _hoisted_1$b = ["aria-label", "aria-labelledby", "aria-describedby"];
    const __default__$5 = /* @__PURE__ */ defineComponent({
      name: "ElDialog",
      inheritAttrs: false
    });
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      ...__default__$5,
      props: dialogProps,
      emits: dialogEmits,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        useDeprecated({
          scope: "el-dialog",
          from: "the title slot",
          replacement: "the header slot",
          version: "3.0.0",
          ref: "https://element-plus.org/en-US/component/dialog.html#slots"
        }, computed(() => !!slots.title));
        const ns = useNamespace("dialog");
        const dialogRef = ref();
        const headerRef = ref();
        const dialogContentRef = ref();
        const {
          visible,
          titleId,
          bodyId,
          style,
          overlayDialogStyle,
          rendered,
          zIndex: zIndex2,
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented
        } = useDialog(props, dialogRef);
        provide(dialogInjectionKey, {
          dialogRef,
          headerRef,
          bodyId,
          ns,
          rendered,
          style
        });
        const overlayEvent = useSameTarget(onModalClick);
        const draggable = computed(() => props.draggable && !props.fullscreen);
        expose({
          visible,
          dialogContentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            to: _ctx.appendTo,
            disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
          }, [
            createVNode(Transition, {
              name: "dialog-fade",
              onAfterEnter: unref(afterEnter),
              onAfterLeave: unref(afterLeave),
              onBeforeLeave: unref(beforeLeave),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createVNode(unref(ElOverlay), {
                  "custom-mask-event": "",
                  mask: _ctx.modal,
                  "overlay-class": _ctx.modalClass,
                  "z-index": unref(zIndex2)
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-label": _ctx.title || void 0,
                      "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                      "aria-describedby": unref(bodyId),
                      class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                      style: normalizeStyle(unref(overlayDialogStyle)),
                      onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                      onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                      onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                    }, [
                      createVNode(unref(ElFocusTrap), {
                        loop: "",
                        trapped: unref(visible),
                        "focus-start-el": "container",
                        onFocusAfterTrapped: unref(onOpenAutoFocus),
                        onFocusAfterReleased: unref(onCloseAutoFocus),
                        onFocusoutPrevented: unref(onFocusoutPrevented),
                        onReleaseRequested: unref(onCloseRequested)
                      }, {
                        default: withCtx(() => [
                          unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                            key: 0,
                            ref_key: "dialogContentRef",
                            ref: dialogContentRef
                          }, _ctx.$attrs, {
                            center: _ctx.center,
                            "align-center": _ctx.alignCenter,
                            "close-icon": _ctx.closeIcon,
                            draggable: unref(draggable),
                            overflow: _ctx.overflow,
                            fullscreen: _ctx.fullscreen,
                            "show-close": _ctx.showClose,
                            title: _ctx.title,
                            "aria-level": _ctx.headerAriaLevel,
                            onClose: unref(handleClose)
                          }), createSlots({
                            header: withCtx(() => [
                              !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                key: 0,
                                close: unref(handleClose),
                                titleId: unref(titleId),
                                titleClass: unref(ns).e("title")
                              }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                            ]),
                            default: withCtx(() => [
                              renderSlot(_ctx.$slots, "default")
                            ]),
                            _: 2
                          }, [
                            _ctx.$slots.footer ? {
                              name: "footer",
                              fn: withCtx(() => [
                                renderSlot(_ctx.$slots, "footer")
                              ])
                            } : void 0
                          ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                        ]),
                        _: 3
                      }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                    ], 46, _hoisted_1$b)
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index"]), [
                  [vShow, unref(visible)]
                ])
              ]),
              _: 3
            }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
          ], 8, ["to", "disabled"]);
        };
      }
    });
    var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "dialog.vue"]]);
    const ElDialog = withInstall(Dialog);
    const inputNumberProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      step: {
        type: Number,
        default: 1
      },
      stepStrictly: Boolean,
      max: {
        type: Number,
        default: Number.POSITIVE_INFINITY
      },
      min: {
        type: Number,
        default: Number.NEGATIVE_INFINITY
      },
      modelValue: Number,
      readonly: Boolean,
      disabled: Boolean,
      size: useSizeProp,
      controls: {
        type: Boolean,
        default: true
      },
      controlsPosition: {
        type: String,
        default: "",
        values: ["", "right"]
      },
      valueOnClear: {
        type: [String, Number, null],
        validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
        default: null
      },
      name: String,
      label: String,
      placeholder: String,
      precision: {
        type: Number,
        validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      ...useAriaProps(["ariaLabel"])
    });
    const inputNumberEmits = {
      [CHANGE_EVENT]: (cur, prev) => prev !== cur,
      blur: (e) => e instanceof FocusEvent,
      focus: (e) => e instanceof FocusEvent,
      [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
      [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
    };
    const _hoisted_1$a = ["aria-label", "onKeydown"];
    const _hoisted_2$4 = ["aria-label", "onKeydown"];
    const __default__$4 = /* @__PURE__ */ defineComponent({
      name: "ElInputNumber"
    });
    const _sfc_main$i = /* @__PURE__ */ defineComponent({
      ...__default__$4,
      props: inputNumberProps,
      emits: inputNumberEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const { t } = useLocale();
        const ns = useNamespace("input-number");
        const input = ref();
        const data = reactive({
          currentValue: props.modelValue,
          userInput: null
        });
        const { formItem } = useFormItem();
        const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
        const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
        const numPrecision = computed(() => {
          const stepPrecision = getPrecision(props.step);
          if (!isUndefined(props.precision)) {
            if (stepPrecision > props.precision) ;
            return props.precision;
          } else {
            return Math.max(getPrecision(props.modelValue), stepPrecision);
          }
        });
        const controlsAtRight = computed(() => {
          return props.controls && props.controlsPosition === "right";
        });
        const inputNumberSize = useFormSize();
        const inputNumberDisabled = useFormDisabled();
        const displayValue = computed(() => {
          if (data.userInput !== null) {
            return data.userInput;
          }
          let currentValue = data.currentValue;
          if (isNil(currentValue))
            return "";
          if (isNumber(currentValue)) {
            if (Number.isNaN(currentValue))
              return "";
            if (!isUndefined(props.precision)) {
              currentValue = currentValue.toFixed(props.precision);
            }
          }
          return currentValue;
        });
        const toPrecision = (num, pre) => {
          if (isUndefined(pre))
            pre = numPrecision.value;
          if (pre === 0)
            return Math.round(num);
          let snum = String(num);
          const pointPos = snum.indexOf(".");
          if (pointPos === -1)
            return num;
          const nums = snum.replace(".", "").split("");
          const datum = nums[pointPos + pre];
          if (!datum)
            return num;
          const length = snum.length;
          if (snum.charAt(length - 1) === "5") {
            snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
          }
          return Number.parseFloat(Number(snum).toFixed(pre));
        };
        const getPrecision = (value) => {
          if (isNil(value))
            return 0;
          const valueString = value.toString();
          const dotPosition = valueString.indexOf(".");
          let precision = 0;
          if (dotPosition !== -1) {
            precision = valueString.length - dotPosition - 1;
          }
          return precision;
        };
        const ensurePrecision = (val, coefficient = 1) => {
          if (!isNumber(val))
            return data.currentValue;
          return toPrecision(val + props.step * coefficient);
        };
        const increase = () => {
          if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
            return;
          const value = Number(displayValue.value) || 0;
          const newVal = ensurePrecision(value);
          setCurrentValue(newVal);
          emit2(INPUT_EVENT, data.currentValue);
          setCurrentValueToModelValue();
        };
        const decrease = () => {
          if (props.readonly || inputNumberDisabled.value || minDisabled.value)
            return;
          const value = Number(displayValue.value) || 0;
          const newVal = ensurePrecision(value, -1);
          setCurrentValue(newVal);
          emit2(INPUT_EVENT, data.currentValue);
          setCurrentValueToModelValue();
        };
        const verifyValue = (value, update) => {
          const { max, min, step, precision, stepStrictly, valueOnClear } = props;
          if (max < min) {
            throwError("InputNumber", "min should not be greater than max.");
          }
          let newVal = Number(value);
          if (isNil(value) || Number.isNaN(newVal)) {
            return null;
          }
          if (value === "") {
            if (valueOnClear === null) {
              return null;
            }
            newVal = isString$1(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
          }
          if (stepStrictly) {
            newVal = toPrecision(Math.round(newVal / step) * step, precision);
          }
          if (!isUndefined(precision)) {
            newVal = toPrecision(newVal, precision);
          }
          if (newVal > max || newVal < min) {
            newVal = newVal > max ? max : min;
            update && emit2(UPDATE_MODEL_EVENT, newVal);
          }
          return newVal;
        };
        const setCurrentValue = (value, emitChange = true) => {
          var _a2;
          const oldVal = data.currentValue;
          const newVal = verifyValue(value);
          if (!emitChange) {
            emit2(UPDATE_MODEL_EVENT, newVal);
            return;
          }
          if (oldVal === newVal && value)
            return;
          data.userInput = null;
          emit2(UPDATE_MODEL_EVENT, newVal);
          if (oldVal !== newVal) {
            emit2(CHANGE_EVENT, newVal, oldVal);
          }
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
          data.currentValue = newVal;
        };
        const handleInput = (value) => {
          data.userInput = value;
          const newVal = value === "" ? null : Number(value);
          emit2(INPUT_EVENT, newVal);
          setCurrentValue(newVal, false);
        };
        const handleInputChange = (value) => {
          const newVal = value !== "" ? Number(value) : "";
          if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
            setCurrentValue(newVal);
          }
          setCurrentValueToModelValue();
          data.userInput = null;
        };
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        const blur = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
        };
        const handleFocus = (event) => {
          emit2("focus", event);
        };
        const handleBlur = (event) => {
          var _a2;
          data.userInput = null;
          emit2("blur", event);
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
          }
        };
        const setCurrentValueToModelValue = () => {
          if (data.currentValue !== props.modelValue) {
            data.currentValue = props.modelValue;
          }
        };
        const handleWheel = (e) => {
          if (document.activeElement === e.target)
            e.preventDefault();
        };
        watch(() => props.modelValue, (value, oldValue) => {
          const newValue = verifyValue(value, true);
          if (data.userInput === null && newValue !== oldValue) {
            data.currentValue = newValue;
          }
        }, { immediate: true });
        onMounted(() => {
          var _a2;
          const { min, max, modelValue } = props;
          const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
          innerInput.setAttribute("role", "spinbutton");
          if (Number.isFinite(max)) {
            innerInput.setAttribute("aria-valuemax", String(max));
          } else {
            innerInput.removeAttribute("aria-valuemax");
          }
          if (Number.isFinite(min)) {
            innerInput.setAttribute("aria-valuemin", String(min));
          } else {
            innerInput.removeAttribute("aria-valuemin");
          }
          innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
          innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
          if (!isNumber(modelValue) && modelValue != null) {
            let val = Number(modelValue);
            if (Number.isNaN(val)) {
              val = null;
            }
            emit2(UPDATE_MODEL_EVENT, val);
          }
          innerInput.addEventListener("wheel", handleWheel, { passive: false });
        });
        onUpdated(() => {
          var _a2, _b;
          const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
          innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
        });
        useDeprecated({
          from: "label",
          replacement: "aria-label",
          version: "2.8.0",
          scope: "el-input-number",
          ref: "https://element-plus.org/en-US/component/input-number.html"
        }, computed(() => !!props.label));
        expose({
          focus,
          blur
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns).b(),
              unref(ns).m(unref(inputNumberSize)),
              unref(ns).is("disabled", unref(inputNumberDisabled)),
              unref(ns).is("without-controls", !_ctx.controls),
              unref(ns).is("controls-right", unref(controlsAtRight))
            ]),
            onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
              key: 0,
              role: "button",
              "aria-label": unref(t)("el.inputNumber.decrease"),
              class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
              onKeydown: withKeys(decrease, ["enter"])
            }, [
              renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ])
            ], 42, _hoisted_1$a)), [
              [unref(vRepeatClick), decrease]
            ]) : createCommentVNode("v-if", true),
            _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
              key: 1,
              role: "button",
              "aria-label": unref(t)("el.inputNumber.increase"),
              class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
              onKeydown: withKeys(increase, ["enter"])
            }, [
              renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                  ]),
                  _: 1
                })
              ])
            ], 42, _hoisted_2$4)), [
              [unref(vRepeatClick), increase]
            ]) : createCommentVNode("v-if", true),
            createVNode(unref(ElInput), {
              id: _ctx.id,
              ref_key: "input",
              ref: input,
              type: "number",
              step: _ctx.step,
              "model-value": unref(displayValue),
              placeholder: _ctx.placeholder,
              readonly: _ctx.readonly,
              disabled: unref(inputNumberDisabled),
              size: unref(inputNumberSize),
              max: _ctx.max,
              min: _ctx.min,
              name: _ctx.name,
              "aria-label": _ctx.label || _ctx.ariaLabel,
              "validate-event": false,
              onKeydown: [
                withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                withKeys(withModifiers(decrease, ["prevent"]), ["down"])
              ],
              onBlur: handleBlur,
              onFocus: handleFocus,
              onInput: handleInput,
              onChange: handleInputChange
            }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
          ], 34);
        };
      }
    });
    var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "input-number.vue"]]);
    const ElInputNumber = withInstall(InputNumber);
    const selectGroupKey = Symbol("ElSelectGroup");
    const selectKey = Symbol("ElSelect");
    function useOption(props, states) {
      const select = inject(selectKey);
      const selectGroup = inject(selectGroupKey, { disabled: false });
      const itemSelected = computed(() => {
        if (select.props.multiple) {
          return contains(select.props.modelValue, props.value);
        } else {
          return contains([select.props.modelValue], props.value);
        }
      });
      const limitReached = computed(() => {
        if (select.props.multiple) {
          const modelValue = select.props.modelValue || [];
          return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
        } else {
          return false;
        }
      });
      const currentLabel = computed(() => {
        return props.label || (isObject$1(props.value) ? "" : props.value);
      });
      const currentValue = computed(() => {
        return props.value || props.label || "";
      });
      const isDisabled = computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const instance = getCurrentInstance();
      const contains = (arr = [], target) => {
        if (!isObject$1(props.value)) {
          return arr && arr.includes(target);
        } else {
          const valueKey = select.props.valueKey;
          return arr && arr.some((item) => {
            return toRaw(get(item, valueKey)) === get(target, valueKey);
          });
        }
      };
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
        }
      };
      const updateOption = (query) => {
        const regexp = new RegExp(escapeStringRegexp(query), "i");
        states.visible = regexp.test(currentLabel.value) || props.created;
      };
      watch(() => currentLabel.value, () => {
        if (!props.created && !select.props.remote)
          select.setSelected();
      });
      watch(() => props.value, (val, oldVal) => {
        const { remote, valueKey } = select.props;
        if (!isEqual(val, oldVal)) {
          select.onOptionDestroy(oldVal, instance.proxy);
          select.onOptionCreate(instance.proxy);
        }
        if (!props.created && !remote) {
          if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
            return;
          }
          select.setSelected();
        }
      });
      watch(() => selectGroup.disabled, () => {
        states.groupDisabled = selectGroup.disabled;
      }, { immediate: true });
      return {
        select,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem,
        updateOption
      };
    }
    const _sfc_main$h = /* @__PURE__ */ defineComponent({
      name: "ElOption",
      componentName: "ElOption",
      props: {
        value: {
          required: true,
          type: [String, Number, Boolean, Object]
        },
        label: [String, Number],
        created: Boolean,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const id = useId();
        const containerKls = computed(() => [
          ns.be("dropdown", "item"),
          ns.is("disabled", unref(isDisabled)),
          ns.is("selected", unref(itemSelected)),
          ns.is("hovering", unref(hover))
        ]);
        const states = reactive({
          index: -1,
          groupDisabled: false,
          visible: true,
          hover: false
        });
        const {
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption
        } = useOption(props, states);
        const { visible, hover } = toRefs(states);
        const vm = getCurrentInstance().proxy;
        select.onOptionCreate(vm);
        onBeforeUnmount(() => {
          const key = vm.value;
          const { selected } = select.states;
          const selectedOptions = select.props.multiple ? selected : [selected];
          const doesSelected = selectedOptions.some((item) => {
            return item.value === vm.value;
          });
          nextTick(() => {
            if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
              select.states.cachedOptions.delete(key);
            }
          });
          select.onOptionDestroy(key, vm);
        });
        function selectOptionClick() {
          if (props.disabled !== true && states.groupDisabled !== true) {
            select.handleOptionSelect(vm);
          }
        }
        return {
          ns,
          id,
          containerKls,
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption,
          visible,
          hover,
          selectOptionClick,
          states
        };
      }
    });
    const _hoisted_1$9 = ["id", "aria-disabled", "aria-selected"];
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("li", {
        id: _ctx.id,
        class: normalizeClass(_ctx.containerKls),
        role: "option",
        "aria-disabled": _ctx.isDisabled || void 0,
        "aria-selected": _ctx.itemSelected,
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
        ])
      ], 42, _hoisted_1$9)), [
        [vShow, _ctx.visible]
      ]);
    }
    var Option = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$7], ["__file", "option.vue"]]);
    const _sfc_main$g = /* @__PURE__ */ defineComponent({
      name: "ElSelectDropdown",
      componentName: "ElSelectDropdown",
      setup() {
        const select = inject(selectKey);
        const ns = useNamespace("select");
        const popperClass = computed(() => select.props.popperClass);
        const isMultiple = computed(() => select.props.multiple);
        const isFitInputWidth = computed(() => select.props.fitInputWidth);
        const minWidth = ref("");
        function updateMinWidth() {
          var _a2;
          minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
        }
        onMounted(() => {
          updateMinWidth();
          useResizeObserver(select.selectRef, updateMinWidth);
        });
        return {
          ns,
          minWidth,
          popperClass,
          isMultiple,
          isFitInputWidth
        };
      }
    });
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
        style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
      }, [
        _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("dropdown", "header"))
        }, [
          renderSlot(_ctx.$slots, "header")
        ], 2)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true)
      ], 6);
    }
    var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$6], ["__file", "select-dropdown.vue"]]);
    function useInput(handleInput) {
      const isComposing = ref(false);
      const handleCompositionStart = () => {
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        if (isComposing.value) {
          isComposing.value = false;
          if (isFunction$1(handleInput)) {
            handleInput(event);
          }
        }
      };
      return {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      };
    }
    const MINIMUM_INPUT_WIDTH = 11;
    const useSelect = (props, emit2) => {
      const { t } = useLocale();
      const contentId = useId();
      const nsSelect = useNamespace("select");
      const nsInput = useNamespace("input");
      const states = reactive({
        inputValue: "",
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        disabledOptions: /* @__PURE__ */ new Map(),
        optionValues: [],
        selected: props.multiple ? [] : {},
        selectionWidth: 0,
        calculatorWidth: 0,
        collapseItemWidth: 0,
        selectedLabel: "",
        hoveringIndex: -1,
        previousQuery: null,
        inputHovering: false,
        menuVisibleOnFocus: false,
        isBeforeHide: false
      });
      const selectRef = ref(null);
      const selectionRef = ref(null);
      const tooltipRef = ref(null);
      const tagTooltipRef = ref(null);
      const inputRef = ref(null);
      const calculatorRef = ref(null);
      const prefixRef = ref(null);
      const suffixRef = ref(null);
      const menuRef = ref(null);
      const tagMenuRef = ref(null);
      const collapseItemRef = ref(null);
      const scrollbarRef = ref(null);
      const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
        afterFocus() {
          if (props.automaticDropdown && !expanded.value) {
            expanded.value = true;
            states.menuVisibleOnFocus = true;
          }
        },
        beforeBlur(event) {
          var _a2, _b;
          return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
        },
        afterBlur() {
          expanded.value = false;
          states.menuVisibleOnFocus = false;
        }
      });
      const expanded = ref(false);
      const hoverOption = ref();
      const { form, formItem } = useFormItem();
      const { inputId } = useFormItemInputId(props, {
        formItemContext: formItem
      });
      const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props);
      const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
      const hasModelValue = computed(() => {
        return props.multiple ? isArray$2(props.modelValue) && props.modelValue.length > 0 : !isEmptyValue2(props.modelValue);
      });
      const showClose = computed(() => {
        return props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
      });
      const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
      const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value));
      const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
      const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
      const debounce$1$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && !states.inputValue && states.options.size === 0)
            return false;
          if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (states.options.size === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
      const optionsArray = computed(() => {
        const list = Array.from(states.options.values());
        const newList = [];
        states.optionValues.forEach((item) => {
          const index = list.findIndex((i) => i.value === item);
          if (index > -1) {
            newList.push(list[index]);
          }
        });
        return newList.length >= list.length ? newList : list;
      });
      const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
      const showNewOption = computed(() => {
        const hasExistingOption = optionsArray.value.filter((option) => {
          return !option.created;
        }).some((option) => {
          return option.currentLabel === states.inputValue;
        });
        return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
      });
      const updateOptions2 = () => {
        if (props.filterable && isFunction$1(props.filterMethod))
          return;
        if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
          return;
        optionsArray.value.forEach((option) => {
          var _a2;
          (_a2 = option.updateOption) == null ? void 0 : _a2.call(option, states.inputValue);
        });
      };
      const selectSize = useFormSize();
      const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
      const dropdownMenuVisible = computed({
        get() {
          return expanded.value && emptyText.value !== false;
        },
        set(val) {
          expanded.value = val;
        }
      });
      const shouldShowPlaceholder = computed(() => {
        if (isArray$2(props.modelValue)) {
          return props.modelValue.length === 0 && !states.inputValue;
        }
        return props.filterable ? !states.inputValue : true;
      });
      const currentPlaceholder = computed(() => {
        var _a2;
        const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t("el.select.placeholder");
        return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
      });
      const mouseEnterEventName = computed(() => isIOS ? null : "mouseenter");
      watch(() => props.modelValue, (val, oldVal) => {
        if (props.multiple) {
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
            handleQueryChange("");
          }
        }
        setSelected();
        if (!isEqual(val, oldVal) && props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
        }
      }, {
        flush: "post",
        deep: true
      });
      watch(() => expanded.value, (val) => {
        if (val) {
          handleQueryChange(states.inputValue);
        } else {
          states.inputValue = "";
          states.previousQuery = null;
          states.isBeforeHide = true;
        }
        emit2("visible-change", val);
      });
      watch(() => states.options.entries(), () => {
        var _a2;
        if (!isClient)
          return;
        const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
        if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          checkDefaultFirstOption();
        }
      }, {
        flush: "post"
      });
      watch(() => states.hoveringIndex, (val) => {
        if (isNumber(val) && val > -1) {
          hoverOption.value = optionsArray.value[val] || {};
        } else {
          hoverOption.value = {};
        }
        optionsArray.value.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      });
      watchEffect(() => {
        if (states.isBeforeHide)
          return;
        updateOptions2();
      });
      const handleQueryChange = (val) => {
        if (states.previousQuery === val) {
          return;
        }
        states.previousQuery = val;
        if (props.filterable && isFunction$1(props.filterMethod)) {
          props.filterMethod(val);
        } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
          props.remoteMethod(val);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          nextTick(checkDefaultFirstOption);
        } else {
          nextTick(updateHoveringIndex);
        }
      };
      const checkDefaultFirstOption = () => {
        const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
        const userCreatedOption = optionsInDropdown.find((n) => n.created);
        const firstOriginOption = optionsInDropdown[0];
        states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
      };
      const setSelected = () => {
        if (!props.multiple) {
          const option = getOption(props.modelValue);
          states.selectedLabel = option.currentLabel;
          states.selected = option;
          return;
        } else {
          states.selectedLabel = "";
        }
        const result = [];
        if (isArray$2(props.modelValue)) {
          props.modelValue.forEach((value) => {
            result.push(getOption(value));
          });
        }
        states.selected = result;
      };
      const getOption = (value) => {
        let option;
        const isObjectValue = toRawType(value).toLowerCase() === "object";
        const isNull = toRawType(value).toLowerCase() === "null";
        const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
        for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
          const cachedOption = cachedOptionsArray.value[i];
          const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
          if (isEqualValue) {
            option = {
              value,
              currentLabel: cachedOption.currentLabel,
              get isDisabled() {
                return cachedOption.isDisabled;
              }
            };
            break;
          }
        }
        if (option)
          return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
        const newOption = {
          value,
          currentLabel: label
        };
        return newOption;
      };
      const updateHoveringIndex = () => {
        if (!props.multiple) {
          states.hoveringIndex = optionsArray.value.findIndex((item) => {
            return getValueKey(item) === getValueKey(states.selected);
          });
        } else {
          states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
        }
      };
      const resetSelectionWidth = () => {
        states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
      };
      const resetCalculatorWidth = () => {
        states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
      };
      const resetCollapseItemWidth = () => {
        states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
      };
      const updateTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const updateTagTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const onInputChange = () => {
        if (states.inputValue.length > 0 && !expanded.value) {
          expanded.value = true;
        }
        handleQueryChange(states.inputValue);
      };
      const onInput = (event) => {
        states.inputValue = event.target.value;
        if (props.remote) {
          debouncedOnInputChange();
        } else {
          return onInputChange();
        }
      };
      const debouncedOnInputChange = debounce$1(() => {
        onInputChange();
      }, debounce$1$1.value);
      const emitChange = (val) => {
        if (!isEqual(props.modelValue, val)) {
          emit2(CHANGE_EVENT, val);
        }
      };
      const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
      const deletePrevTag = (e) => {
        if (!props.multiple)
          return;
        if (e.code === EVENT_CODE.delete)
          return;
        if (e.target.value.length <= 0) {
          const value = props.modelValue.slice();
          const lastNotDisabledIndex = getLastNotDisabledIndex(value);
          if (lastNotDisabledIndex < 0)
            return;
          const removeTagValue = value[lastNotDisabledIndex];
          value.splice(lastNotDisabledIndex, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          emit2("remove-tag", removeTagValue);
        }
      };
      const deleteTag = (event, tag) => {
        const index = states.selected.indexOf(tag);
        if (index > -1 && !selectDisabled.value) {
          const value = props.modelValue.slice();
          value.splice(index, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          emit2("remove-tag", tag.value);
        }
        event.stopPropagation();
        focus();
      };
      const deleteSelected = (event) => {
        event.stopPropagation();
        const value = props.multiple ? [] : valueOnClear.value;
        if (props.multiple) {
          for (const item of states.selected) {
            if (item.isDisabled)
              value.push(item.value);
          }
        }
        emit2(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.hoveringIndex = -1;
        expanded.value = false;
        emit2("clear");
        focus();
      };
      const handleOptionSelect = (option) => {
        if (props.multiple) {
          const value = (props.modelValue || []).slice();
          const optionIndex = getValueIndex(value, option.value);
          if (optionIndex > -1) {
            value.splice(optionIndex, 1);
          } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
            value.push(option.value);
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          if (option.created) {
            handleQueryChange("");
          }
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
          }
        } else {
          emit2(UPDATE_MODEL_EVENT, option.value);
          emitChange(option.value);
          expanded.value = false;
        }
        focus();
        if (expanded.value)
          return;
        nextTick(() => {
          scrollToOption(option);
        });
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$1(value))
          return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index = -1;
        arr.some((item, i) => {
          if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
            index = i;
            return true;
          }
          return false;
        });
        return index;
      };
      const scrollToOption = (option) => {
        var _a2, _b, _c, _d, _e;
        const targetOption = isArray$2(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
          const options = optionsArray.value.filter((item) => item.value === targetOption.value);
          if (options.length > 0) {
            target = options[0].$el;
          }
        }
        if (tooltipRef.value && target) {
          const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
          if (menu) {
            scrollIntoView(menu, target);
          }
        }
        (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
      };
      const onOptionCreate = (vm) => {
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
        vm.disabled && states.disabledOptions.set(vm.value, vm);
      };
      const onOptionDestroy = (key, vm) => {
        if (states.options.get(key) === vm) {
          states.options.delete(key);
        }
      };
      const {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      } = useInput((e) => onInput(e));
      const popperRef = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
      });
      const handleMenuEnter = () => {
        states.isBeforeHide = false;
        nextTick(() => scrollToOption(states.selected));
      };
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      };
      const blur = () => {
        handleClickOutside();
      };
      const handleClearClick = (event) => {
        deleteSelected(event);
      };
      const handleClickOutside = (event) => {
        expanded.value = false;
        if (isFocused.value) {
          const _event2 = new FocusEvent("focus", event);
          nextTick(() => handleBlur(_event2));
        }
      };
      const handleEsc = () => {
        if (states.inputValue.length > 0) {
          states.inputValue = "";
        } else {
          expanded.value = false;
        }
      };
      const toggleMenu = () => {
        if (selectDisabled.value)
          return;
        if (isIOS)
          states.inputHovering = true;
        if (states.menuVisibleOnFocus) {
          states.menuVisibleOnFocus = false;
        } else {
          expanded.value = !expanded.value;
        }
      };
      const selectOption = () => {
        if (!expanded.value) {
          toggleMenu();
        } else {
          if (optionsArray.value[states.hoveringIndex]) {
            handleOptionSelect(optionsArray.value[states.hoveringIndex]);
          }
        }
      };
      const getValueKey = (item) => {
        return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
      };
      const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
      const showTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
      });
      const collapseTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
      });
      const navigateOptions = (direction) => {
        if (!expanded.value) {
          expanded.value = true;
          return;
        }
        if (states.options.size === 0 || filteredOptionsCount.value === 0)
          return;
        if (!optionsAllDisabled.value) {
          if (direction === "next") {
            states.hoveringIndex++;
            if (states.hoveringIndex === states.options.size) {
              states.hoveringIndex = 0;
            }
          } else if (direction === "prev") {
            states.hoveringIndex--;
            if (states.hoveringIndex < 0) {
              states.hoveringIndex = states.options.size - 1;
            }
          }
          const option = optionsArray.value[states.hoveringIndex];
          if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
            navigateOptions(direction);
          }
          nextTick(() => scrollToOption(hoverOption.value));
        }
      };
      const getGapWidth = () => {
        if (!selectionRef.value)
          return 0;
        const style = window.getComputedStyle(selectionRef.value);
        return Number.parseFloat(style.gap || "6px");
      };
      const tagStyle = computed(() => {
        const gapWidth = getGapWidth();
        const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
        return { maxWidth: `${maxWidth}px` };
      });
      const collapseTagStyle = computed(() => {
        return { maxWidth: `${states.selectionWidth}px` };
      });
      const inputStyle = computed(() => ({
        width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
      }));
      if (props.multiple && !isArray$2(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, []);
      }
      if (!props.multiple && isArray$2(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, "");
      }
      useResizeObserver(selectionRef, resetSelectionWidth);
      useResizeObserver(calculatorRef, resetCalculatorWidth);
      useResizeObserver(menuRef, updateTooltip);
      useResizeObserver(wrapperRef, updateTooltip);
      useResizeObserver(tagMenuRef, updateTagTooltip);
      useResizeObserver(collapseItemRef, resetCollapseItemWidth);
      onMounted(() => {
        setSelected();
      });
      return {
        inputId,
        contentId,
        nsSelect,
        nsInput,
        states,
        isFocused,
        expanded,
        optionsArray,
        hoverOption,
        selectSize,
        filteredOptionsCount,
        resetCalculatorWidth,
        updateTooltip,
        updateTagTooltip,
        debouncedOnInputChange,
        onInput,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        hasModelValue,
        shouldShowPlaceholder,
        currentPlaceholder,
        mouseEnterEventName,
        showClose,
        iconComponent,
        iconReverse,
        validateState,
        validateIcon,
        showNewOption,
        updateOptions: updateOptions2,
        collapseTagSize,
        setSelected,
        selectDisabled,
        emptyText,
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        focus,
        blur,
        handleBlur,
        handleClearClick,
        handleClickOutside,
        handleEsc,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropdownMenuVisible,
        showTagList,
        collapseTagList,
        tagStyle,
        collapseTagStyle,
        inputStyle,
        popperRef,
        inputRef,
        tooltipRef,
        tagTooltipRef,
        calculatorRef,
        prefixRef,
        suffixRef,
        selectRef,
        wrapperRef,
        selectionRef,
        scrollbarRef,
        menuRef,
        tagMenuRef,
        collapseItemRef
      };
    };
    var ElOptions = /* @__PURE__ */ defineComponent({
      name: "ElOptions",
      setup(_, { slots }) {
        const select = inject(selectKey);
        let cachedValueList = [];
        return () => {
          var _a2, _b;
          const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          const valueList = [];
          function filterOptions(children2) {
            if (!isArray$2(children2))
              return;
            children2.forEach((item) => {
              var _a22, _b2, _c, _d;
              const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
              if (name === "ElOptionGroup") {
                filterOptions(!isString$1(item.children) && !isArray$2(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
              } else if (name === "ElOption") {
                valueList.push((_d = item.props) == null ? void 0 : _d.value);
              } else if (isArray$2(item.children)) {
                filterOptions(item.children);
              }
            });
          }
          if (children.length) {
            filterOptions((_b = children[0]) == null ? void 0 : _b.children);
          }
          if (!isEqual(valueList, cachedValueList)) {
            cachedValueList = valueList;
            if (select) {
              select.states.optionValues = valueList;
            }
          }
          return children;
        };
      }
    });
    const SelectProps = buildProps({
      name: String,
      id: String,
      modelValue: {
        type: [Array, String, Number, Boolean, Object],
        default: void 0
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      automaticDropdown: Boolean,
      size: useSizeProp,
      effect: {
        type: definePropType(String),
        default: "light"
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: {
        type: String
      },
      defaultFirstOption: Boolean,
      reserveKeyword: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: "value"
      },
      collapseTags: Boolean,
      collapseTagsTooltip: Boolean,
      maxCollapseTags: {
        type: Number,
        default: 1
      },
      teleported: useTooltipContentProps.teleported,
      persistent: {
        type: Boolean,
        default: true
      },
      clearIcon: {
        type: iconPropType,
        default: circle_close_default
      },
      fitInputWidth: Boolean,
      suffixIcon: {
        type: iconPropType,
        default: arrow_down_default
      },
      tagType: { ...tagProps.type, default: "info" },
      tagEffect: { ...tagProps.effect, default: "light" },
      validateEvent: {
        type: Boolean,
        default: true
      },
      remoteShowSuffix: Boolean,
      placement: {
        type: definePropType(String),
        values: Ee,
        default: "bottom-start"
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: ["bottom-start", "top-start", "right", "left"]
      },
      ...useEmptyValuesProps,
      ...useAriaProps(["ariaLabel"])
    });
    const COMPONENT_NAME$3 = "ElSelect";
    const _sfc_main$f = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$3,
      componentName: COMPONENT_NAME$3,
      components: {
        ElInput,
        ElSelectMenu,
        ElOption: Option,
        ElOptions,
        ElTag,
        ElScrollbar,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside },
      props: SelectProps,
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, { emit: emit2 }) {
        const API = useSelect(props, emit2);
        provide(selectKey, reactive({
          props,
          states: API.states,
          optionsArray: API.optionsArray,
          handleOptionSelect: API.handleOptionSelect,
          onOptionCreate: API.onOptionCreate,
          onOptionDestroy: API.onOptionDestroy,
          selectRef: API.selectRef,
          setSelected: API.setSelected
        }));
        return {
          ...API
        };
      }
    });
    const _hoisted_1$8 = ["id", "name", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
    const _hoisted_2$3 = ["textContent"];
    const _hoisted_3$2 = { key: 1 };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_option = resolveComponent("el-option");
      const _component_el_options = resolveComponent("el-options");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectRef",
        class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
        [toHandlerKey(_ctx.mouseEnterEventName)]: _cache[16] || (_cache[16] = ($event) => _ctx.states.inputHovering = true),
        onMouseleave: _cache[17] || (_cache[17] = ($event) => _ctx.states.inputHovering = false),
        onClick: _cache[18] || (_cache[18] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["prevent", "stop"]))
      }, [
        createVNode(_component_el_tooltip, {
          ref: "tooltipRef",
          visible: _ctx.dropdownMenuVisible,
          placement: _ctx.placement,
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
          "popper-options": _ctx.popperOptions,
          "fallback-placements": _ctx.fallbackPlacements,
          effect: _ctx.effect,
          pure: "",
          trigger: "click",
          transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
          "stop-popper-mouse-event": false,
          "gpu-acceleration": false,
          persistent: _ctx.persistent,
          onBeforeShow: _ctx.handleMenuEnter,
          onHide: _cache[15] || (_cache[15] = ($event) => _ctx.states.isBeforeHide = false)
        }, {
          default: withCtx(() => {
            var _a2;
            return [
              createBaseVNode("div", {
                ref: "wrapperRef",
                class: normalizeClass([
                  _ctx.nsSelect.e("wrapper"),
                  _ctx.nsSelect.is("focused", _ctx.isFocused),
                  _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                  _ctx.nsSelect.is("filterable", _ctx.filterable),
                  _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "prefixRef",
                  class: normalizeClass(_ctx.nsSelect.e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref: "selectionRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("selection"),
                    _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                  ])
                }, [
                  _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          effect: _ctx.tagEffect,
                          "disable-transitions": "",
                          style: normalizeStyle(_ctx.tagStyle),
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, [
                              renderSlot(_ctx.$slots, "label", {
                                label: item.currentLabel,
                                value: item.value
                              }, () => [
                                createTextVNode(toDisplayString(item.currentLabel), 1)
                              ])
                            ], 2)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                      ], 2);
                    }), 128)),
                    _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                      key: 0,
                      ref: "tagTooltipRef",
                      disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: _ctx.effect,
                      placement: "bottom",
                      teleported: _ctx.teleported
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "collapseItemRef",
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: false,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            effect: _ctx.tagEffect,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.collapseTagStyle)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                            ]),
                            _: 1
                          }, 8, ["size", "type", "effect", "style"])
                        ], 2)
                      ]),
                      content: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "tagMenuRef",
                          class: normalizeClass(_ctx.nsSelect.e("selection"))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                            return openBlock(), createElementBlock("div", {
                              key: _ctx.getValueKey(item),
                              class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                            }, [
                              createVNode(_component_el_tag, {
                                class: "in-tooltip",
                                closable: !_ctx.selectDisabled && !item.isDisabled,
                                size: _ctx.collapseTagSize,
                                type: _ctx.tagType,
                                effect: _ctx.tagEffect,
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag($event, item)
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("span", {
                                    class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                  }, [
                                    renderSlot(_ctx.$slots, "label", {
                                      label: item.currentLabel,
                                      value: item.value
                                    }, () => [
                                      createTextVNode(toDisplayString(item.currentLabel), 1)
                                    ])
                                  ], 2)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "type", "effect", "onClose"])
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 3
                    }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true),
                  !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("input-wrapper"),
                      _ctx.nsSelect.is("hidden", !_ctx.filterable)
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.inputId,
                      ref: "inputRef",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                      type: "text",
                      name: _ctx.name,
                      class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                      disabled: _ctx.selectDisabled,
                      autocomplete: _ctx.autocomplete,
                      style: normalizeStyle(_ctx.inputStyle),
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                      "aria-controls": _ctx.contentId,
                      "aria-expanded": _ctx.dropdownMenuVisible,
                      "aria-label": _ctx.ariaLabel,
                      "aria-autocomplete": "none",
                      "aria-haspopup": "listbox",
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onKeydown: [
                        _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                        _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                        _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                      ],
                      onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                    }, null, 46, _hoisted_1$8), [
                      [vModelText, _ctx.states.inputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.inputValue)
                    }, null, 10, _hoisted_2$3)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("placeholder"),
                      _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                    ])
                  }, [
                    _ctx.hasModelValue ? renderSlot(_ctx.$slots, "label", {
                      key: 0,
                      label: _ctx.currentPlaceholder,
                      value: _ctx.modelValue
                    }, () => [
                      createBaseVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                    ]) : (openBlock(), createElementBlock("span", _hoisted_3$2, toDisplayString(_ctx.currentPlaceholder), 1))
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createBaseVNode("div", {
                  ref: "suffixRef",
                  class: normalizeClass(_ctx.nsSelect.e("suffix"))
                }, [
                  _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                    onClick: _ctx.handleClearClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ];
          }),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, { ref: "menuRef" }, {
              default: withCtx(() => [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                  onClick: _cache[13] || (_cache[13] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  renderSlot(_ctx.$slots, "header")
                ], 2)) : createCommentVNode("v-if", true),
                withDirectives(createVNode(_component_el_scrollbar, {
                  id: _ctx.contentId,
                  ref: "scrollbarRef",
                  tag: "ul",
                  "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                  "view-class": _ctx.nsSelect.be("dropdown", "list"),
                  class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                  role: "listbox",
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": "vertical"
                }, {
                  default: withCtx(() => [
                    _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: _ctx.states.inputValue,
                      created: true
                    }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                    createVNode(_component_el_options, null, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                  [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                ]),
                _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                }, [
                  renderSlot(_ctx.$slots, "loading")
                ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                  key: 3,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                  onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                  }, ["stop"]))
                }, [
                  renderSlot(_ctx.$slots, "footer")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 512)
          ]),
          _: 3
        }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
      ], 16)), [
        [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
      ]);
    }
    var Select = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$5], ["__file", "select.vue"]]);
    const _sfc_main$e = /* @__PURE__ */ defineComponent({
      name: "ElOptionGroup",
      componentName: "ElOptionGroup",
      props: {
        label: String,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const groupRef = ref(null);
        const instance = getCurrentInstance();
        const children = ref([]);
        provide(selectGroupKey, reactive({
          ...toRefs(props)
        }));
        const visible = computed(() => children.value.some((option) => option.visible === true));
        const isOption = (node) => {
          var _a2, _b;
          return ((_a2 = node.type) == null ? void 0 : _a2.name) === "ElOption" && !!((_b = node.component) == null ? void 0 : _b.proxy);
        };
        const flattedChildren2 = (node) => {
          const Nodes = castArray(node);
          const children2 = [];
          Nodes.forEach((child) => {
            var _a2, _b;
            if (isOption(child)) {
              children2.push(child.component.proxy);
            } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
              children2.push(...flattedChildren2(child.children));
            } else if ((_b = child.component) == null ? void 0 : _b.subTree) {
              children2.push(...flattedChildren2(child.component.subTree));
            }
          });
          return children2;
        };
        const updateChildren = () => {
          children.value = flattedChildren2(instance.subTree);
        };
        onMounted(() => {
          updateChildren();
        });
        useMutationObserver(groupRef, updateChildren, {
          attributes: true,
          subtree: true,
          childList: true
        });
        return {
          groupRef,
          visible,
          ns
        };
      }
    });
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("ul", {
        ref: "groupRef",
        class: normalizeClass(_ctx.ns.be("group", "wrap"))
      }, [
        createBaseVNode("li", {
          class: normalizeClass(_ctx.ns.be("group", "title"))
        }, toDisplayString(_ctx.label), 3),
        createBaseVNode("li", null, [
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.ns.b("group"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ])
      ], 2)), [
        [vShow, _ctx.visible]
      ]);
    }
    var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$4], ["__file", "option-group.vue"]]);
    const ElSelect = withInstall(Select, {
      Option,
      OptionGroup
    });
    const ElOption = withNoopInstall(Option);
    withNoopInstall(OptionGroup);
    const sliderContextKey = Symbol("sliderContextKey");
    const sliderProps = buildProps({
      modelValue: {
        type: definePropType([Number, Array]),
        default: 0
      },
      id: {
        type: String,
        default: void 0
      },
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: 1
      },
      showInput: Boolean,
      showInputControls: {
        type: Boolean,
        default: true
      },
      size: useSizeProp,
      inputSize: useSizeProp,
      showStops: Boolean,
      showTooltip: {
        type: Boolean,
        default: true
      },
      formatTooltip: {
        type: definePropType(Function),
        default: void 0
      },
      disabled: Boolean,
      range: Boolean,
      vertical: Boolean,
      height: String,
      debounce: {
        type: Number,
        default: 300
      },
      label: {
        type: String,
        default: void 0
      },
      rangeStartLabel: {
        type: String,
        default: void 0
      },
      rangeEndLabel: {
        type: String,
        default: void 0
      },
      formatValueText: {
        type: definePropType(Function),
        default: void 0
      },
      tooltipClass: {
        type: String,
        default: void 0
      },
      placement: {
        type: String,
        values: Ee,
        default: "top"
      },
      marks: {
        type: definePropType(Object)
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      ...useAriaProps(["ariaLabel"])
    });
    const isValidValue = (value) => isNumber(value) || isArray$2(value) && value.every(isNumber);
    const sliderEmits = {
      [UPDATE_MODEL_EVENT]: isValidValue,
      [INPUT_EVENT]: isValidValue,
      [CHANGE_EVENT]: isValidValue
    };
    const useLifecycle = (props, initData, resetSize) => {
      const sliderWrapper = ref();
      onMounted(async () => {
        if (props.range) {
          if (Array.isArray(props.modelValue)) {
            initData.firstValue = Math.max(props.min, props.modelValue[0]);
            initData.secondValue = Math.min(props.max, props.modelValue[1]);
          } else {
            initData.firstValue = props.min;
            initData.secondValue = props.max;
          }
          initData.oldValue = [initData.firstValue, initData.secondValue];
        } else {
          if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
            initData.firstValue = props.min;
          } else {
            initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
          }
          initData.oldValue = initData.firstValue;
        }
        useEventListener(window, "resize", resetSize);
        await nextTick();
        resetSize();
      });
      return {
        sliderWrapper
      };
    };
    const useMarks = (props) => {
      return computed(() => {
        if (!props.marks) {
          return [];
        }
        const marksKeys = Object.keys(props.marks);
        return marksKeys.map(Number.parseFloat).sort((a, b) => a - b).filter((point) => point <= props.max && point >= props.min).map((point) => ({
          point,
          position: (point - props.min) * 100 / (props.max - props.min),
          mark: props.marks[point]
        }));
      });
    };
    const useSlide = (props, initData, emit2) => {
      const { form: elForm, formItem: elFormItem } = useFormItem();
      const slider = shallowRef();
      const firstButton = ref();
      const secondButton = ref();
      const buttonRefs = {
        firstButton,
        secondButton
      };
      const sliderDisabled = computed(() => {
        return props.disabled || (elForm == null ? void 0 : elForm.disabled) || false;
      });
      const minValue = computed(() => {
        return Math.min(initData.firstValue, initData.secondValue);
      });
      const maxValue = computed(() => {
        return Math.max(initData.firstValue, initData.secondValue);
      });
      const barSize = computed(() => {
        return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
      });
      const barStart = computed(() => {
        return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
      });
      const runwayStyle = computed(() => {
        return props.vertical ? { height: props.height } : {};
      });
      const barStyle = computed(() => {
        return props.vertical ? {
          height: barSize.value,
          bottom: barStart.value
        } : {
          width: barSize.value,
          left: barStart.value
        };
      });
      const resetSize = () => {
        if (slider.value) {
          initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
        }
      };
      const getButtonRefByPercent = (percent) => {
        const targetValue = props.min + percent * (props.max - props.min) / 100;
        if (!props.range) {
          return firstButton;
        }
        let buttonRefName;
        if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
          buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
        } else {
          buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
        }
        return buttonRefs[buttonRefName];
      };
      const setPosition = (percent) => {
        const buttonRef = getButtonRefByPercent(percent);
        buttonRef.value.setPosition(percent);
        return buttonRef;
      };
      const setFirstValue = (firstValue) => {
        initData.firstValue = firstValue;
        _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
      };
      const setSecondValue = (secondValue) => {
        initData.secondValue = secondValue;
        if (props.range) {
          _emit([minValue.value, maxValue.value]);
        }
      };
      const _emit = (val) => {
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(INPUT_EVENT, val);
      };
      const emitChange = async () => {
        await nextTick();
        emit2(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
      };
      const handleSliderPointerEvent = (event) => {
        var _a2, _b, _c, _d, _e, _f;
        if (sliderDisabled.value || initData.dragging)
          return;
        resetSize();
        let newPercent = 0;
        if (props.vertical) {
          const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
          const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
          newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
        } else {
          const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
          const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
          newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
        }
        if (newPercent < 0 || newPercent > 100)
          return;
        return setPosition(newPercent);
      };
      const onSliderWrapperPrevent = (event) => {
        var _a2, _b;
        if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
          event.preventDefault();
        }
      };
      const onSliderDown = async (event) => {
        const buttonRef = handleSliderPointerEvent(event);
        if (buttonRef) {
          await nextTick();
          buttonRef.value.onButtonDown(event);
        }
      };
      const onSliderClick = (event) => {
        const buttonRef = handleSliderPointerEvent(event);
        if (buttonRef) {
          emitChange();
        }
      };
      return {
        elFormItem,
        slider,
        firstButton,
        secondButton,
        sliderDisabled,
        minValue,
        maxValue,
        runwayStyle,
        barStyle,
        resetSize,
        setPosition,
        emitChange,
        onSliderWrapperPrevent,
        onSliderClick,
        onSliderDown,
        setFirstValue,
        setSecondValue
      };
    };
    const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
    const useTooltip = (props, formatTooltip, showTooltip) => {
      const tooltip = ref();
      const tooltipVisible = ref(false);
      const enableFormat = computed(() => {
        return formatTooltip.value instanceof Function;
      });
      const formatValue = computed(() => {
        return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
      });
      const displayTooltip = debounce$1(() => {
        showTooltip.value && (tooltipVisible.value = true);
      }, 50);
      const hideTooltip = debounce$1(() => {
        showTooltip.value && (tooltipVisible.value = false);
      }, 50);
      return {
        tooltip,
        tooltipVisible,
        formatValue,
        displayTooltip,
        hideTooltip
      };
    };
    const useSliderButton = (props, initData, emit2) => {
      const {
        disabled,
        min,
        max,
        step,
        showTooltip,
        precision,
        sliderSize,
        formatTooltip,
        emitChange,
        resetSize,
        updateDragging
      } = inject(sliderContextKey);
      const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
      const button = ref();
      const currentPosition = computed(() => {
        return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;
      });
      const wrapperStyle = computed(() => {
        return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
      });
      const handleMouseEnter = () => {
        initData.hovering = true;
        displayTooltip();
      };
      const handleMouseLeave = () => {
        initData.hovering = false;
        if (!initData.dragging) {
          hideTooltip();
        }
      };
      const onButtonDown = (event) => {
        if (disabled.value)
          return;
        event.preventDefault();
        onDragStart(event);
        window.addEventListener("mousemove", onDragging);
        window.addEventListener("touchmove", onDragging);
        window.addEventListener("mouseup", onDragEnd);
        window.addEventListener("touchend", onDragEnd);
        window.addEventListener("contextmenu", onDragEnd);
        button.value.focus();
      };
      const incrementPosition = (amount) => {
        if (disabled.value)
          return;
        initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;
        setPosition(initData.newPosition);
        emitChange();
      };
      const onLeftKeyDown = () => {
        incrementPosition(-step.value);
      };
      const onRightKeyDown = () => {
        incrementPosition(step.value);
      };
      const onPageDownKeyDown = () => {
        incrementPosition(-step.value * 4);
      };
      const onPageUpKeyDown = () => {
        incrementPosition(step.value * 4);
      };
      const onHomeKeyDown = () => {
        if (disabled.value)
          return;
        setPosition(0);
        emitChange();
      };
      const onEndKeyDown = () => {
        if (disabled.value)
          return;
        setPosition(100);
        emitChange();
      };
      const onKeyDown = (event) => {
        let isPreventDefault = true;
        if ([left, down].includes(event.key)) {
          onLeftKeyDown();
        } else if ([right, up].includes(event.key)) {
          onRightKeyDown();
        } else if (event.key === home) {
          onHomeKeyDown();
        } else if (event.key === end) {
          onEndKeyDown();
        } else if (event.key === pageDown) {
          onPageDownKeyDown();
        } else if (event.key === pageUp) {
          onPageUpKeyDown();
        } else {
          isPreventDefault = false;
        }
        isPreventDefault && event.preventDefault();
      };
      const getClientXY = (event) => {
        let clientX;
        let clientY;
        if (event.type.startsWith("touch")) {
          clientY = event.touches[0].clientY;
          clientX = event.touches[0].clientX;
        } else {
          clientY = event.clientY;
          clientX = event.clientX;
        }
        return {
          clientX,
          clientY
        };
      };
      const onDragStart = (event) => {
        initData.dragging = true;
        initData.isClick = true;
        const { clientX, clientY } = getClientXY(event);
        if (props.vertical) {
          initData.startY = clientY;
        } else {
          initData.startX = clientX;
        }
        initData.startPosition = Number.parseFloat(currentPosition.value);
        initData.newPosition = initData.startPosition;
      };
      const onDragging = (event) => {
        if (initData.dragging) {
          initData.isClick = false;
          displayTooltip();
          resetSize();
          let diff;
          const { clientX, clientY } = getClientXY(event);
          if (props.vertical) {
            initData.currentY = clientY;
            diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
          } else {
            initData.currentX = clientX;
            diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
          }
          initData.newPosition = initData.startPosition + diff;
          setPosition(initData.newPosition);
        }
      };
      const onDragEnd = () => {
        if (initData.dragging) {
          setTimeout(() => {
            initData.dragging = false;
            if (!initData.hovering) {
              hideTooltip();
            }
            if (!initData.isClick) {
              setPosition(initData.newPosition);
            }
            emitChange();
          }, 0);
          window.removeEventListener("mousemove", onDragging);
          window.removeEventListener("touchmove", onDragging);
          window.removeEventListener("mouseup", onDragEnd);
          window.removeEventListener("touchend", onDragEnd);
          window.removeEventListener("contextmenu", onDragEnd);
        }
      };
      const setPosition = async (newPosition) => {
        if (newPosition === null || Number.isNaN(+newPosition))
          return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        const lengthPerStep = 100 / ((max.value - min.value) / step.value);
        const steps = Math.round(newPosition / lengthPerStep);
        let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
        value = Number.parseFloat(value.toFixed(precision.value));
        if (value !== props.modelValue) {
          emit2(UPDATE_MODEL_EVENT, value);
        }
        if (!initData.dragging && props.modelValue !== initData.oldValue) {
          initData.oldValue = props.modelValue;
        }
        await nextTick();
        initData.dragging && displayTooltip();
        tooltip.value.updatePopper();
      };
      watch(() => initData.dragging, (val) => {
        updateDragging(val);
      });
      return {
        disabled,
        button,
        tooltip,
        tooltipVisible,
        showTooltip,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onKeyDown,
        setPosition
      };
    };
    const useStops = (props, initData, minValue, maxValue) => {
      const stops = computed(() => {
        if (!props.showStops || props.min > props.max)
          return [];
        if (props.step === 0) {
          return [];
        }
        const stopCount = (props.max - props.min) / props.step;
        const stepWidth = 100 * props.step / (props.max - props.min);
        const result = Array.from({ length: stopCount - 1 }).map((_, index) => (index + 1) * stepWidth);
        if (props.range) {
          return result.filter((step) => {
            return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
          });
        } else {
          return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
        }
      });
      const getStopStyle = (position) => {
        return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
      };
      return {
        stops,
        getStopStyle
      };
    };
    const useWatch = (props, initData, minValue, maxValue, emit2, elFormItem) => {
      const _emit = (val) => {
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(INPUT_EVENT, val);
      };
      const valueChanged = () => {
        if (props.range) {
          return ![minValue.value, maxValue.value].every((item, index) => item === initData.oldValue[index]);
        } else {
          return props.modelValue !== initData.oldValue;
        }
      };
      const setValues = () => {
        var _a2, _b;
        if (props.min > props.max) {
          throwError("Slider", "min should not be greater than max.");
        }
        const val = props.modelValue;
        if (props.range && Array.isArray(val)) {
          if (val[1] < props.min) {
            _emit([props.min, props.min]);
          } else if (val[0] > props.max) {
            _emit([props.max, props.max]);
          } else if (val[0] < props.min) {
            _emit([props.min, val[1]]);
          } else if (val[1] > props.max) {
            _emit([val[0], props.max]);
          } else {
            initData.firstValue = val[0];
            initData.secondValue = val[1];
            if (valueChanged()) {
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
              }
              initData.oldValue = val.slice();
            }
          }
        } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
          if (val < props.min) {
            _emit(props.min);
          } else if (val > props.max) {
            _emit(props.max);
          } else {
            initData.firstValue = val;
            if (valueChanged()) {
              if (props.validateEvent) {
                (_b = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change").catch((err) => debugWarn());
              }
              initData.oldValue = val;
            }
          }
        }
      };
      setValues();
      watch(() => initData.dragging, (val) => {
        if (!val) {
          setValues();
        }
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
          return;
        }
        setValues();
      }, {
        deep: true
      });
      watch(() => [props.min, props.max], () => {
        setValues();
      });
    };
    const sliderButtonProps = buildProps({
      modelValue: {
        type: Number,
        default: 0
      },
      vertical: Boolean,
      tooltipClass: String,
      placement: {
        type: String,
        values: Ee,
        default: "top"
      }
    });
    const sliderButtonEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
    };
    const _hoisted_1$7 = ["tabindex"];
    const __default__$3 = /* @__PURE__ */ defineComponent({
      name: "ElSliderButton"
    });
    const _sfc_main$d = /* @__PURE__ */ defineComponent({
      ...__default__$3,
      props: sliderButtonProps,
      emits: sliderButtonEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("slider");
        const initData = reactive({
          hovering: false,
          dragging: false,
          isClick: false,
          startX: 0,
          currentX: 0,
          startY: 0,
          currentY: 0,
          startPosition: 0,
          newPosition: 0,
          oldValue: props.modelValue
        });
        const {
          disabled,
          button,
          tooltip,
          showTooltip,
          tooltipVisible,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        } = useSliderButton(props, initData, emit2);
        const { hovering, dragging } = toRefs(initData);
        expose({
          onButtonDown,
          onKeyDown,
          setPosition,
          hovering,
          dragging
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "button",
            ref: button,
            class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
            style: normalizeStyle(unref(wrapperStyle)),
            tabindex: unref(disabled) ? -1 : 0,
            onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
            onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
            onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
            onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
            onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
            onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
            onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
          }, [
            createVNode(unref(ElTooltip), {
              ref_key: "tooltip",
              ref: tooltip,
              visible: unref(tooltipVisible),
              placement: _ctx.placement,
              "fallback-placements": ["top", "bottom", "right", "left"],
              "stop-popper-mouse-event": false,
              "popper-class": _ctx.tooltipClass,
              disabled: !unref(showTooltip),
              persistent: ""
            }, {
              content: withCtx(() => [
                createBaseVNode("span", null, toDisplayString(unref(formatValue)), 1)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                }, null, 2)
              ]),
              _: 1
            }, 8, ["visible", "placement", "popper-class", "disabled"])
          ], 46, _hoisted_1$7);
        };
      }
    });
    var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "button.vue"]]);
    const sliderMarkerProps = buildProps({
      mark: {
        type: definePropType([String, Object]),
        default: void 0
      }
    });
    var SliderMarker = /* @__PURE__ */ defineComponent({
      name: "ElSliderMarker",
      props: sliderMarkerProps,
      setup(props) {
        const ns = useNamespace("slider");
        const label = computed(() => {
          return isString$1(props.mark) ? props.mark : props.mark.label;
        });
        const style = computed(() => isString$1(props.mark) ? void 0 : props.mark.style);
        return () => h("div", {
          class: ns.e("marks-text"),
          style: style.value
        }, label.value);
      }
    });
    const _hoisted_1$6 = ["id", "role", "aria-label", "aria-labelledby"];
    const _hoisted_2$2 = { key: 1 };
    const __default__$2 = /* @__PURE__ */ defineComponent({
      name: "ElSlider"
    });
    const _sfc_main$c = /* @__PURE__ */ defineComponent({
      ...__default__$2,
      props: sliderProps,
      emits: sliderEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("slider");
        const { t } = useLocale();
        const initData = reactive({
          firstValue: 0,
          secondValue: 0,
          oldValue: 0,
          dragging: false,
          sliderSize: 1
        });
        const {
          elFormItem,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        } = useSlide(props, initData, emit2);
        const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem
        });
        const sliderWrapperSize = useFormSize();
        const sliderInputSize = computed(() => props.inputSize || sliderWrapperSize.value);
        const groupLabel = computed(() => {
          return props.label || props.ariaLabel || t("el.slider.defaultLabel", {
            min: props.min,
            max: props.max
          });
        });
        const firstButtonLabel = computed(() => {
          if (props.range) {
            return props.rangeStartLabel || t("el.slider.defaultRangeStartLabel");
          } else {
            return groupLabel.value;
          }
        });
        const firstValueText = computed(() => {
          return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
        });
        const secondButtonLabel = computed(() => {
          return props.rangeEndLabel || t("el.slider.defaultRangeEndLabel");
        });
        const secondValueText = computed(() => {
          return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
        });
        const sliderKls = computed(() => [
          ns.b(),
          ns.m(sliderWrapperSize.value),
          ns.is("vertical", props.vertical),
          { [ns.m("with-input")]: props.showInput }
        ]);
        const markList = useMarks(props);
        useWatch(props, initData, minValue, maxValue, emit2, elFormItem);
        const precision = computed(() => {
          const precisions = [props.min, props.max, props.step].map((item) => {
            const decimal = `${item}`.split(".")[1];
            return decimal ? decimal.length : 0;
          });
          return Math.max.apply(null, precisions);
        });
        const { sliderWrapper } = useLifecycle(props, initData, resetSize);
        const { firstValue, secondValue, sliderSize } = toRefs(initData);
        const updateDragging = (val) => {
          initData.dragging = val;
        };
        provide(sliderContextKey, {
          ...toRefs(props),
          sliderSize,
          disabled: sliderDisabled,
          precision,
          emitChange,
          resetSize,
          updateDragging
        });
        useDeprecated({
          from: "label",
          replacement: "aria-label",
          version: "2.8.0",
          scope: "el-slider",
          ref: "https://element-plus.org/en-US/component/slider.html"
        }, computed(() => !!props.label));
        expose({
          onSliderClick
        });
        return (_ctx, _cache) => {
          var _a2, _b;
          return openBlock(), createElementBlock("div", {
            id: _ctx.range ? unref(inputId) : void 0,
            ref_key: "sliderWrapper",
            ref: sliderWrapper,
            class: normalizeClass(unref(sliderKls)),
            role: _ctx.range ? "group" : void 0,
            "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
            "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem)) == null ? void 0 : _a2.labelId : void 0,
            onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
            onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
          }, [
            createBaseVNode("div", {
              ref_key: "slider",
              ref: slider,
              class: normalizeClass([
                unref(ns).e("runway"),
                { "show-input": _ctx.showInput && !_ctx.range },
                unref(ns).is("disabled", unref(sliderDisabled))
              ]),
              style: normalizeStyle(unref(runwayStyle)),
              onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
              onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("bar")),
                style: normalizeStyle(unref(barStyle))
              }, null, 6),
              createVNode(SliderButton, {
                id: !_ctx.range ? unref(inputId) : void 0,
                ref_key: "firstButton",
                ref: firstButton,
                "model-value": unref(firstValue),
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                placement: _ctx.placement,
                role: "slider",
                "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem)) == null ? void 0 : _b.labelId : void 0,
                "aria-valuemin": _ctx.min,
                "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                "aria-valuenow": unref(firstValue),
                "aria-valuetext": unref(firstValueText),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-disabled": unref(sliderDisabled),
                "onUpdate:modelValue": unref(setFirstValue)
              }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
              _ctx.range ? (openBlock(), createBlock(SliderButton, {
                key: 0,
                ref_key: "secondButton",
                ref: secondButton,
                "model-value": unref(secondValue),
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                placement: _ctx.placement,
                role: "slider",
                "aria-label": unref(secondButtonLabel),
                "aria-valuemin": unref(firstValue),
                "aria-valuemax": _ctx.max,
                "aria-valuenow": unref(secondValue),
                "aria-valuetext": unref(secondValueText),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-disabled": unref(sliderDisabled),
                "onUpdate:modelValue": unref(setSecondValue)
              }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
              _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$2, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                  return openBlock(), createElementBlock("div", {
                    key,
                    class: normalizeClass(unref(ns).e("stop")),
                    style: normalizeStyle(unref(getStopStyle)(item))
                  }, null, 6);
                }), 128))
              ])) : createCommentVNode("v-if", true),
              unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("div", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      style: normalizeStyle(unref(getStopStyle)(item.position)),
                      class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                    }, null, 6);
                  }), 128))
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("marks"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                    return openBlock(), createBlock(unref(SliderMarker), {
                      key,
                      mark: item.mark,
                      style: normalizeStyle(unref(getStopStyle)(item.position))
                    }, null, 8, ["mark", "style"]);
                  }), 128))
                ], 2)
              ], 64)) : createCommentVNode("v-if", true)
            ], 38),
            _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
              key: 0,
              ref: "input",
              "model-value": unref(firstValue),
              class: normalizeClass(unref(ns).e("input")),
              step: _ctx.step,
              disabled: unref(sliderDisabled),
              controls: _ctx.showInputControls,
              min: _ctx.min,
              max: _ctx.max,
              debounce: _ctx.debounce,
              size: unref(sliderInputSize),
              "onUpdate:modelValue": unref(setFirstValue),
              onChange: unref(emitChange)
            }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$6);
        };
      }
    });
    var Slider = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "slider.vue"]]);
    const ElSlider = withInstall(Slider);
    const tabsRootContextKey = Symbol("tabsRootContextKey");
    const tabBarProps = buildProps({
      tabs: {
        type: definePropType(Array),
        default: () => mutable([])
      }
    });
    const COMPONENT_NAME$2 = "ElTabBar";
    const __default__$1 = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$2
    });
    const _sfc_main$b = /* @__PURE__ */ defineComponent({
      ...__default__$1,
      props: tabBarProps,
      setup(__props, { expose }) {
        const props = __props;
        const instance = getCurrentInstance();
        const rootTabs = inject(tabsRootContextKey);
        if (!rootTabs)
          throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
        const ns = useNamespace("tabs");
        const barRef = ref();
        const barStyle = ref();
        const getBarStyle = () => {
          let offset = 0;
          let tabSize = 0;
          const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
          const sizeDir = sizeName === "width" ? "x" : "y";
          const position = sizeDir === "x" ? "left" : "top";
          props.tabs.every((tab) => {
            var _a2, _b;
            const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
            if (!$el)
              return false;
            if (!tab.active) {
              return true;
            }
            offset = $el[`offset${capitalize(position)}`];
            tabSize = $el[`client${capitalize(sizeName)}`];
            const tabStyles = window.getComputedStyle($el);
            if (sizeName === "width") {
              if (props.tabs.length > 1) {
                tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
              }
              offset += Number.parseFloat(tabStyles.paddingLeft);
            }
            return false;
          });
          return {
            [sizeName]: `${tabSize}px`,
            transform: `translate${capitalize(sizeDir)}(${offset}px)`
          };
        };
        const update = () => barStyle.value = getBarStyle();
        watch(() => props.tabs, async () => {
          await nextTick();
          update();
        }, { immediate: true });
        useResizeObserver(barRef, () => update());
        expose({
          ref: barRef,
          update
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "barRef",
            ref: barRef,
            class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
            style: normalizeStyle(barStyle.value)
          }, null, 6);
        };
      }
    });
    var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "tab-bar.vue"]]);
    const tabNavProps = buildProps({
      panes: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      currentName: {
        type: [String, Number],
        default: ""
      },
      editable: Boolean,
      type: {
        type: String,
        values: ["card", "border-card", ""],
        default: ""
      },
      stretch: Boolean
    });
    const tabNavEmits = {
      tabClick: (tab, tabName, ev) => ev instanceof Event,
      tabRemove: (tab, ev) => ev instanceof Event
    };
    const COMPONENT_NAME$1 = "ElTabNav";
    const TabNav = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$1,
      props: tabNavProps,
      emits: tabNavEmits,
      setup(props, {
        expose,
        emit: emit2
      }) {
        const vm = getCurrentInstance();
        const rootTabs = inject(tabsRootContextKey);
        if (!rootTabs)
          throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
        const ns = useNamespace("tabs");
        const visibility = useDocumentVisibility();
        const focused = useWindowFocus();
        const navScroll$ = ref();
        const nav$ = ref();
        const el$ = ref();
        const tabBarRef = ref();
        const scrollable = ref(false);
        const navOffset = ref(0);
        const isFocus = ref(false);
        const focusable = ref(true);
        const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
        const navStyle = computed(() => {
          const dir = sizeName.value === "width" ? "X" : "Y";
          return {
            transform: `translate${dir}(-${navOffset.value}px)`
          };
        });
        const scrollPrev = () => {
          if (!navScroll$.value)
            return;
          const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (!currentOffset)
            return;
          const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
          navOffset.value = newOffset;
        };
        const scrollNext = () => {
          if (!navScroll$.value || !nav$.value)
            return;
          const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
          const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (navSize - currentOffset <= containerSize)
            return;
          const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
          navOffset.value = newOffset;
        };
        const scrollToActiveTab = async () => {
          const nav = nav$.value;
          if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
            return;
          await nextTick();
          const activeTab = el$.value.querySelector(".is-active");
          if (!activeTab)
            return;
          const navScroll = navScroll$.value;
          const isHorizontal = ["top", "bottom"].includes(rootTabs.props.tabPosition);
          const activeTabBounding = activeTab.getBoundingClientRect();
          const navScrollBounding = navScroll.getBoundingClientRect();
          const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
          const currentOffset = navOffset.value;
          let newOffset = currentOffset;
          if (isHorizontal) {
            if (activeTabBounding.left < navScrollBounding.left) {
              newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
            }
            if (activeTabBounding.right > navScrollBounding.right) {
              newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
            }
          } else {
            if (activeTabBounding.top < navScrollBounding.top) {
              newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
            }
            if (activeTabBounding.bottom > navScrollBounding.bottom) {
              newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
            }
          }
          newOffset = Math.max(newOffset, 0);
          navOffset.value = Math.min(newOffset, maxOffset);
        };
        const update = () => {
          var _a2;
          if (!nav$.value || !navScroll$.value)
            return;
          props.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
          const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
          const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (containerSize < navSize) {
            scrollable.value = scrollable.value || {};
            scrollable.value.prev = currentOffset;
            scrollable.value.next = currentOffset + containerSize < navSize;
            if (navSize - currentOffset < containerSize) {
              navOffset.value = navSize - containerSize;
            }
          } else {
            scrollable.value = false;
            if (currentOffset > 0) {
              navOffset.value = 0;
            }
          }
        };
        const changeTab = (e) => {
          const code = e.code;
          const {
            up: up2,
            down: down2,
            left: left2,
            right: right2
          } = EVENT_CODE;
          if (![up2, down2, left2, right2].includes(code))
            return;
          const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
          const currentIndex = tabList.indexOf(e.target);
          let nextIndex;
          if (code === left2 || code === up2) {
            if (currentIndex === 0) {
              nextIndex = tabList.length - 1;
            } else {
              nextIndex = currentIndex - 1;
            }
          } else {
            if (currentIndex < tabList.length - 1) {
              nextIndex = currentIndex + 1;
            } else {
              nextIndex = 0;
            }
          }
          tabList[nextIndex].focus({
            preventScroll: true
          });
          tabList[nextIndex].click();
          setFocus();
        };
        const setFocus = () => {
          if (focusable.value)
            isFocus.value = true;
        };
        const removeFocus = () => isFocus.value = false;
        watch(visibility, (visibility2) => {
          if (visibility2 === "hidden") {
            focusable.value = false;
          } else if (visibility2 === "visible") {
            setTimeout(() => focusable.value = true, 50);
          }
        });
        watch(focused, (focused2) => {
          if (focused2) {
            setTimeout(() => focusable.value = true, 50);
          } else {
            focusable.value = false;
          }
        });
        useResizeObserver(el$, update);
        onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
        onUpdated(() => update());
        expose({
          scrollToActiveTab,
          removeFocus
        });
        watch(() => props.panes, () => vm.update(), {
          flush: "post",
          deep: true
        });
        return () => {
          const scrollBtn = scrollable.value ? [createVNode("span", {
            "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
            "onClick": scrollPrev
          }, [createVNode(ElIcon, null, {
            default: () => [createVNode(arrow_left_default, null, null)]
          })]), createVNode("span", {
            "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
            "onClick": scrollNext
          }, [createVNode(ElIcon, null, {
            default: () => [createVNode(arrow_right_default, null, null)]
          })])] : null;
          const tabs = props.panes.map((pane, index) => {
            var _a2, _b, _c, _d;
            const uid2 = pane.uid;
            const disabled = pane.props.disabled;
            const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
            const closable = !disabled && (pane.isClosable || props.editable);
            pane.index = `${index}`;
            const btnClose = closable ? createVNode(ElIcon, {
              "class": "is-icon-close",
              "onClick": (ev) => emit2("tabRemove", pane, ev)
            }, {
              default: () => [createVNode(close_default, null, null)]
            }) : null;
            const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
            const tabindex = !disabled && pane.active ? 0 : -1;
            return createVNode("div", {
              "ref": `tab-${uid2}`,
              "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
              "id": `tab-${tabName}`,
              "key": `tab-${uid2}`,
              "aria-controls": `pane-${tabName}`,
              "role": "tab",
              "aria-selected": pane.active,
              "tabindex": tabindex,
              "onFocus": () => setFocus(),
              "onBlur": () => removeFocus(),
              "onClick": (ev) => {
                removeFocus();
                emit2("tabClick", pane, tabName, ev);
              },
              "onKeydown": (ev) => {
                if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                  emit2("tabRemove", pane, ev);
                }
              }
            }, [...[tabLabelContent, btnClose]]);
          });
          return createVNode("div", {
            "ref": el$,
            "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
          }, [scrollBtn, createVNode("div", {
            "class": ns.e("nav-scroll"),
            "ref": navScroll$
          }, [createVNode("div", {
            "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
            "ref": nav$,
            "style": navStyle.value,
            "role": "tablist",
            "onKeydown": changeTab
          }, [...[!props.type ? createVNode(TabBar, {
            "ref": tabBarRef,
            "tabs": [...props.panes]
          }, null) : null, tabs]])])]);
        };
      }
    });
    const tabsProps = buildProps({
      type: {
        type: String,
        values: ["card", "border-card", ""],
        default: ""
      },
      closable: Boolean,
      addable: Boolean,
      modelValue: {
        type: [String, Number]
      },
      editable: Boolean,
      tabPosition: {
        type: String,
        values: ["top", "right", "bottom", "left"],
        default: "top"
      },
      beforeLeave: {
        type: definePropType(Function),
        default: () => true
      },
      stretch: Boolean
    });
    const isPaneName = (value) => isString$1(value) || isNumber(value);
    const tabsEmits = {
      [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
      tabClick: (pane, ev) => ev instanceof Event,
      tabChange: (name) => isPaneName(name),
      edit: (paneName, action) => ["remove", "add"].includes(action),
      tabRemove: (name) => isPaneName(name),
      tabAdd: () => true
    };
    const Tabs = /* @__PURE__ */ defineComponent({
      name: "ElTabs",
      props: tabsProps,
      emits: tabsEmits,
      setup(props, {
        emit: emit2,
        slots,
        expose
      }) {
        var _a2;
        const ns = useNamespace("tabs");
        const {
          children: panes,
          addChild: registerPane,
          removeChild: unregisterPane
        } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
        const nav$ = ref();
        const currentName = ref((_a2 = props.modelValue) != null ? _a2 : "0");
        const setCurrentName = async (value, trigger2 = false) => {
          var _a22, _b, _c;
          if (currentName.value === value || isUndefined(value))
            return;
          try {
            const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
            if (canLeave !== false) {
              currentName.value = value;
              if (trigger2) {
                emit2(UPDATE_MODEL_EVENT, value);
                emit2("tabChange", value);
              }
              (_c = (_b = nav$.value) == null ? void 0 : _b.removeFocus) == null ? void 0 : _c.call(_b);
            }
          } catch (e) {
          }
        };
        const handleTabClick = (tab, tabName, event) => {
          if (tab.props.disabled)
            return;
          setCurrentName(tabName, true);
          emit2("tabClick", tab, event);
        };
        const handleTabRemove = (pane, ev) => {
          if (pane.props.disabled || isUndefined(pane.props.name))
            return;
          ev.stopPropagation();
          emit2("edit", pane.props.name, "remove");
          emit2("tabRemove", pane.props.name);
        };
        const handleTabAdd = () => {
          emit2("edit", void 0, "add");
          emit2("tabAdd");
        };
        watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
        watch(currentName, async () => {
          var _a22;
          await nextTick();
          (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
        });
        provide(tabsRootContextKey, {
          props,
          currentName,
          registerPane,
          unregisterPane
        });
        expose({
          currentName
        });
        return () => {
          const addSlot = slots["add-icon"];
          const newButton = props.editable || props.addable ? createVNode("span", {
            "class": ns.e("new-tab"),
            "tabindex": "0",
            "onClick": handleTabAdd,
            "onKeydown": (ev) => {
              if (ev.code === EVENT_CODE.enter)
                handleTabAdd();
            }
          }, [addSlot ? renderSlot(slots, "add-icon") : createVNode(ElIcon, {
            "class": ns.is("icon-plus")
          }, {
            default: () => [createVNode(plus_default, null, null)]
          })]) : null;
          const header = createVNode("div", {
            "class": [ns.e("header"), ns.is(props.tabPosition)]
          }, [newButton, createVNode(TabNav, {
            "ref": nav$,
            "currentName": currentName.value,
            "editable": props.editable,
            "type": props.type,
            "panes": panes.value,
            "stretch": props.stretch,
            "onTabClick": handleTabClick,
            "onTabRemove": handleTabRemove
          }, null)]);
          const panels = createVNode("div", {
            "class": ns.e("content")
          }, [renderSlot(slots, "default")]);
          return createVNode("div", {
            "class": [ns.b(), ns.m(props.tabPosition), {
              [ns.m("card")]: props.type === "card",
              [ns.m("border-card")]: props.type === "border-card"
            }]
          }, [...props.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
        };
      }
    });
    const tabPaneProps = buildProps({
      label: {
        type: String,
        default: ""
      },
      name: {
        type: [String, Number]
      },
      closable: Boolean,
      disabled: Boolean,
      lazy: Boolean
    });
    const _hoisted_1$5 = ["id", "aria-hidden", "aria-labelledby"];
    const COMPONENT_NAME = "ElTabPane";
    const __default__ = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME
    });
    const _sfc_main$a = /* @__PURE__ */ defineComponent({
      ...__default__,
      props: tabPaneProps,
      setup(__props) {
        const props = __props;
        const instance = getCurrentInstance();
        const slots = useSlots();
        const tabsRoot = inject(tabsRootContextKey);
        if (!tabsRoot)
          throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
        const ns = useNamespace("tab-pane");
        const index = ref();
        const isClosable = computed(() => props.closable || tabsRoot.props.closable);
        const active = computedEager(() => {
          var _a2;
          return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index.value);
        });
        const loaded = ref(active.value);
        const paneName = computed(() => {
          var _a2;
          return (_a2 = props.name) != null ? _a2 : index.value;
        });
        const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
        watch(active, (val) => {
          if (val)
            loaded.value = true;
        });
        const pane = reactive({
          uid: instance.uid,
          slots,
          props,
          paneName,
          active,
          index,
          isClosable
        });
        onMounted(() => {
          tabsRoot.registerPane(pane);
        });
        onUnmounted(() => {
          tabsRoot.unregisterPane(pane.uid);
        });
        return (_ctx, _cache) => {
          return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            id: `pane-${unref(paneName)}`,
            class: normalizeClass(unref(ns).b()),
            role: "tabpanel",
            "aria-hidden": !unref(active),
            "aria-labelledby": `tab-${unref(paneName)}`
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 10, _hoisted_1$5)), [
            [vShow, unref(active)]
          ]) : createCommentVNode("v-if", true);
        };
      }
    });
    var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "tab-pane.vue"]]);
    const ElTabs = withInstall(Tabs, {
      TabPane
    });
    const ElTabPane = withNoopInstall(TabPane);
    function createLoadingComponent(options) {
      let afterLeaveTimer;
      const afterLeaveFlag = ref(false);
      const data = reactive({
        ...options,
        originalPosition: "",
        originalOverflow: "",
        visible: false
      });
      function setText(text) {
        data.text = text;
      }
      function destroySelf() {
        const target = data.parent;
        const ns = vm.ns;
        if (!target.vLoadingAddClassList) {
          let loadingNumber = target.getAttribute("loading-number");
          loadingNumber = Number.parseInt(loadingNumber) - 1;
          if (!loadingNumber) {
            removeClass(target, ns.bm("parent", "relative"));
            target.removeAttribute("loading-number");
          } else {
            target.setAttribute("loading-number", loadingNumber.toString());
          }
          removeClass(target, ns.bm("parent", "hidden"));
        }
        removeElLoadingChild();
        loadingInstance.unmount();
      }
      function removeElLoadingChild() {
        var _a2, _b;
        (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
      }
      function close() {
        var _a2;
        if (options.beforeClose && !options.beforeClose())
          return;
        afterLeaveFlag.value = true;
        clearTimeout(afterLeaveTimer);
        afterLeaveTimer = window.setTimeout(handleAfterLeave, 400);
        data.visible = false;
        (_a2 = options.closed) == null ? void 0 : _a2.call(options);
      }
      function handleAfterLeave() {
        if (!afterLeaveFlag.value)
          return;
        const target = data.parent;
        afterLeaveFlag.value = false;
        target.vLoadingAddClassList = void 0;
        destroySelf();
      }
      const elLoadingComponent = /* @__PURE__ */ defineComponent({
        name: "ElLoading",
        setup(_, { expose }) {
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("loading");
          expose({
            ns,
            zIndex: zIndex2
          });
          return () => {
            const svg = data.spinner || data.svg;
            const spinner = h("svg", {
              class: "circular",
              viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
              ...svg ? { innerHTML: svg } : {}
            }, [
              h("circle", {
                class: "path",
                cx: "25",
                cy: "25",
                r: "20",
                fill: "none"
              })
            ]);
            const spinnerText = data.text ? h("p", { class: ns.b("text") }, [data.text]) : void 0;
            return h(Transition, {
              name: ns.b("fade"),
              onAfterLeave: handleAfterLeave
            }, {
              default: withCtx(() => [
                withDirectives(createVNode("div", {
                  style: {
                    backgroundColor: data.background || ""
                  },
                  class: [
                    ns.b("mask"),
                    data.customClass,
                    data.fullscreen ? "is-fullscreen" : ""
                  ]
                }, [
                  h("div", {
                    class: ns.b("spinner")
                  }, [spinner, spinnerText])
                ]), [[vShow, data.visible]])
              ])
            });
          };
        }
      });
      const loadingInstance = createApp(elLoadingComponent);
      const vm = loadingInstance.mount(document.createElement("div"));
      return {
        ...toRefs(data),
        setText,
        removeElLoadingChild,
        close,
        handleAfterLeave,
        vm,
        get $el() {
          return vm.$el;
        }
      };
    }
    let fullscreenInstance = void 0;
    const Loading = function(options = {}) {
      if (!isClient)
        return void 0;
      const resolved = resolveOptions(options);
      if (resolved.fullscreen && fullscreenInstance) {
        return fullscreenInstance;
      }
      const instance = createLoadingComponent({
        ...resolved,
        closed: () => {
          var _a2;
          (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
          if (resolved.fullscreen)
            fullscreenInstance = void 0;
        }
      });
      addStyle(resolved, resolved.parent, instance);
      addClassList(resolved, resolved.parent, instance);
      resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
      let loadingNumber = resolved.parent.getAttribute("loading-number");
      if (!loadingNumber) {
        loadingNumber = "1";
      } else {
        loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
      }
      resolved.parent.setAttribute("loading-number", loadingNumber);
      resolved.parent.appendChild(instance.$el);
      nextTick(() => instance.visible.value = resolved.visible);
      if (resolved.fullscreen) {
        fullscreenInstance = instance;
      }
      return instance;
    };
    const resolveOptions = (options) => {
      var _a2, _b, _c, _d;
      let target;
      if (isString$1(options.target)) {
        target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
      } else {
        target = options.target || document.body;
      }
      return {
        parent: target === document.body || options.body ? document.body : target,
        background: options.background || "",
        svg: options.svg || "",
        svgViewBox: options.svgViewBox || "",
        spinner: options.spinner || false,
        text: options.text || "",
        fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
        lock: (_c = options.lock) != null ? _c : false,
        customClass: options.customClass || "",
        visible: (_d = options.visible) != null ? _d : true,
        target
      };
    };
    const addStyle = async (options, parent, instance) => {
      const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
      const maskStyle = {};
      if (options.fullscreen) {
        instance.originalPosition.value = getStyle(document.body, "position");
        instance.originalOverflow.value = getStyle(document.body, "overflow");
        maskStyle.zIndex = nextZIndex();
      } else if (options.parent === document.body) {
        instance.originalPosition.value = getStyle(document.body, "position");
        await nextTick();
        for (const property2 of ["top", "left"]) {
          const scroll = property2 === "top" ? "scrollTop" : "scrollLeft";
          maskStyle[property2] = `${options.target.getBoundingClientRect()[property2] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property2}`), 10)}px`;
        }
        for (const property2 of ["height", "width"]) {
          maskStyle[property2] = `${options.target.getBoundingClientRect()[property2]}px`;
        }
      } else {
        instance.originalPosition.value = getStyle(parent, "position");
      }
      for (const [key, value] of Object.entries(maskStyle)) {
        instance.$el.style[key] = value;
      }
    };
    const addClassList = (options, parent, instance) => {
      const ns = instance.vm.ns || instance.vm._.exposed.ns;
      if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
        addClass(parent, ns.bm("parent", "relative"));
      } else {
        removeClass(parent, ns.bm("parent", "relative"));
      }
      if (options.fullscreen && options.lock) {
        addClass(parent, ns.bm("parent", "hidden"));
      } else {
        removeClass(parent, ns.bm("parent", "hidden"));
      }
    };
    const INSTANCE_KEY = Symbol("ElLoading");
    const createInstance = (el, binding) => {
      var _a2, _b, _c, _d;
      const vm = binding.instance;
      const getBindingProp = (key) => isObject$1(binding.value) ? binding.value[key] : void 0;
      const resolveExpression = (key) => {
        const data = isString$1(key) && (vm == null ? void 0 : vm[key]) || key;
        if (data)
          return ref(data);
        else
          return data;
      };
      const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
      const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
      const options = {
        text: getProp2("text"),
        svg: getProp2("svg"),
        svgViewBox: getProp2("svgViewBox"),
        spinner: getProp2("spinner"),
        background: getProp2("background"),
        customClass: getProp2("customClass"),
        fullscreen,
        target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
        body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
        lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
      };
      el[INSTANCE_KEY] = {
        options,
        instance: Loading(options)
      };
    };
    const updateOptions = (newOptions, originalOptions) => {
      for (const key of Object.keys(originalOptions)) {
        if (isRef(originalOptions[key]))
          originalOptions[key].value = newOptions[key];
      }
    };
    const vLoading = {
      mounted(el, binding) {
        if (binding.value) {
          createInstance(el, binding);
        }
      },
      updated(el, binding) {
        const instance = el[INSTANCE_KEY];
        if (binding.oldValue !== binding.value) {
          if (binding.value && !binding.oldValue) {
            createInstance(el, binding);
          } else if (binding.value && binding.oldValue) {
            if (isObject$1(binding.value))
              updateOptions(binding.value, instance.options);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        }
      },
      unmounted(el) {
        var _a2;
        (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
        el[INSTANCE_KEY] = null;
      }
    };
    var VueDrawCanvas = /* @__PURE__ */ defineComponent({
      name: "VueDrawCanvas",
      props: {
        strokeType: {
          type: String,
          default: "dash",
          validator: (value) => {
            return ["dash", "line", "rectangle", "circle", "triangle", "half_triangle"].indexOf(value) !== -1;
          }
        },
        fillShape: {
          type: Boolean,
          default: () => false
        },
        width: {
          type: [String, Number],
          default: () => 600
        },
        height: {
          type: [String, Number],
          default: () => 400
        },
        image: {
          type: String,
          default: () => ""
        },
        eraser: {
          type: Boolean,
          default: () => false
        },
        color: {
          type: String,
          default: () => "#000000"
        },
        lineWidth: {
          type: Number,
          default: () => 5
        },
        lineCap: {
          type: String,
          default: "round",
          validator: (value) => {
            return ["round", "square", "butt"].indexOf(value) !== -1;
          }
        },
        lineJoin: {
          type: String,
          default: "round",
          validator: (value) => {
            return ["miter", "round", "bevel"].indexOf(value) !== -1;
          }
        },
        lock: {
          type: Boolean,
          default: () => false
        },
        styles: {
          type: [Array, String, Object],
          default: () => ""
        },
        classes: {
          type: [Array, String, Object],
          default: () => ""
        },
        backgroundColor: {
          type: String,
          default: () => "#FFFFFF"
        },
        backgroundImage: {
          type: String,
          default: () => null
        },
        backgroundImageCors: {
          type: String,
          default: () => null
        },
        watermark: {
          type: Object,
          default: () => null
        },
        saveAs: {
          type: String,
          validator: (value) => {
            return ["jpeg", "png"].indexOf(value) !== -1;
          },
          default: () => "png"
        },
        canvasId: {
          type: String,
          default: () => "VueDrawCanvas"
        },
        initialImage: {
          type: Array,
          default: () => []
        },
        additionalImages: {
          type: Array,
          default: () => []
        },
        outputWidth: {
          type: Number,
          default: () => 500
        },
        outputHeight: {
          type: Number,
          default: () => 500
        }
      },
      emits: ["update:image"],
      data() {
        return {
          loadedImage: null,
          drawing: false,
          context: null,
          images: [],
          strokes: {
            type: "",
            from: {
              x: 0,
              y: 0
            },
            coordinates: [],
            color: "",
            width: "",
            fill: false,
            lineCap: "",
            lineJoin: ""
          },
          guides: [],
          trash: []
        };
      },
      watch: {
        backgroundImage: function() {
          this.loadedImage = null;
        }
      },
      mounted() {
        this.setContext();
        this.$nextTick(() => {
          this.drawInitialImage();
          this.drawAdditionalImages();
        });
      },
      methods: {
        async setContext() {
          const canvas = document.querySelector(`#${this.canvasId}`);
          this.context = this.context ? this.context : canvas.getContext("2d");
          await this.setBackground();
        },
        drawInitialImage() {
          if (this.initialImage && this.initialImage.length > 0) {
            this.images = [].concat(this.images, this.initialImage);
            this.redraw(true);
          }
        },
        drawAdditionalImages() {
          if (this.additionalImages && this.additionalImages.length > 0) {
            const canvas = document.querySelector(`#${this.canvasId}`);
            this.additionalImages.forEach((watermarkObject) => {
              this.drawWatermark(canvas, this.context, watermarkObject);
            });
          }
        },
        clear() {
          this.context.clearRect(0, 0, Number(this.width), Number(this.height));
        },
        async setBackground() {
          this.clear();
          this.context.fillStyle = this.backgroundColor;
          this.context.fillRect(0, 0, Number(this.width), Number(this.height));
          this.$nextTick(async () => {
            await this.drawBackgroundImage();
          });
          this.save();
        },
        async drawBackgroundImage() {
          if (!this.loadedImage) {
            return new Promise((resolve2) => {
              if (!this.backgroundImage) {
                resolve2();
                return;
              }
              const image = new Image();
              if (this.backgroundImageCors) image.crossOrigin = this.backgroundImageCors;
              image.src = this.backgroundImage;
              image.onload = () => {
                this.context.drawImage(image, 0, 0);
                this.loadedImage = image;
                resolve2();
              };
            });
          } else {
            this.context.drawImage(this.loadedImage, 0, 0);
          }
        },
        getCoordinates(event) {
          let x, y;
          if (event.touches && event.touches.length > 0) {
            const canvas = document.querySelector(`#${this.canvasId}`);
            const rect = canvas.getBoundingClientRect();
            x = event.touches[0].clientX - rect.left;
            y = event.touches[0].clientY - rect.top;
          } else {
            x = event.offsetX;
            y = event.offsetY;
          }
          return {
            x,
            y
          };
        },
        startDraw(event) {
          if (!this.lock) {
            this.drawing = true;
            this.strokes = {
              type: this.eraser ? "eraser" : this.strokeType,
              from: this.getCoordinates(event),
              coordinates: [],
              color: this.eraser ? this.backgroundColor : this.color,
              width: this.lineWidth,
              fill: this.eraser || this.strokeType === "dash" || this.strokeType === "line" ? false : this.fillShape,
              lineCap: this.lineCap,
              lineJoin: this.lineJoin
            };
            this.guides = [];
          }
        },
        draw(event) {
          if (this.drawing) {
            if (!this.context) {
              this.setContext();
            }
            const coordinate = this.getCoordinates(event);
            if (this.eraser || this.strokeType === "dash") {
              this.strokes.coordinates.push(coordinate);
              this.drawShape(this.context, this.strokes, false);
            } else {
              switch (this.strokeType) {
                case "line": {
                  this.guides = [{
                    x: coordinate.x,
                    y: coordinate.y
                  }];
                  break;
                }
                case "rectangle": {
                  this.guides = [{
                    x: coordinate.x,
                    y: this.strokes.from.y
                  }, {
                    x: coordinate.x,
                    y: coordinate.y
                  }, {
                    x: this.strokes.from.x,
                    y: coordinate.y
                  }, {
                    x: this.strokes.from.x,
                    y: this.strokes.from.y
                  }];
                  break;
                }
                case "triangle": {
                  const center = Math.floor((coordinate.x - this.strokes.from.x) / 2) < 0 ? Math.floor((coordinate.x - this.strokes.from.x) / 2) * -1 : Math.floor((coordinate.x - this.strokes.from.x) / 2);
                  const width = this.strokes.from.x < coordinate.x ? this.strokes.from.x + center : this.strokes.from.x - center;
                  this.guides = [{
                    x: coordinate.x,
                    y: this.strokes.from.y
                  }, {
                    x: width,
                    y: coordinate.y
                  }, {
                    x: this.strokes.from.x,
                    y: this.strokes.from.y
                  }];
                  break;
                }
                case "half_triangle": {
                  this.guides = [{
                    x: coordinate.x,
                    y: this.strokes.from.y
                  }, {
                    x: this.strokes.from.x,
                    y: coordinate.y
                  }, {
                    x: this.strokes.from.x,
                    y: this.strokes.from.y
                  }];
                  break;
                }
                case "circle": {
                  const radiusX = this.strokes.from.x - coordinate.x < 0 ? (this.strokes.from.x - coordinate.x) * -1 : this.strokes.from.x - coordinate.x;
                  this.guides = [{
                    x: this.strokes.from.x > coordinate.x ? this.strokes.from.x - radiusX : this.strokes.from.x + radiusX,
                    y: this.strokes.from.y
                  }, {
                    x: radiusX,
                    y: radiusX
                  }];
                  break;
                }
              }
              this.drawGuide(true);
            }
          }
        },
        drawGuide(closingPath) {
          this.redraw(true);
          this.$nextTick(() => {
            this.context.strokeStyle = this.color;
            this.context.lineWidth = 1;
            this.context.lineJoin = this.lineJoin;
            this.context.lineCap = this.lineCap;
            this.context.beginPath();
            this.context.setLineDash([15, 15]);
            if (this.strokes.type === "circle") {
              this.context.ellipse(this.guides[0].x, this.guides[0].y, this.guides[1].x, this.guides[1].y, 0, 0, Math.PI * 2);
            } else {
              this.context.moveTo(this.strokes.from.x, this.strokes.from.y);
              this.guides.forEach((coordinate) => {
                this.context.lineTo(coordinate.x, coordinate.y);
              });
              if (closingPath) {
                this.context.closePath();
              }
            }
            this.context.stroke();
          });
        },
        drawShape(context, strokes, closingPath) {
          context.strokeStyle = strokes.color;
          context.fillStyle = strokes.color;
          context.lineWidth = strokes.width;
          context.lineJoin = strokes.lineJoin === void 0 ? this.lineJoin : strokes.lineJoin;
          context.lineCap = strokes.lineCap === void 0 ? this.lineCap : strokes.lineCap;
          context.beginPath();
          context.setLineDash([]);
          if (strokes.type === "circle") {
            context.ellipse(strokes.coordinates[0].x, strokes.coordinates[0].y, strokes.coordinates[1].x, strokes.coordinates[1].y, 0, 0, Math.PI * 2);
          } else {
            context.moveTo(strokes.from.x, strokes.from.y);
            strokes.coordinates.forEach((stroke) => {
              context.lineTo(stroke.x, stroke.y);
            });
            if (closingPath) {
              context.closePath();
            }
          }
          if (strokes.fill) {
            context.fill();
          } else {
            context.stroke();
          }
        },
        stopDraw() {
          if (this.drawing) {
            this.strokes.coordinates = this.guides.length > 0 ? this.guides : this.strokes.coordinates;
            this.images.push(this.strokes);
            this.redraw(true);
            this.drawing = false;
            this.trash = [];
          }
        },
        reset() {
          if (!this.lock) {
            this.images = [];
            this.strokes = {
              type: "",
              coordinates: [],
              color: "",
              width: "",
              fill: false,
              lineCap: "",
              lineJoin: ""
            };
            this.guides = [];
            this.trash = [];
            this.redraw(true);
          }
        },
        undo() {
          if (!this.lock) {
            const strokes = this.images.pop();
            if (strokes) {
              this.trash.push(strokes);
              this.redraw(true);
            }
          }
        },
        redo() {
          if (!this.lock) {
            const strokes = this.trash.pop();
            if (strokes) {
              this.images.push(strokes);
              this.redraw(true);
            }
          }
        },
        async redraw(output) {
          output = typeof output !== "undefined" ? output : true;
          await this.setBackground().then(() => {
            this.drawAdditionalImages();
          }).then(() => {
            const baseCanvas = document.createElement("canvas");
            const baseCanvasContext = baseCanvas.getContext("2d");
            baseCanvas.width = Number(this.width);
            baseCanvas.height = Number(this.height);
            if (baseCanvasContext) {
              this.images.forEach((stroke) => {
                if (baseCanvasContext) {
                  baseCanvasContext.globalCompositeOperation = stroke.type === "eraser" ? "destination-out" : "source-over";
                  if (stroke.type !== "circle" || stroke.type === "circle" && stroke.coordinates.length > 0) {
                    this.drawShape(baseCanvasContext, stroke, stroke.type === "eraser" || stroke.type === "dash" || stroke.type === "line" ? false : true);
                  }
                }
              });
              this.context.drawImage(baseCanvas, 0, 0, Number(this.width), Number(this.height));
            }
          }).then(() => {
            if (output) {
              this.save();
            }
          });
        },
        wrapText(context, text, x, y, maxWidth, lineHeight) {
          const newLineRegex = /(\r\n|\n\r|\n|\r)+/g;
          const whitespaceRegex = /\s+/g;
          const lines = text.split(newLineRegex).filter((word) => word.length > 0);
          for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
            const words = lines[lineNumber].split(whitespaceRegex).filter((word) => word.length > 0);
            let line = "";
            for (let n = 0; n < words.length; n++) {
              const testLine = line + words[n] + " ";
              const metrics = context.measureText(testLine);
              const testWidth = metrics.width;
              if (testWidth > maxWidth && n > 0) {
                if (this.watermark && this.watermark.fontStyle && this.watermark.fontStyle.drawType && this.watermark.fontStyle.drawType === "stroke") {
                  context.strokeText(line, x, y);
                } else {
                  context.fillText(line, x, y);
                }
                line = words[n] + " ";
                y += lineHeight;
              } else {
                line = testLine;
              }
            }
            if (this.watermark && this.watermark.fontStyle && this.watermark.fontStyle.drawType && this.watermark.fontStyle.drawType === "stroke") {
              context.strokeText(line, x, y);
            } else {
              context.fillText(line, x, y);
            }
            y += words.length > 0 ? lineHeight : 0;
          }
        },
        save() {
          const canvas = document.querySelector(`#${this.canvasId}`);
          if (this.watermark) {
            const temp = document.createElement("canvas");
            const ctx = temp.getContext("2d");
            if (ctx) {
              temp.width = Number(this.width);
              temp.height = Number(this.height);
              ctx.drawImage(canvas, 0, 0, Number(this.width), Number(this.height));
              this.drawWatermark(temp, ctx, this.watermark);
            }
          } else {
            const temp = document.createElement("canvas");
            const tempCtx = temp.getContext("2d");
            const tempWidth = this.outputWidth === void 0 ? this.width : this.outputWidth;
            const tempHeight = this.outputHeight === void 0 ? this.height : this.outputHeight;
            temp.width = Number(tempWidth);
            temp.height = Number(tempHeight);
            if (tempCtx) {
              tempCtx.drawImage(canvas, 0, 0, Number(tempWidth), Number(tempHeight));
              this.$emit("update:image", temp.toDataURL(`image/${this.saveAs}`, 1));
              return temp.toDataURL(`image/${this.saveAs}`, 1);
            }
          }
        },
        drawWatermark(canvas, ctx, watermark) {
          if (watermark.type === "Image") {
            const imageWidth = watermark.imageStyle ? watermark.imageStyle.width ? watermark.imageStyle.width : Number(this.width) : Number(this.width);
            const imageHeight = watermark.imageStyle ? watermark.imageStyle.height ? watermark.imageStyle.height : Number(this.height) : Number(this.height);
            const image = new Image();
            image.src = watermark.source;
            image.onload = () => {
              if (watermark && ctx) {
                ctx.drawImage(image, watermark.x, watermark.y, Number(imageWidth), Number(imageHeight));
              }
              const temp = document.createElement("canvas");
              const tempCtx = temp.getContext("2d");
              const tempWidth = this.outputWidth === void 0 ? this.width : this.outputWidth;
              const tempHeight = this.outputHeight === void 0 ? this.height : this.outputHeight;
              temp.width = Number(tempWidth);
              temp.height = Number(tempHeight);
              if (tempCtx) {
                tempCtx.drawImage(canvas, 0, 0, Number(tempWidth), Number(tempHeight));
                this.$emit("update:image", temp.toDataURL(`image/${this.saveAs}`, 1));
                return temp.toDataURL(`image/${this.saveAs}`, 1);
              }
            };
          } else if (watermark.type === "Text") {
            const font = watermark.fontStyle ? watermark.fontStyle.font ? watermark.fontStyle.font : "20px serif" : "20px serif";
            const align = watermark.fontStyle ? watermark.fontStyle.textAlign ? watermark.fontStyle.textAlign : "start" : "start";
            const baseline = watermark.fontStyle ? watermark.fontStyle.textBaseline ? watermark.fontStyle.textBaseline : "alphabetic" : "alphabetic";
            const color = watermark.fontStyle ? watermark.fontStyle.color ? watermark.fontStyle.color : "#000000" : "#000000";
            ctx.font = font;
            ctx.textAlign = align;
            ctx.textBaseline = baseline;
            if (watermark.fontStyle && watermark.fontStyle.rotate) {
              let centerX, centerY;
              if (watermark.fontStyle && watermark.fontStyle.width) {
                centerX = watermark.x + Math.floor(watermark.fontStyle.width / 2);
              } else {
                centerX = watermark.x;
              }
              if (watermark.fontStyle && watermark.fontStyle.lineHeight) {
                centerY = watermark.y + Math.floor(watermark.fontStyle.lineHeight / 2);
              } else {
                centerY = watermark.y;
              }
              ctx.translate(centerX, centerY);
              ctx.rotate(watermark.fontStyle.rotate * Math.PI / 180);
              ctx.translate(centerX * -1, centerY * -1);
            }
            if (watermark.fontStyle && watermark.fontStyle.drawType && watermark.fontStyle.drawType === "stroke") {
              ctx.strokeStyle = watermark.fontStyle.color;
              if (watermark.fontStyle && watermark.fontStyle.width) {
                this.wrapText(ctx, watermark.source, watermark.x, watermark.y, watermark.fontStyle.width, watermark.fontStyle.lineHeight);
              } else {
                ctx.strokeText(watermark.source, watermark.x, watermark.y);
              }
            } else {
              ctx.fillStyle = color;
              if (watermark.fontStyle && watermark.fontStyle.width) {
                this.wrapText(ctx, watermark.source, watermark.x, watermark.y, watermark.fontStyle.width, watermark.fontStyle.lineHeight);
              } else {
                ctx.fillText(watermark.source, watermark.x, watermark.y);
              }
            }
            const temp = document.createElement("canvas");
            const tempCtx = temp.getContext("2d");
            const tempWidth = this.outputWidth === void 0 ? this.width : this.outputWidth;
            const tempHeight = this.outputHeight === void 0 ? this.height : this.outputHeight;
            temp.width = Number(tempWidth);
            temp.height = Number(tempHeight);
            if (tempCtx) {
              tempCtx.drawImage(canvas, 0, 0, Number(tempWidth), Number(tempHeight));
              this.$emit("update:image", temp.toDataURL(`image/${this.saveAs}`, 1));
              return temp.toDataURL(`image/${this.saveAs}`, 1);
            }
          }
        },
        isEmpty() {
          return this.images.length > 0 ? false : true;
        },
        getAllStrokes() {
          return this.images;
        }
      },
      render() {
        return h("canvas", {
          id: this.canvasId,
          height: Number(this.height),
          width: Number(this.width),
          style: {
            touchAction: "none",
            // @ts-ignore
            ...this.styles
          },
          class: this.classes,
          onMousedown: ($event) => this.startDraw($event),
          onMousemove: ($event) => this.draw($event),
          onMouseup: () => this.stopDraw(),
          onMouseleave: () => this.stopDraw(),
          onTouchstart: ($event) => this.startDraw($event),
          onTouchmove: ($event) => this.draw($event),
          onTouchend: () => this.stopDraw(),
          onTouchleave: () => this.stopDraw(),
          onTouchcancel: () => this.stopDraw(),
          onPointerdown: ($event) => this.startDraw($event),
          onPointermove: ($event) => this.draw($event),
          onPointerup: () => this.stopDraw(),
          onPointerleave: () => this.stopDraw(),
          onPointercancel: () => this.stopDraw()
        });
      }
    });
    const useDrawPanelStore = /* @__PURE__ */ defineStore("draw-panel", {
      state: () => ({
        canvasRef: null,
        canvasEraser: false,
        canvasDisable: false,
        canvasLine: 5,
        canvasBackground: null,
        canvasBackgroundID: 0,
        currentImgURL: ""
      }),
      actions: {
        setCanvasRef(ref2) {
          this.canvasRef = ref2;
        },
        setCanvasEraser(eraser) {
          this.canvasEraser = eraser;
        },
        setCanvasDisable(disable) {
          this.canvasDisable = disable;
        },
        setCanvasLine(line) {
          this.canvasLine = line;
        },
        setCanvasBackground(background) {
          this.canvasBackground = background;
        },
        setCurrentImgURL(URL) {
          this.currentImgURL = URL;
        },
        setCanvasBackgroundID(ID) {
          this.canvasBackgroundID = ID;
        }
      }
    });
    const useMediaRecordingStore = /* @__PURE__ */ defineStore("mediaRecording", {
      state: () => ({
        recognizedText: "",
        finishRecording: true
      }),
      actions: {
        setRecognizedText(text) {
          this.recognizedText = text;
        },
        toggleFinishRecording() {
          this.finishRecording = !this.finishRecording;
        }
      }
    });
    const usePatientInfoStore = /* @__PURE__ */ defineStore("patient-info", {
      state: () => ({
        currentPatient: "blank",
        switchPatient: false,
        summaryContent: "",
        rawReport: ""
      }),
      actions: {
        setCurrentPatient(patient) {
          this.currentPatient = patient;
        },
        setSwitchPatient(switchPatient) {
          this.switchPatient = switchPatient;
        },
        setSummaryContent(summary) {
          this.summaryContent = summary;
        },
        setRawReport(report) {
          this.rawReport = report;
        }
      }
    });
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    const _sfc_main$9 = {
      name: "CanvasControler",
      components: {},
      data() {
        return {
          canvas: Object,
          canvasEraser: false,
          canvasDisable: false,
          canvasLine: 5,
          canvasBackgroundImages: [],
          canvasBackgroundId: 0,
          strokes: [],
          btnStatus: "UNDEFINED",
          // "UNDEFINED" "CONNECTING" "OPEN" "CLOSING" "CLOSED"
          resultText: "",
          resultTextTemp: "",
          seconds: 60,
          isSwitching: false
        };
      },
      mounted() {
        const canvasStore = useDrawPanelStore();
        this.mediaRecordingStore = useMediaRecordingStore();
        this.patientInfoStore = usePatientInfoStore();
        this.canvasStore = canvasStore;
        this.canvas = canvasStore.canvasRef;
        this.canvasEraser = canvasStore.canvasEraser;
        this.canvasDisable = canvasStore.canvasDisable;
        this.canvasLine = canvasStore.canvasLine;
        this.APIKey = "8b82b9730a2c117f3deccc41ee7dd2c4";
        this.APISecret = "Mzg5OWNmNDMxODk5MDNiMzIyNWZmMDdm";
        this.APPID = "8301bc30";
        this.chunks = [];
        this.recorder = null;
        this.iatWS = null;
        this.countdownInterval = null;
        const script = document.createElement("script");
        script.src = "/recorderTools/index.umd.js";
        script.onload = () => {
          this.recorder = new window.RecorderManager("/recorderTools");
          this.setupRecorderEvents();
        };
        document.head.appendChild(script);
        this.spaceDown = false;
        const hidebtn = document.getElementById("hidebtn");
        hidebtn.addEventListener("mousedown", this.hideStroke);
        hidebtn.addEventListener("mouseup", this.showStroke);
        window.addEventListener("keydown", this.handleKeyDown);
        window.addEventListener("keyup", this.handleKeyUp);
      },
      destroyed() {
        const hidebtn = document.getElementById("hidebtn");
        hidebtn.removeEventListener("mousedown", this.hideStroke);
        hidebtn.removeEventListener("mouseup", this.showStroke);
        if (this.countdownInterval) {
          clearInterval(this.countdownInterval);
        }
        if (this.recorder) {
          this.recorder.stop();
        }
        if (this.iatWS) {
          this.iatWS.close();
        }
      },
      methods: {
        hideStroke() {
          this.strokes = this.canvas.getAllStrokes();
          this.canvas.reset();
        },
        showStroke() {
          this.canvas.images = [].concat(this.canvas.images, this.strokes);
          this.canvas.redraw(true);
        },
        onDisableChange() {
          this.canvasDisable = !this.canvasDisable;
          this.canvasStore.setCanvasDisable(this.canvasDisable);
        },
        onEraserChange() {
          this.canvasEraser = !this.canvasEraser;
          this.canvasStore.setCanvasEraser(this.canvasEraser);
        },
        onLineChange() {
          this.canvasStore.setCanvasLine(this.canvasLine);
        },
        openConfigWin() {
          window.api.invoke("renderer-to-main", {
            name: "create-config",
            event: "event",
            data: {}
          });
        },
        getWebSocketUrl() {
          const url = "wss://iat-api.xfyun.cn/v2/iat";
          const host = "iat-api.xfyun.cn";
          const date = (/* @__PURE__ */ new Date()).toGMTString();
          const algorithm = "hmac-sha256";
          const headers = "host date request-line";
          const signatureOrigin = `host: ${host}
date: ${date}
GET /v2/iat HTTP/1.1`;
          const signatureSha = window.CryptoJS.HmacSHA256(signatureOrigin, this.APISecret);
          const signature = window.CryptoJS.enc.Base64.stringify(signatureSha);
          const authorizationOrigin = `api_key="${this.APIKey}", algorithm="${algorithm}", headers="${headers}", signature="${signature}"`;
          const authorization = btoa(authorizationOrigin);
          return `${url}?authorization=${authorization}&date=${date}&host=${host}`;
        },
        toBase64(buffer) {
          let binary = "";
          const bytes = new Uint8Array(buffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return window.btoa(binary);
        },
        countdown() {
          this.seconds = 60;
          this.countdownInterval = setInterval(() => {
            this.seconds -= 1;
            if (this.seconds <= 0) {
              clearInterval(this.countdownInterval);
              this.recorder.stop();
            }
          }, 1e3);
        },
        getBtnText() {
          const status = this.btnStatus;
          if (status === "UNDEFINED" || status === "CLOSED") {
            return "PressSpeaking";
          } else if (status === "CONNECTING" || status === "CLOSING") {
            return status;
          } else if (status === "OPEN") {
            return this.seconds;
          } else {
            return "开始录音";
          }
        },
        changeBtnStatus(status) {
          this.btnStatus = status;
          if (status === "CONNECTING") {
            this.resultText = "";
            this.resultTextTemp = "";
          } else if (status === "OPEN") {
            this.countdown();
          }
        },
        renderResult(resultData) {
          const jsonData = JSON.parse(resultData);
          if (jsonData.data && jsonData.data.result) {
            const data = jsonData.data.result;
            let str = "";
            const ws = data.ws;
            for (let i = 0; i < ws.length; i++) {
              str = str + ws[i].cw[0].w;
            }
            if (data.pgs) {
              if (data.pgs === "apd") {
                this.resultText = this.resultTextTemp;
              }
              this.resultTextTemp = this.resultText + str;
            } else {
              this.resultText = this.resultText + str;
            }
            this.mediaRecordingStore.setRecognizedText(this.resultTextTemp || this.resultText || "");
          }
          if (jsonData.code === 0 && jsonData.data.status === 2) {
            this.iatWS.close();
          }
          if (jsonData.code !== 0) {
            this.iatWS.close();
            console.error(jsonData);
          }
        },
        connectWebSocket() {
          const websocketUrl = this.getWebSocketUrl();
          if ("WebSocket" in window) {
            this.iatWS = new WebSocket(websocketUrl);
          } else if ("MozWebSocket" in window) {
            this.iatWS = new MozWebSocket(websocketUrl);
          } else {
            alert("浏览器不支持WebSocket");
            return;
          }
          this.changeBtnStatus("CONNECTING");
          this.iatWS.onopen = (e) => {
            this.recorder.start({
              sampleRate: 16e3,
              frameSize: 1280
            });
            const params = {
              common: {
                app_id: this.APPID
              },
              business: {
                language: "zh_cn",
                domain: "iat",
                accent: "mandarin",
                vad_eos: 5e3,
                dwa: "wpgs"
              },
              data: {
                status: 0,
                format: "audio/L16;rate=16000",
                encoding: "raw"
              }
            };
            this.iatWS.send(JSON.stringify(params));
            this.mediaRecordingStore.toggleFinishRecording();
          };
          this.iatWS.onmessage = (e) => {
            this.renderResult(e.data);
          };
          this.iatWS.onerror = (e) => {
            console.error(e);
            this.recorder.stop();
            this.changeBtnStatus("CLOSED");
          };
          this.iatWS.onclose = (e) => {
            this.recorder.stop();
            this.changeBtnStatus("CLOSED");
            this.mediaRecordingStore.toggleFinishRecording();
          };
        },
        setupRecorderEvents() {
          this.recorder.onStart = () => {
            this.changeBtnStatus("OPEN");
          };
          this.recorder.onFrameRecorded = ({ isLastFrame, frameBuffer }) => {
            if (this.iatWS && this.iatWS.readyState === this.iatWS.OPEN) {
              this.iatWS.send(
                JSON.stringify({
                  data: {
                    status: isLastFrame ? 2 : 1,
                    format: "audio/L16;rate=16000",
                    encoding: "raw",
                    audio: this.toBase64(frameBuffer)
                  }
                })
              );
              if (isLastFrame) {
                this.changeBtnStatus("CLOSING");
              }
            }
          };
          this.recorder.onStop = () => {
            clearInterval(this.countdownInterval);
          };
        },
        toggleRecording() {
          if (this.btnStatus === "UNDEFINED" || this.btnStatus === "CLOSED") {
            this.connectWebSocket();
          } else if (this.btnStatus === "CONNECTING" || this.btnStatus === "OPEN") {
            this.recorder.stop();
          }
        },
        setImage(event) {
          const files = Array.from(event.target.files);
          if (!files.length) return;
          this.canvasBackgroundImages = [];
          const folderName = files[0].webkitRelativePath?.split("/")[0] || "未知文件夹";
          this.patientInfoStore.setCurrentPatient(folderName);
          const imgFiles = files.filter((file) => file.type.startsWith("image/"));
          let URL = window.URL;
          for (let i = 0; i < imgFiles.length; ++i) {
            const file = URL.createObjectURL(imgFiles[i]);
            this.canvasBackgroundImages.push(file);
          }
          console.log("pre:", this.patientInfoStore.switchPatient);
          this.patientInfoStore.setSwitchPatient(true);
          console.log("after:", this.patientInfoStore.switchPatient);
          this.canvasStore.setCanvasBackgroundID(0);
          this.canvasStore.setCanvasBackground(this.canvasBackgroundImages[0]);
          this.canvasBackgroundId = 0;
        },
        _loadPreviousImage() {
          if (this.canvasBackgroundId - 1 < 0) return;
          if (this.isSwitching) return;
          this.isSwitching = true;
          let idex = --this.canvasBackgroundId;
          this.canvasStore.setCanvasBackground(this.canvasBackgroundImages[idex]);
          this.canvasStore.setCanvasBackgroundID(idex);
          setTimeout(() => {
            this.isSwitching = false;
          }, 500);
        },
        _loadNextImage() {
          if (this.canvasBackgroundId + 1 >= this.canvasBackgroundImages.length) return;
          if (this.isSwitching) return;
          this.isSwitching = true;
          let idex = ++this.canvasBackgroundId;
          this.canvasStore.setCanvasBackground(this.canvasBackgroundImages[idex]);
          this.canvasStore.setCanvasBackgroundID(idex);
          setTimeout(() => {
            this.isSwitching = false;
          }, 500);
        },
        loadPreviousImage: debounce(function() {
          this._loadPreviousImage();
        }, 300),
        loadNextImage: debounce(function() {
          this._loadNextImage();
        }, 300),
        exportImage() {
          const link = document.createElement("a");
          link.href = this.canvasStore.currentImgURL;
          link.download = "image.png";
          link.click();
        },
        handleKeyDown(event) {
          const active = document.activeElement;
          if (active && active.tagName.toLowerCase() === "textarea") return;
          if (event.key === " " || event.key === "Spacebar") {
            event.preventDefault();
            if (!this.spaceDown) {
              this.spaceDown = true;
              this.toggleRecording();
            }
          }
        },
        handleKeyUp(event) {
          const active = document.activeElement;
          if (active && active.tagName.toLowerCase() === "textarea") return;
          if ((event.key === " " || event.key === "Spacebar") && this.spaceDown) {
            this.spaceDown = false;
            this.toggleRecording();
          }
        }
      }
    };
    const _hoisted_1$4 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-lock",
      viewBox: "0 0 16 16"
    };
    const _hoisted_2$1 = {
      key: 0,
      d: "M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"
    };
    const _hoisted_3$1 = {
      key: 1,
      d: "M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"
    };
    const _hoisted_4$1 = { key: 0 };
    const _hoisted_5 = { key: 1 };
    const _hoisted_6 = { key: 0 };
    const _hoisted_7 = { key: 1 };
    const _hoisted_8 = { class: "slider-demo-block" };
    const _hoisted_9 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-arrow-left-square",
      viewBox: "0 0 16 16",
      style: { "margin": "3px" }
    };
    const _hoisted_10 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-folder",
      viewBox: "0 0 16 16",
      style: { "margin": "3px" }
    };
    const _hoisted_11 = {
      key: 0,
      style: { "display": "inline-flex", "align-items": "center" }
    };
    const _hoisted_12 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-play-circle",
      viewBox: "0 0 16 16",
      style: { "margin": "3px" }
    };
    const _hoisted_13 = { key: 1 };
    const _hoisted_14 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-file-earmark-richtext",
      viewBox: "0 0 16 16",
      style: { "margin": "3px" }
    };
    const _hoisted_15 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      fill: "currentColor",
      class: "bi bi-arrow-right-square",
      viewBox: "0 0 16 16",
      style: { "margin": "3px" }
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_col = ElCol;
      const _component_el_slider = ElSlider;
      const _component_el_row = ElRow;
      const _component_el_button = ElButton;
      const _component_el_button_group = ElButtonGroup;
      return openBlock(), createBlock(_component_el_col, {
        span: 24,
        class: "btn-panel style-color-3"
      }, {
        default: withCtx(() => [
          createVNode(_component_el_row, { span: 24 }, {
            default: withCtx(() => [
              createVNode(_component_el_col, {
                span: 3,
                justify: "center"
              }, {
                default: withCtx(() => _cache[12] || (_cache[12] = [
                  createBaseVNode("button", {
                    type: "button",
                    id: "hidebtn",
                    class: "canvas-button"
                  }, [
                    createBaseVNode("svg", {
                      xmlns: "http://www.w3.org/2000/svg",
                      width: "24",
                      height: "24",
                      fill: "currentColor",
                      class: "bi bi-eye-slash",
                      viewBox: "0 0 16 16"
                    }, [
                      createBaseVNode("path", { d: "M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7 7 0 0 0-2.79.588l.77.771A6 6 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13 13 0 0 1 14.828 8q-.086.13-.195.288c-.335.48-.83 1.12-1.465 1.755q-.247.248-.517.486z" }),
                      createBaseVNode("path", { d: "M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829" }),
                      createBaseVNode("path", { d: "M3.35 5.47q-.27.24-.518.487A13 13 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7 7 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12z" })
                    ]),
                    createBaseVNode("span", { style: { "margin-left": "2px" } }, "Hide")
                  ], -1)
                ])),
                _: 1
              }),
              createVNode(_component_el_col, {
                span: 3,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.onDisableChange(), ["prevent"])),
                    class: "canvas-button"
                  }, [
                    (openBlock(), createElementBlock("svg", _hoisted_1$4, [
                      !$data.canvasDisable ? (openBlock(), createElementBlock("path", _hoisted_2$1)) : (openBlock(), createElementBlock("path", _hoisted_3$1))
                    ])),
                    !$data.canvasDisable ? (openBlock(), createElementBlock("span", _hoisted_4$1, "Lock")) : (openBlock(), createElementBlock("span", _hoisted_5, "Unlock"))
                  ])
                ]),
                _: 1
              }),
              createVNode(_component_el_col, {
                span: 3,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $data.canvas.undo(), ["prevent"])),
                    class: "canvas-button"
                  }, _cache[13] || (_cache[13] = [
                    createBaseVNode("svg", {
                      xmlns: "http://www.w3.org/2000/svg",
                      width: "24",
                      height: "24",
                      fill: "currentColor",
                      class: "bi bi-arrow-counterclockwise",
                      viewBox: "0 0 16 16"
                    }, [
                      createBaseVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"
                      }),
                      createBaseVNode("path", { d: "M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z" })
                    ], -1),
                    createTextVNode(" Undo ")
                  ]))
                ]),
                _: 1
              }),
              createVNode(_component_el_col, {
                span: 3,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $data.canvas.reset(), ["prevent"])),
                    class: "canvas-button"
                  }, _cache[14] || (_cache[14] = [
                    createBaseVNode("svg", {
                      xmlns: "http://www.w3.org/2000/svg",
                      width: "24",
                      height: "24",
                      fill: "currentColor",
                      class: "bi bi-file-earmark",
                      viewBox: "0 0 16 16"
                    }, [
                      createBaseVNode("path", { d: "M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z" })
                    ], -1),
                    createTextVNode(" Clear ")
                  ]))
                ]),
                _: 1
              }),
              createVNode(_component_el_col, {
                span: 3,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("button", {
                    type: "button",
                    onClick: _cache[3] || (_cache[3] = withModifiers(($event) => $options.onEraserChange(), ["prevent"])),
                    class: "canvas-button"
                  }, [
                    $data.canvasEraser ? (openBlock(), createElementBlock("span", _hoisted_6, _cache[15] || (_cache[15] = [
                      createBaseVNode("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "24",
                        height: "24",
                        fill: "currentColor",
                        class: "bi bi-pencil",
                        viewBox: "0 0 16 16"
                      }, [
                        createBaseVNode("path", { d: "M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z" })
                      ], -1),
                      createTextVNode(" Draw ")
                    ]))) : (openBlock(), createElementBlock("span", _hoisted_7, _cache[16] || (_cache[16] = [
                      createBaseVNode("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "24",
                        height: "24",
                        fill: "currentColor",
                        class: "bi bi-eraser",
                        viewBox: "0 0 16 16"
                      }, [
                        createBaseVNode("path", { d: "M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z" })
                      ], -1),
                      createTextVNode(" Eraser ")
                    ])))
                  ])
                ]),
                _: 1
              }),
              createVNode(_component_el_col, {
                span: 9,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_8, [
                    _cache[17] || (_cache[17] = createBaseVNode("span", { class: "demonstration" }, "Size", -1)),
                    createVNode(_component_el_slider, {
                      modelValue: $data.canvasLine,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.canvasLine = $event),
                      step: 5,
                      min: 5,
                      max: 51,
                      "show-stops": "",
                      onInput: _cache[5] || (_cache[5] = ($event) => $options.onLineChange())
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_row, {
            span: 24,
            justify: "center"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_col, { span: 20 }, {
                default: withCtx(() => [
                  createVNode(_component_el_button_group, { class: "btn-group" }, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "default",
                        size: "large",
                        round: "",
                        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => $options.loadPreviousImage(), ["prevent"]))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createElementBlock("svg", _hoisted_9, _cache[18] || (_cache[18] = [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M15 2a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1zM0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm11.5 5.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5z"
                            }, null, -1)
                          ]))),
                          _cache[19] || (_cache[19] = createBaseVNode("span", null, "Previous", -1))
                        ]),
                        _: 1
                      }),
                      createBaseVNode("input", {
                        ref: "fileInput",
                        type: "file",
                        webkitdirectory: "",
                        directory: "",
                        onChange: _cache[7] || (_cache[7] = (...args) => $options.setImage && $options.setImage(...args)),
                        style: { "display": "none" }
                      }, null, 544),
                      createVNode(_component_el_button, {
                        type: "default",
                        size: "large",
                        round: "",
                        onClick: _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.$refs.fileInput.click(), ["prevent"]))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createElementBlock("svg", _hoisted_10, _cache[20] || (_cache[20] = [
                            createBaseVNode("path", { d: "M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a2 2 0 0 1 .342-1.31zM2.19 4a1 1 0 0 0-.996 1.09l.637 7a1 1 0 0 0 .995.91h10.348a1 1 0 0 0 .995-.91l.637-7A1 1 0 0 0 13.81 4zm4.69-1.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139q.323-.119.684-.12h5.396z" }, null, -1)
                          ]))),
                          _cache[21] || (_cache[21] = createBaseVNode("span", null, "Import", -1))
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, {
                        type: "default",
                        size: "large",
                        round: "",
                        class: "speaking-btn",
                        onMousedown: $options.toggleRecording,
                        onMouseup: $options.toggleRecording
                      }, {
                        default: withCtx(() => [
                          this.getBtnText() === "PressSpeaking" ? (openBlock(), createElementBlock("span", _hoisted_11, [
                            _cache[23] || (_cache[23] = createBaseVNode("span", null, "Press", -1)),
                            (openBlock(), createElementBlock("svg", _hoisted_12, _cache[22] || (_cache[22] = [
                              createBaseVNode("path", { d: "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16" }, null, -1),
                              createBaseVNode("path", { d: "M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445" }, null, -1)
                            ]))),
                            _cache[24] || (_cache[24] = createBaseVNode("span", null, "Speaking", -1))
                          ])) : (openBlock(), createElementBlock("span", _hoisted_13, [
                            createBaseVNode("span", null, toDisplayString($options.getBtnText()), 1)
                          ]))
                        ]),
                        _: 1
                      }, 8, ["onMousedown", "onMouseup"]),
                      createVNode(_component_el_button, {
                        type: "default",
                        size: "large",
                        round: "",
                        onClick: _cache[9] || (_cache[9] = withModifiers(($event) => $options.exportImage(), ["prevent"]))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createElementBlock("svg", _hoisted_14, _cache[25] || (_cache[25] = [
                            createBaseVNode("path", { d: "M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5z" }, null, -1),
                            createBaseVNode("path", { d: "M4.5 12.5A.5.5 0 0 1 5 12h3a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5m0-2A.5.5 0 0 1 5 10h6a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5m1.639-3.708 1.33.886 1.854-1.855a.25.25 0 0 1 .289-.047l1.888.974V8.5a.5.5 0 0 1-.5.5H5a.5.5 0 0 1-.5-.5V8s1.54-1.274 1.639-1.208M6.25 6a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" }, null, -1)
                          ]))),
                          _cache[26] || (_cache[26] = createBaseVNode("span", null, "Export", -1))
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, {
                        type: "default",
                        size: "large",
                        round: "",
                        onClick: _cache[10] || (_cache[10] = withModifiers(($event) => $options.loadNextImage(), ["prevent"]))
                      }, {
                        default: withCtx(() => [
                          _cache[28] || (_cache[28] = createBaseVNode("span", null, "Next", -1)),
                          (openBlock(), createElementBlock("svg", _hoisted_15, _cache[27] || (_cache[27] = [
                            createBaseVNode("path", {
                              "fill-rule": "evenodd",
                              d: "M15 2a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1zM0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm4.5 5.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5z"
                            }, null, -1)
                          ])))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_row, {
            span: 24,
            style: { "margin-top": "10px" }
          }, {
            default: withCtx(() => [
              createVNode(_component_el_col, { span: 20 }, {
                default: withCtx(() => [
                  createVNode(_component_el_row, { style: { "font-size": "14px" } }, {
                    default: withCtx(() => _cache[29] || (_cache[29] = [
                      createTextVNode("1. Press Import Button to Select the medical image folder.")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_row, { style: { "font-size": "14px" } }, {
                    default: withCtx(() => _cache[30] || (_cache[30] = [
                      createTextVNode("2. Press Previous/Next Button to move forward/backward in the medical image list.")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_row, { style: { "font-size": "14px" } }, {
                    default: withCtx(() => _cache[31] || (_cache[31] = [
                      createTextVNode("3. Press Export Button to generate PDF report.")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_row, { style: { "font-size": "14px" } }, {
                    default: withCtx(() => _cache[32] || (_cache[32] = [
                      createTextVNode("4. Labeled Image will saved automatically.")
                    ])),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_col, { span: 4 }, {
                default: withCtx(() => [
                  createVNode(_component_el_row, {
                    span: 24,
                    justify: "end",
                    style: { "padding": "10px" }
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        size: "large",
                        style: { "height": "60px", "width": "60px" },
                        round: "",
                        onClick: _cache[11] || (_cache[11] = ($event) => $options.openConfigWin())
                      }, {
                        default: withCtx(() => _cache[33] || (_cache[33] = [
                          createBaseVNode("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            width: "32",
                            height: "32",
                            fill: "currentColor",
                            class: "bi bi-gear",
                            viewBox: "0 0 16 16"
                          }, [
                            createBaseVNode("path", { d: "M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492M5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0" }),
                            createBaseVNode("path", { d: "M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115z" })
                          ], -1)
                        ])),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const ControlPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$3], ["__scopeId", "data-v-e690c942"]]);
    const canvasWidth = ref(window.innerWidth * 0.68);
    const canvasHeight = ref(canvasWidth.value / 16 * 9);
    const _sfc_main$8 = {
      name: "DrawCanvas",
      components: {
        VueDrawCanvas,
        ControlPanle: ControlPanel
      },
      data() {
        return {
          initialImage: [],
          width: canvasWidth,
          height: canvasHeight,
          x: 0,
          y: 0,
          image: "",
          eraser: false,
          disabled: false,
          fillShape: false,
          line: 5,
          color: "#00FF00",
          strokeType: "dash",
          lineCap: "round",
          lineJoin: "round",
          backgroundColor: "#FFFFFF",
          backgroundImage: "",
          watermark: null,
          additionalImages: [],
          imageSrc: "",
          currentImgURL: "",
          canvasStore: null,
          previousBackgroundID: 0,
          currentBackgroundID: 0,
          history: {},
          currentPatient: "blank",
          previousPatient: "blank",
          patientInfoStore: null,
          canvasActive: false
        };
      },
      computed: {
        canvasEraser() {
          const store = useDrawPanelStore();
          return store.canvasEraser;
        },
        canvasDisabled() {
          const store = useDrawPanelStore();
          return store.canvasDisable;
        },
        canvasLine() {
          const store = useDrawPanelStore();
          return store.canvasLine;
        },
        canvasPatient() {
          const store = usePatientInfoStore();
          return store.currentPatient;
        },
        canvasBackground() {
          const store = useDrawPanelStore();
          return store.canvasBackground;
        },
        patientRawReport() {
          const store = usePatientInfoStore();
          return store.rawReport;
        },
        patientSummay() {
          const store = usePatientInfoStore();
          return store.summaryContent;
        }
      },
      watch: {
        // Watch the computed property for changes and update the data property
        canvasEraser(newValue) {
          this.eraser = newValue;
        },
        canvasDisabled(newValue) {
          this.disabled = newValue;
        },
        canvasLine(newValue) {
          this.line = newValue;
        },
        canvasPatient(newValue) {
          this.previousPatient = this.currentPatient;
          this.currentPatient = newValue;
        },
        async canvasBackground(newValue) {
          this.previousBackgroundID = this.currentBackgroundID;
          this.currentBackgroundID = this.canvasStore.canvasBackgroundID;
          if (this.patientInfoStore.switchPatient) {
            this.saveReportData(this.previousPatient, this.previousBackgroundID);
            this.saveCanvasData(this.previousPatient, this.previousBackgroundID);
          } else this.saveCanvasData(this.currentPatient, this.previousBackgroundID);
          this.$refs.VueCanvasDrawing.reset();
          if (newValue) {
            const fitImg = await this.resizeImageToFitCanvas(
              newValue,
              this.width,
              this.height
            );
            this.backgroundImage = fitImg;
          } else {
            this.backgroundImage = "";
          }
          await this.$refs.VueCanvasDrawing.redraw(true);
          await this.$nextTick();
          await this.loadCanvasData(this.currentPatient, this.currentBackgroundID);
          await this.$refs.VueCanvasDrawing.redraw(true);
        },
        patientRawReport(newVal) {
          this.saveReportData(this.currentPatient, this.currentBackgroundID);
        },
        patientSummay(newVal) {
          console.log("summary");
          this.saveReportData(this.currentPatient, this.currrentBackgroundID);
        }
      },
      mounted() {
        this.canvasStore = useDrawPanelStore();
        this.canvasStore.setCanvasRef(this.$refs.VueCanvasDrawing);
        this.patientInfoStore = usePatientInfoStore();
        document.addEventListener("keydown", this.handleKeyDown);
        this.$nextTick(() => {
          const canvasEl = this.$el.querySelector("canvas");
          if (canvasEl) canvasEl.setAttribute("tabindex", "0");
        });
      },
      destroyed() {
        document.removeEventListener("keydown", this.handleKeyDown);
      },
      methods: {
        getCoordinate(event) {
          let coordinates = this.$refs.VueCanvasDrawing.getCoordinates(event);
          this.x = coordinates.x;
          this.y = coordinates.y;
        },
        resizeImageToFitCanvas(imageUrl, canvasWidth2, canvasHeight2) {
          return new Promise((resolve2, reject) => {
            const img = new window.Image();
            img.crossOrigin = "anonymous";
            img.onload = function() {
              const canvas = document.createElement("canvas");
              canvas.width = canvasWidth2;
              canvas.height = canvasHeight2;
              const ctx = canvas.getContext("2d");
              const scale = Math.min(
                canvasWidth2 / img.width,
                canvasHeight2 / img.height
              );
              const newWidth = img.width * scale;
              const newHeight = img.height * scale;
              const offsetX = (canvasWidth2 - newWidth) / 2;
              const offsetY = (canvasHeight2 - newHeight) / 2;
              ctx.fillStyle = "#fff";
              ctx.fillRect(0, 0, canvasWidth2, canvasHeight2);
              ctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
              resolve2(canvas.toDataURL());
            };
            img.onerror = reject;
            img.src = imageUrl;
          });
        },
        onImageUpdate(URL) {
          if (this.canvasStore) this.canvasStore.setCurrentImgURL(URL);
        },
        saveCanvasData(patient, id) {
          const drawer = this.$refs.VueCanvasDrawing;
          const canvasStrokes = JSON.parse(JSON.stringify(drawer.getAllStrokes()));
          const canvasImages = JSON.parse(JSON.stringify(drawer.images));
          const canvasTrash = JSON.parse(JSON.stringify(drawer.trash));
          this.history[id] = {
            strokes: canvasStrokes,
            images: canvasImages,
            trash: canvasTrash
          };
          window.api.invoke("renderer-to-main", {
            name: "save-history",
            event: "cevent",
            data: {
              "patient": patient,
              "history": JSON.parse(JSON.stringify(this.history))
            }
          });
        },
        saveReportData(patient, id) {
          window.api.invoke("renderer-to-main", {
            name: "save-report",
            event: "cevent",
            data: {
              "patient": patient,
              "report": {
                "rawReport": this.patientInfoStore.rawReport,
                "summary": this.patientInfoStore.summaryContent
              }
            }
          });
        },
        async loadCanvasData(patient, id) {
          this.history = await window.api.invoke("renderer-to-main-async", {
            name: "load-history",
            event: "asyncevent",
            data: {
              "patient": patient
            }
          });
          const drawer = this.$refs.VueCanvasDrawing;
          const canvasData = this.history[id] || {
            strokes: [],
            images: [],
            trash: []
          };
          drawer.images = [].concat(canvasData.images, drawer.images);
          drawer.trash = canvasData.trash;
        },
        handleKeyDown(event) {
          if (event.ctrlKey) {
            const drawer = this.$refs.VueCanvasDrawing;
            if (event.key === "s" || event.ket === "S") {
              this.saveCanvasData(this.currentPatient, this.currentBackgroundID);
              this.saveReportData(this.currentPatient, this.currentBackgroundID);
            }
            if (!this.canvasActive) return;
            if (event.key === "z" || event.key === "Z") drawer.undo();
            if (event.key === "y" || event.key === "Y") drawer.redo();
          }
        },
        canvasFocus() {
          this.canvasActive = true;
        },
        canvasBlur() {
          this.canvasActive = false;
        }
      }
    };
    const _hoisted_1$3 = { class: "canvas" };
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_VueDrawCanvas = resolveComponent("VueDrawCanvas");
      const _component_el_row = ElRow;
      const _component_el_col = ElCol;
      return openBlock(), createBlock(_component_el_col, { span: 24 }, {
        default: withCtx(() => [
          createVNode(_component_el_row, {
            span: 24,
            justify: "center",
            class: "canvas-panel"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$3, [
                createVNode(_component_VueDrawCanvas, {
                  ref: "VueCanvasDrawing",
                  image: $data.image,
                  "onUpdate:image": [
                    _cache[0] || (_cache[0] = ($event) => $data.image = $event),
                    $options.onImageUpdate
                  ],
                  width: $data.width,
                  height: $data.height,
                  "stroke-type": $data.strokeType,
                  "line-cap": $data.lineCap,
                  "line-join": $data.lineJoin,
                  "fill-shape": $data.fillShape,
                  eraser: $data.eraser,
                  lineWidth: $data.line,
                  color: $data.color,
                  "background-color": $data.backgroundColor,
                  "background-image": $data.backgroundImage,
                  watermark: $data.watermark,
                  "initial-image": $data.initialImage,
                  saveAs: "png",
                  "output-width": $data.width,
                  "output-height": $data.height,
                  styles: {
                    border: "solid 1px #000"
                  },
                  lock: $data.disabled,
                  onMousemove: _cache[1] || (_cache[1] = ($event) => $options.getCoordinate($event)),
                  "additional-images": $data.additionalImages,
                  onFocus: $options.canvasFocus,
                  onBlur: $options.canvasBlur
                }, null, 8, ["image", "width", "height", "stroke-type", "line-cap", "line-join", "fill-shape", "eraser", "lineWidth", "color", "background-color", "background-image", "watermark", "initial-image", "output-width", "output-height", "lock", "additional-images", "onUpdate:image", "onFocus", "onBlur"])
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const DrawPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$2], ["__scopeId", "data-v-bc68f297"]]);
    const _sfc_main$7 = {
      __name: "DrawingPanel",
      setup(__props) {
        return (_ctx, _cache) => {
          const _component_el_col = ElCol;
          return openBlock(), createBlock(_component_el_col, { span: 24 }, {
            default: withCtx(() => [
              createVNode(DrawPanel),
              createVNode(ControlPanel)
            ]),
            _: 1
          });
        };
      }
    };
    const useTestListStore = /* @__PURE__ */ defineStore("testList", {
      state: () => ({
        testListOptions: [],
        testList: []
      }),
      getters: {
        getList() {
          return self.testList;
        },
        getTestOptions() {
          return self.testListOptions;
        }
      },
      actions: {
        setList(ref2) {
          this.testList = ref2;
          this.testListOptions = ref2.reduce((acc, item, index) => {
            acc[index] = {
              "key": item,
              "value": item,
              "label": item.split(".")[0]
            };
            return acc;
          }, {});
        }
      }
    });
    const usePointStore = /* @__PURE__ */ defineStore("points", {
      state: () => ({
        points: []
      }),
      getters: {
        getPoints() {
          return self.points;
        }
      },
      actions: {
        setPoints(ref2) {
          this.points = ref2;
        }
      }
    });
    const _hoisted_1$2 = { class: "keypoints-container" };
    const _hoisted_2 = { class: "status-indicator" };
    const _hoisted_3 = { class: "scrollbar-item" };
    const _hoisted_4 = { style: { "font-size": "large" } };
    const _sfc_main$6 = {
      __name: "ReportPanel",
      setup(__props) {
        useCssVars((_ctx) => ({
          "25ef3070": scrollbar_max.value
        }));
        const summary_area = ref("");
        const recording_area = ref("");
        const prev_recording = ref("");
        const activeName = ref("first");
        const scrollbar_max = ref(Math.floor(window.innerHeight * 0.42) + "px");
        const chosenTest = reactive({
          testName: ""
        });
        const testListStore = useTestListStore();
        const testListOptions = computed(() => testListStore.testListOptions);
        const pointsStore = usePointStore();
        const checkPoints = computed(() => pointsStore.points);
        const mediaRecordingStore = useMediaRecordingStore();
        const patientInfoStore = usePatientInfoStore();
        const updateStatus = ref("Unload");
        let timer = null;
        function addTest() {
          window.api.invoke("renderer-to-main", {
            name: "create-addcat",
            event: "event",
            data: {}
          });
        }
        function getStatusClass(required) {
          return required === "required" ? "red" : required === "done" ? "green" : "yellow";
        }
        function getSummaryDescription() {
          if (recording_area.value != "") return "Waiting for response...";
          return "Waiting for your speaking";
        }
        async function loadPoints() {
          const points = await window.api.invoke("renderer-to-main-async", {
            name: "load-points",
            event: "asyncevent",
            data: {
              "teatName": chosenTest.testName
            }
          });
          if ("error" in points) {
            alert("Load Points File Failed");
          } else {
            pointsStore.setPoints(points);
            if (updateStatus != "Updating") updateStatus.value = "Loaded";
            updateKeypoints();
          }
        }
        async function summarize() {
          const points = pointsStore.points;
          const userText = {
            "report": recording_area.value,
            "keypoints": points.reduce((acc, item) => {
              acc.push({
                "title": item.title,
                "importance": item.importance,
                "explanation": item.explanation
              });
              return acc;
            }, [])
          };
          const messages2 = [
            { "role": "user", "content": JSON.stringify(userText) }
          ];
          const res = await window.api.invoke("renderer-to-main-async", {
            name: "summarize-chat",
            event: "asyncevent",
            data: {
              "apiURL": window.localStorage.getItem("apiURL"),
              "apiKEY": window.localStorage.getItem("apiKEY"),
              "request": {
                model: window.localStorage.getItem("MODEL"),
                messages: messages2
              }
            }
          });
          try {
            const regex = /<json>([\s\S]*?)<\/json>/;
            const match = res.match(regex);
            const res_json = JSON.parse(match[1]);
            return res_json["summary"];
          } catch (error) {
            console.error("Parse json failed: ", error);
          }
          return "Failed to parse JSON";
        }
        async function updateKeypoints() {
          if (updateStatus.value == "Unload" || updateStatus.value == "Updating" || recording_area.value == "") {
            return;
          }
          updateStatus.value = "Updating";
          const points = pointsStore.points;
          const userText = {
            "report": recording_area.value,
            "keypoints": points.reduce((acc, item) => {
              acc.push({
                "title": item.title,
                "importance": item.importance,
                "explanation": item.explanation
              });
              return acc;
            }, [])
          };
          const messages2 = [
            { "role": "user", "content": JSON.stringify(userText) }
          ];
          const res = await window.api.invoke("renderer-to-main-async", {
            name: "updkeys-chat",
            event: "asyncevent",
            data: {
              "apiURL": window.localStorage.getItem("apiURL"),
              "apiKEY": window.localStorage.getItem("apiKEY"),
              "request": {
                model: window.localStorage.getItem("MODEL"),
                messages: messages2
              }
            }
          });
          try {
            const regex = /<json>([\s\S]*?)<\/json>/;
            const match = res.match(regex);
            const res_json = JSON.parse(match[1]);
            pointsStore.setPoints(res_json["key_points"]);
            updateStatus.value = "Updated";
          } catch (error) {
            console.error("Parse json failed: ", error);
          }
        }
        watch(
          () => mediaRecordingStore.recognizedText,
          (newVal) => {
            recording_area.value = prev_recording.value + (newVal || "");
          }
        );
        watch(
          () => mediaRecordingStore.finishRecording,
          (newVal) => {
            if (newVal === true) {
              prev_recording.value = recording_area.value;
            }
          }
        );
        watch(
          () => activeName.value,
          async (newVal) => {
            if (newVal === "second" && recording_area.value != "") {
              const result = await summarize();
              summary_area.value = result;
              patientInfoStore.setSummaryContent(result);
            }
          }
        );
        watch(
          () => recording_area.value,
          async (newVal) => {
            if (mediaRecordingStore.finishRecording == true) {
              prev_recording.value = newVal;
            }
            patientInfoStore.setRawReport(newVal);
            if (timer) {
              clearTimeout(timer);
            }
            if (newVal != "") {
              timer = setTimeout(() => {
                updateKeypoints();
              }, 2e3);
            }
          }
        );
        watch(
          () => summary_area.value,
          (newVal) => {
            if (newVal != "") {
              patientInfoStore.setSummaryContent(newVal);
            }
          }
        );
        watch(
          () => patientInfoStore.switchPatient,
          async (newVal) => {
            if (newVal) {
              let readReport = await window.api.invoke("renderer-to-main-async", {
                name: "load-report",
                event: "asyncevent",
                data: {
                  "patient": patientInfoStore.currentPatient
                }
              });
              const rawReport = readReport.rawReport;
              recording_area.value = rawReport;
              patientInfoStore.setSwitchPatient(false);
            }
          }
        );
        return (_ctx, _cache) => {
          const _component_el_row = ElRow;
          const _component_el_option = ElOption;
          const _component_el_select = ElSelect;
          const _component_el_col = ElCol;
          const _component_el_button = ElButton;
          const _component_el_form_item = ElFormItem;
          const _component_el_form = ElForm;
          const _component_el_tooltip = ElTooltip;
          const _component_el_scrollbar = ElScrollbar;
          const _component_el_input = ElInput;
          const _component_el_tab_pane = ElTabPane;
          const _component_el_tabs = ElTabs;
          return openBlock(), createBlock(_component_el_col, {
            span: 24,
            class: "style-color-3 report-panel"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_row, {
                span: 24,
                class: "report-aims style-color-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_col, { span: 24 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_row, null, {
                        default: withCtx(() => _cache[4] || (_cache[4] = [
                          createBaseVNode("h1", { style: { "text-align": "left" } }, "Image Catalog Name", -1)
                        ])),
                        _: 1
                      }),
                      createVNode(_component_el_row, { span: 24 }, {
                        default: withCtx(() => [
                          createVNode(_component_el_form, {
                            model: chosenTest,
                            "label-width": "auto",
                            style: { "width": "100%" }
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_form_item, null, {
                                default: withCtx(() => [
                                  createVNode(_component_el_col, { span: 18 }, {
                                    default: withCtx(() => [
                                      createVNode(_component_el_select, {
                                        modelValue: chosenTest.testName,
                                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => chosenTest.testName = $event),
                                        filterable: "",
                                        placeholder: "Please select",
                                        onChange: loadPoints
                                      }, {
                                        default: withCtx(() => [
                                          (openBlock(true), createElementBlock(Fragment, null, renderList(testListOptions.value, (option) => {
                                            return openBlock(), createBlock(_component_el_option, {
                                              key: option.key,
                                              label: option.label,
                                              value: option.value
                                            }, null, 8, ["label", "value"]);
                                          }), 128))
                                        ]),
                                        _: 1
                                      }, 8, ["modelValue"])
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(_component_el_col, { span: 6 }, {
                                    default: withCtx(() => [
                                      createVNode(_component_el_button, {
                                        onClick: addTest,
                                        round: ""
                                      }, {
                                        default: withCtx(() => _cache[5] || (_cache[5] = [
                                          createTextVNode("Add")
                                        ])),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["model"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_row, {
                span: 24,
                "hidden-sm-only": "",
                class: "report-divider"
              }),
              createVNode(_component_el_row, {
                span: 24,
                class: "report-items style-color-2"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_1$2, [
                    _cache[6] || (_cache[6] = createBaseVNode("h1", { class: "keypoints-title" }, "Key Points", -1)),
                    createBaseVNode("div", _hoisted_2, toDisplayString(updateStatus.value), 1)
                  ]),
                  createVNode(_component_el_scrollbar, { class: "scrollbar" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(checkPoints.value, (point) => {
                        return openBlock(), createElementBlock("div", {
                          key: point.title,
                          class: "scrollbar-demo-item"
                        }, [
                          createVNode(_component_el_tooltip, {
                            class: "box-item",
                            effect: "dark",
                            content: point.explanation,
                            placement: "left",
                            "popper-class": "point-tooltip"
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_3, [
                                createBaseVNode("span", {
                                  class: normalizeClass(["status-light", getStatusClass(point.importance)])
                                }, null, 2),
                                createBaseVNode("span", _hoisted_4, toDisplayString(point.title), 1)
                              ])
                            ]),
                            _: 2
                          }, 1032, ["content"])
                        ]);
                      }), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_row, {
                span: 24,
                "hidden-sm-only": "",
                class: "report-divider"
              }),
              createVNode(_component_el_row, {
                span: 24,
                class: "report-summary style-color-2"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_tabs, {
                    modelValue: activeName.value,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => activeName.value = $event),
                    class: "demo-tabs",
                    type: "border-card"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_tab_pane, {
                        label: "Raw Speaking",
                        name: "first",
                        style: { "width": "100%" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: recording_area.value,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => recording_area.value = $event),
                            type: "textarea",
                            resize: "none",
                            autosize: { minRows: 7, maxRows: 7 },
                            placeholder: "Waiting for your speaking"
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_tab_pane, {
                        label: "Auto Summary",
                        name: "second",
                        style: { "width": "100%" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: summary_area.value,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => summary_area.value = $event),
                            type: "textarea",
                            resize: "none",
                            autosize: { minRows: 7, maxRows: 7 },
                            placeholder: getSummaryDescription()
                          }, null, 8, ["modelValue", "placeholder"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          });
        };
      }
    };
    const ReportPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-7621519d"]]);
    const _hoisted_1$1 = { class: "common-layout layout-style" };
    const _sfc_main$5 = {
      __name: "mainWin",
      setup(__props) {
        async function updateTestList() {
          const testList = await window.api.invoke("renderer-to-main-async", {
            name: "testlist-get",
            event: "asyncevent",
            data: {}
          });
          const testListStore = useTestListStore();
          testListStore.setList(testList);
        }
        async function fetchConfig() {
          const _config = await window.api.invoke("renderer-to-main-async", {
            name: "request-config",
            event: "asyncevent",
            data: {}
          });
          for (const [key, value] of Object.entries(_config)) {
            window.localStorage.setItem(key, value);
          }
        }
        updateTestList();
        fetchConfig();
        window.api.onMainMessage((data) => {
          if (data.child === "addcat" && data.action === "closed") {
            updateTestList();
          }
        });
        return (_ctx, _cache) => {
          const _component_el_header = ElHeader;
          const _component_el_col = ElCol;
          const _component_el_row = ElRow;
          const _component_el_main = ElMain;
          const _component_el_footer = ElFooter;
          const _component_el_container = ElContainer;
          return openBlock(), createElementBlock("div", _hoisted_1$1, [
            createVNode(_component_el_container, { class: "layout-style" }, {
              default: withCtx(() => [
                createVNode(_component_el_header, { class: "header style-color-2" }, {
                  default: withCtx(() => _cache[0] || (_cache[0] = [
                    createTextVNode(" Medical Image Labeling Assistant ")
                  ])),
                  _: 1
                }),
                createVNode(_component_el_main, { class: "main-area" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_row, {
                      gutter: 20,
                      class: "main-row"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_col, { span: 18 }, {
                          default: withCtx(() => [
                            createVNode(_sfc_main$7)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_col, { span: 6 }, {
                          default: withCtx(() => [
                            createVNode(ReportPanel)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_el_footer, { class: "footer style-color-2" }, {
                  default: withCtx(() => _cache[1] || (_cache[1] = [
                    createTextVNode(" Copyright@TimberZhang@ISCAS-HCI ")
                  ])),
                  _: 1
                })
              ]),
              _: 1
            })
          ]);
        };
      }
    };
    const mainWindow = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__scopeId", "data-v-b4077fea"]]);
    const _sfc_main$4 = {
      __name: "configWin",
      setup(__props) {
        const configForm = reactive({
          apiURL: "",
          apiKEY: "",
          MODEL: ""
        });
        const isLoading = ref(false);
        const submitForm = () => {
          window.localStorage.setItem("apiURL", configForm.apiURL);
          window.localStorage.setItem("apiKEY", configForm.apiKEY);
          window.localStorage.setItem("MODEL", configForm.MODEL);
          window.api.invoke("renderer-to-main", {
            name: "save-config",
            event: "event",
            data: {
              "apiURL": configForm.apiURL,
              "apiKEY": configForm.apiKEY,
              "MODEL": configForm.MODEL
            }
          });
          alert("Config Saved");
        };
        window.addEventListener("load", () => {
          configForm.apiURL = window.localStorage.getItem("apiURL");
          configForm.apiKEY = window.localStorage.getItem("apiKEY");
          configForm.MODEL = window.localStorage.getItem("MODEL");
          document.getElementById("apiURL").value = window.localStorage.getItem("apiURL");
          document.getElementById("apiKEY").value = window.localStorage.getItem("apiKEY");
          document.getElementById("MODEL").value = window.localStorage.getItem("MODEL");
        });
        async function testAPI() {
          isLoading.value = true;
          const res = await window.api.invoke("renderer-to-main-async", {
            name: "test-api",
            event: "asyncevent",
            data: {
              "apiURL": configForm.apiURL,
              "apiKEY": configForm.apiKEY,
              "request": {
                model: configForm.MODEL,
                messages: [
                  {
                    role: "user",
                    content: "Hi, I'm testing your API. If you can response to this message, please return 'Hi Miaa, I'm {{Your_Model_Name}}. Your API is ok.' with the Your_Model_Name is the name of you."
                  }
                ]
              }
            }
          });
          alert(res);
          isLoading.value = false;
        }
        return (_ctx, _cache) => {
          const _component_el_input = ElInput;
          const _component_el_form_item = ElFormItem;
          const _component_el_button = ElButton;
          const _component_el_form = ElForm;
          const _directive_loading = vLoading;
          return withDirectives((openBlock(), createBlock(_component_el_form, {
            ref: "configFormTag",
            model: configForm,
            class: "configForm"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_form_item, { label: "apiURL" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    id: "apiURL",
                    modelValue: configForm.apiURL,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => configForm.apiURL = $event),
                    autocomplete: "off"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, { label: "apiKEY" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    id: "apiKEY",
                    modelValue: configForm.apiKEY,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => configForm.apiKEY = $event),
                    autocomplete: "off"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, { label: "MODEL" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    id: "MODEL",
                    modelValue: configForm.MODEL,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => configForm.MODEL = $event),
                    autocomplete: "off"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, null, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    type: "default",
                    onClick: _cache[3] || (_cache[3] = ($event) => submitForm())
                  }, {
                    default: withCtx(() => _cache[5] || (_cache[5] = [
                      createTextVNode(" Save ")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "default",
                    onClick: _cache[4] || (_cache[4] = ($event) => testAPI())
                  }, {
                    default: withCtx(() => _cache[6] || (_cache[6] = [
                      createTextVNode(" Test API ")
                    ])),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["model"])), [
            [_directive_loading, isLoading.value]
          ]);
        };
      }
    };
    const configWindow = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__scopeId", "data-v-38ac2f51"]]);
    const useCatlogAddingStore = /* @__PURE__ */ defineStore("catlogAdding", {
      state: () => ({
        points: []
      }),
      getters: {
        getPointList() {
          return self.points;
        }
      },
      actions: {
        getLength() {
          return this.points.length;
        },
        setList(ref2) {
          this.points = ref2;
        }
      }
    });
    const _sfc_main$3 = {
      setup() {
        const messages2 = ref([
          { role: "assistant", text: "Hi, I'm Miaa! Your AI Assistant helping you generate medical image description. Now I could help you generate a new set of key-points that meet your requirement of a specific medical image catalog, please let me know the catalog of the medical image." }
        ]);
        const userInput = ref("");
        const CatlogAddingStore = useCatlogAddingStore();
        const sendMessage = async () => {
          if (!userInput.value.trim()) return;
          messages2.value.push({ role: "user", text: userInput.value });
          userInput.value;
          userInput.value = "";
          await nextTick();
          scrollToBottom();
          messages2.value.push({ role: "assistant", text: "Waiting..." });
          nextTick().then(scrollToBottom);
          const res = await window.api.invoke("renderer-to-main-async", {
            name: "addcat-chat",
            event: "asyncevent",
            data: {
              "apiURL": window.localStorage.getItem("apiURL"),
              "apiKEY": window.localStorage.getItem("apiKEY"),
              "request": {
                model: window.localStorage.getItem("MODEL"),
                messages: messages2.value.reduce((acc, item) => {
                  acc.push({
                    "role": item.role,
                    "content": item.text
                  });
                  return acc;
                }, [])
              }
            }
          });
          messages2.value.pop();
          nextTick().then(scrollToBottom);
          try {
            const regex = /<json>([\s\S]*?)<\/json>/;
            const match = res.match(regex);
            const res_json = JSON.parse(match[1]);
            CatlogAddingStore.setList(res_json["key_points"]);
            if ("massage" in res_json) {
              messages2.value.push({ role: "assistant", text: res_json["massage"] });
            } else {
              messages2.value.push({ role: "assistant", text: "I have done the work, let me show you the key points below." });
            }
          } catch {
            messages2.value.push({ role: "assistant", text: res });
          }
          nextTick().then(scrollToBottom);
        };
        const scrollToBottom = () => {
          const chatContainer = document.querySelector(".chat-container");
          if (chatContainer) {
            chatContainer.scrollTop = chatContainer.scrollHeight;
          }
        };
        return { messages: messages2, userInput, sendMessage, scrollToBottom };
      }
    };
    const _hoisted_1 = { class: "chat-container" };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_col = ElCol;
      const _component_el_row = ElRow;
      const _component_el_button = ElButton;
      const _component_el_input = ElInput;
      return openBlock(), createBlock(_component_el_col, {
        span: 22,
        justify: "center",
        class: "style-color-3 chat-panel"
      }, {
        default: withCtx(() => [
          createVNode(_component_el_row, {
            span: 24,
            justify: "center"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_col, { span: 22 }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($setup.messages, (message, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: index,
                        class: normalizeClass(["message", message.role])
                      }, toDisplayString(message.text), 3);
                    }), 128))
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_row, {
            span: 24,
            justify: "center"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_col, { span: 20 }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    modelValue: $setup.userInput,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.userInput = $event),
                    placeholder: "Type a message...",
                    onKeyup: withKeys($setup.sendMessage, ["enter"]),
                    size: "large"
                  }, {
                    append: withCtx(() => [
                      createVNode(_component_el_button, {
                        onClick: $setup.sendMessage,
                        round: ""
                      }, {
                        default: withCtx(() => _cache[1] || (_cache[1] = [
                          createTextVNode("Send")
                        ])),
                        _: 1
                      }, 8, ["onClick"])
                    ]),
                    _: 1
                  }, 8, ["modelValue", "onKeyup"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_row, {
            span: 24,
            style: { "height": "10px" }
          })
        ]),
        _: 1
      });
    }
    const ChatAssis = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$1]]);
    const _sfc_main$2 = {
      setup() {
        const cataddStore = useCatlogAddingStore();
        const itemList = computed(() => cataddStore.points);
        const dialogVisible = ref(false);
        const nameInput = ref("");
        const doneVisble = ref(false);
        const openDialog = () => {
          dialogVisible.value = true;
        };
        const addItem = () => {
          itemList.value.push({ name: "", importance: "optional", description: "" });
        };
        const removeItem = (index) => {
          itemList.value.splice(index, 1);
        };
        const saveList = () => {
          window.api.invoke("renderer-to-main", {
            name: "save-points",
            event: "cevent",
            data: {
              "name": nameInput.value,
              "points": JSON.stringify(itemList.value, null, 2)
            }
          });
          doneVisble.value = true;
          dialogVisible.value = false;
          setTimeout(() => {
            doneVisble.value = false;
          }, 2e3);
        };
        return { itemList, cataddStore, dialogVisible, nameInput, doneVisble, addItem, removeItem, saveList, openDialog };
      },
      computed: {
        isEmpty() {
          return this.cataddStore.getLength() === 0;
        }
      }
    };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_input = ElInput;
      const _component_el_button = ElButton;
      const _component_el_dialog = ElDialog;
      const _component_el_col = ElCol;
      const _component_el_alert = ElAlert;
      const _component_el_radio = ElRadio;
      const _component_el_radio_group = ElRadioGroup;
      const _component_el_row = ElRow;
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_el_dialog, {
          modelValue: $setup.dialogVisible,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.dialogVisible = $event),
          title: "Enter Name"
        }, {
          footer: withCtx(() => [
            createVNode(_component_el_button, {
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.dialogVisible = false)
            }, {
              default: withCtx(() => _cache[3] || (_cache[3] = [
                createTextVNode("Cancel")
              ])),
              _: 1
            }),
            createVNode(_component_el_button, {
              type: "primary",
              onClick: $setup.saveList
            }, {
              default: withCtx(() => _cache[4] || (_cache[4] = [
                createTextVNode("Save")
              ])),
              _: 1
            }, 8, ["onClick"])
          ]),
          default: withCtx(() => [
            createVNode(_component_el_input, {
              modelValue: $setup.nameInput,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.nameInput = $event),
              placeholder: "Enter the name of new catalog"
            }, null, 8, ["modelValue"])
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createVNode(_component_el_col, {
          span: 22,
          class: "style-color-2 points-panel"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_row, {
              span: 22,
              justify: "center",
              class: "list-container"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_col, { span: 24 }, {
                  default: withCtx(() => [
                    withDirectives(createVNode(_component_el_col, null, {
                      default: withCtx(() => _cache[5] || (_cache[5] = [
                        createBaseVNode("h1", null, "Chat with Miaa to help you generate the key points.", -1)
                      ])),
                      _: 1
                    }, 512), [
                      [vShow, $options.isEmpty]
                    ]),
                    withDirectives(createVNode(_component_el_alert, {
                      title: "Successfully saved",
                      type: "success",
                      description: "More text description",
                      "show-icon": ""
                    }, null, 512), [
                      [vShow, $setup.doneVisble]
                    ]),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($setup.itemList, (item, index) => {
                      return openBlock(), createBlock(_component_el_col, {
                        key: index,
                        class: "list-item"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: item.title,
                            "onUpdate:modelValue": ($event) => item.title = $event,
                            style: { "width": "22%" },
                            placeholder: "Enter name"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(_component_el_radio_group, {
                            modelValue: item.importance,
                            "onUpdate:modelValue": ($event) => item.importance = $event,
                            style: { "width": "22%", "background-color": "white", "padding": "0px 10px 0px 10px", "align-content": "center", "border-radius": "2px" }
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_radio, { value: "required" }, {
                                default: withCtx(() => _cache[6] || (_cache[6] = [
                                  createTextVNode("Required")
                                ])),
                                _: 1
                              }),
                              createVNode(_component_el_radio, { value: "optional" }, {
                                default: withCtx(() => _cache[7] || (_cache[7] = [
                                  createTextVNode("Optional")
                                ])),
                                _: 1
                              })
                            ]),
                            _: 2
                          }, 1032, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(_component_el_input, {
                            modelValue: item.explanation,
                            "onUpdate:modelValue": ($event) => item.explanation = $event,
                            type: "textarea",
                            rows: "1",
                            resize: "none",
                            style: { "width": "56%" },
                            placeholder: "Enter description"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(_component_el_button, {
                            type: "danger",
                            onClick: ($event) => $setup.removeItem(index)
                          }, {
                            default: withCtx(() => _cache[8] || (_cache[8] = [
                              createTextVNode("Delete")
                            ])),
                            _: 2
                          }, 1032, ["onClick"])
                        ]),
                        _: 2
                      }, 1024);
                    }), 128))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createVNode(_component_el_row, {
              span: 24,
              justify: "end",
              style: { "margin": "10px" }
            }, {
              default: withCtx(() => [
                createVNode(_component_el_col, { span: 3 }, {
                  default: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "primary",
                      onClick: $setup.addItem
                    }, {
                      default: withCtx(() => _cache[9] || (_cache[9] = [
                        createTextVNode("+ Add Item")
                      ])),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_col, { span: 3 }, {
                  default: withCtx(() => [
                    createVNode(_component_el_button, {
                      type: "success",
                      onClick: $setup.openDialog
                    }, {
                      default: withCtx(() => _cache[10] || (_cache[10] = [
                        createTextVNode("Save List")
                      ])),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ], 64);
    }
    const PointsTable = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render]]);
    const _sfc_main$1 = {
      __name: "CatlogAdding",
      setup(__props) {
        return (_ctx, _cache) => {
          const _component_el_row = ElRow;
          const _component_el_col = ElCol;
          return openBlock(), createBlock(_component_el_col, {
            span: 24,
            class: "style-color-1"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_row, {
                span: 24,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createVNode(ChatAssis)
                ]),
                _: 1
              }),
              createVNode(_component_el_row, {
                span: 24,
                justify: "center"
              }, {
                default: withCtx(() => [
                  createVNode(PointsTable)
                ]),
                _: 1
              })
            ]),
            _: 1
          });
        };
      }
    };
    const _sfc_main = {
      __name: "addCatWin",
      setup(__props) {
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$1);
        };
      }
    };
    const routes = [
      {
        path: "/",
        name: "Home",
        component: mainWindow
      },
      {
        path: "/config",
        // Route for child window
        name: "Config",
        component: configWindow
      },
      {
        path: "/addcat",
        // Route for child window
        name: "AddCat",
        component: _sfc_main
      }
    ];
    const router = createRouter({
      history: createWebHashHistory(),
      routes
    });
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && (e.key === "z" || e.key === "Z" || e.key === "y" || e.key === "Y")) {
        const active = document.activeElement;
        if (!active || active.tagName.toLowerCase() !== "textarea") {
          e.preventDefault();
        }
      }
    });
    const app = createApp(App);
    app.use(router);
    app.use(createPinia());
    app.mount("#app");
  }
});
export default require_index_001();
